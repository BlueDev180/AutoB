<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rogue War TFT Roguelike</title>

  <style>
    :root{
      --bg:#0b0e14;
      --panel:#0f1420;
      --panel2:#0c1220;
      --b:#1d2638;
      --b2:#2a3a63;
      --text:#e8eefc;
      --muted:#9fb0d8;
      --good:#55d38a;
      --bad:#ff5c7a;
      --accent:#6aa6ff;

      --rar-common:#8ea0c6;
      --rar-uncommon:#55d38a;
      --rar-rare:#6aa6ff;
      --rar-epic:#b27bff;
      --rar-legendary:#ffd36a;

      --dmg:#ff5c7a;
      --heal:#55d38a;
      --shield:#6aa6ff;
      --tag:#cfe0ff;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html, body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
    }

    .app{
      height:100dvh;
      padding: env(safe-area-inset-top) 10px env(safe-area-inset-bottom) 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      overflow:hidden;
    }

    .screen{
      display:none;
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
    }
    body[data-screen="menu"] .screenMenu{ display:flex; }
    body[data-screen="planning"] .screenPlanning{ display:flex; }
    body[data-screen="battle"] .screenBattle{ display:flex; }

    /* ===== Toast (override) ===== */
    #toast{
      position:fixed;
      left:50%;
      top: calc(env(safe-area-inset-top) + 10px);
      transform: translateX(-50%) translateY(-8px);
      max-width: 92vw;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(15,20,32,0.92);
      border: 1px solid rgba(42,58,99,0.95);
      color: var(--text);
      font-weight: 1000;
      font-size: 14px;
      line-height: 1.2;
      text-align:center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      backdrop-filter: blur(10px);
      transition: opacity 120ms ease, transform 250ms ease, box-shadow 250ms ease, border-color 250ms ease;

      white-space: normal;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #toast.show{ opacity: 1; transform: translateX(-50%) translateY(0px); }
    #toast.good{ border-color: rgba(85,211,138,0.70); box-shadow: 0 0 0 1px rgba(85,211,138,0.12) inset; }
    #toast.bad{ border-color: rgba(255,92,122,0.70); box-shadow: 0 0 0 1px rgba(255,92,122,0.12) inset; }

    .panel{
      background:var(--panel);
      border:1px solid var(--b);
      border-radius:14px;
      padding:10px;
      overflow:hidden;
    }
    .panelTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
      min-width:0;
    }
    .panelTitle{
      font-size:13px;
      font-weight:1000;
      color:#cfe0ff;
      white-space:nowrap;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 62vw;
    }

    button{
      background:#1a2540;
      color:var(--text);
      border:1px solid var(--b2);
      border-radius:12px;
      padding:12px 14px;
      font-weight:1000;
      font-size:13px;
      line-height:1;
      min-height:44px;
      touch-action: manipulation;
      white-space:nowrap;
    }
    button:disabled{ opacity:.5; }
    .btnPrimary{
      border-color: rgba(106,166,255,0.85);
      box-shadow: 0 0 0 1px rgba(106,166,255,0.20) inset;
    }
    .btnGhost{ background:#121a2c; border-color:#24345b; }

    .pill{
      border:1px solid var(--b2);
      background:#111a2c;
      padding:7px 10px;
      border-radius:999px;
      font-size:12px;
      color:#b9c6e6;
      white-space:nowrap;
    }
    .pillGood{ border-color: rgba(85,211,138,0.75); color:#c9ffe2; }
    .pillBad{ border-color: rgba(255,92,122,0.75); color:#ffd0d9; }

    /* ===== MENU ===== */
    .menuWrap{ flex:1 1 auto; min-height:0; display:flex; flex-direction:column; gap:10px; overflow:hidden; justify-content:center; }
    .menuCard{ width:min(520px, 100%); margin:0 auto; display:flex; flex-direction:column; gap:10px; }
    .menuTitle{ font-size:18px; font-weight:1200; letter-spacing:0.4px; color:#d6e4ff; margin-bottom:2px; text-align:center; }
    .menuSub{ font-size:12px; color:var(--muted); text-align:center; line-height:1.35; margin-bottom:6px; }
    .menuBtns{ display:flex; flex-direction:column; gap:10px; }
    .howto{
      display:none;
      background:rgba(12,18,32,0.92);
      border:1px solid rgba(42,58,99,0.95);
      border-radius:14px;
      padding:12px;
      line-height:1.35;
      color:#cfe0ff;
      font-size:13px;
    }
    body[data-howto="open"] .howto{ display:block; }

    /* ===== PLANNING ===== */
    .planningWrap{ flex:1 1 auto; min-height:0; display:flex; flex-direction:column; gap:10px; overflow:hidden; }
    .topPlanning{ flex:0 0 auto; }
    .topGrid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    .phaseRow{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .phaseLabel{
      font-weight:1100;
      font-size:12px;
      letter-spacing:1px;
      color:#cfe0ff;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--b2);
      background:#0e1627;
      white-space:nowrap;
    }

    .statStrip{ display:grid; grid-template-columns: repeat(4, minmax(0,1fr)); gap:8px; }
    @media (max-width: 420px){ .statStrip{ grid-template-columns: repeat(2, minmax(0,1fr)); } }
    .statTile{
      background:var(--panel2);
      border:1px solid var(--b);
      border-radius:14px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:2px;
      min-height:64px;
    }
    .statTile .lab{ font-size:11px; color:#b9c6e6; font-weight:900; letter-spacing:0.3px; }
    .statTile .val{ font-size:20px; font-weight:1200; color:var(--text); line-height:1.05; }

    .actionRow{ display:grid; grid-template-columns: 1fr 1.2fr; gap:8px; }
    @media (max-width: 420px){ .actionRow{ grid-template-columns: 1fr 1fr; } }

    .planningBody{ flex:1 1 auto; min-height:0; display:flex; flex-direction:column; gap:10px; overflow:hidden; }
    .shopPanel{ flex: 1 1 58%; min-height:0; display:flex; flex-direction:column; }
    .armyPanel{ flex: 1 1 42%; min-height:0; display:flex; flex-direction:column; }

    .shop{
      flex:1 1 auto; min-height:0; display:flex; gap:10px;
      overflow-x:auto; overflow-y:hidden;
      -webkit-overflow-scrolling: touch; scrollbar-width:none; padding-bottom:2px;
    }
    .shop::-webkit-scrollbar{ display:none; }
    .card{
      flex: 0 0 215px;
      background:var(--panel2);
      border:1px solid var(--b);
      border-radius:14px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      position:relative;
      overflow:hidden;
    }
    .rarStrip{
      position:absolute; left:0; top:0; bottom:0;
      width:6px;
      opacity:0.95;
      background: var(--rar-common);
    }
    .card h4{
      margin:0;
      font-size:15px;
      color:var(--text);
      font-weight:1100;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-width:0;
    }
    .card h4 span:first-child{
      min-width:0;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .card .badge{
      width:10px; height:10px; border-radius:999px;
      background:#fff;
      flex:0 0 auto;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25);
    }
    /* Make long trait/class text not "cut" */
    .line{
      font-size:12px;
      color:var(--muted);
      white-space: normal;
      line-height: 1.25;
      word-break: break-word;
    }

    .armyBar{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      gap:10px;
      overflow-x:auto;
      overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      scrollbar-width:none;
      padding-bottom:2px;
    }
    .armyBar::-webkit-scrollbar{ display:none; }
    .chip{
      flex:0 0 auto;
      background:#12203b;
      border:1px solid var(--b2);
      border-radius:12px;
      padding:10px 12px;
      min-width: 168px;
      display:flex;
      flex-direction:column;
      gap:4px;
      position:relative;
      overflow:hidden;
      border-left: 6px solid #6aa6ff;
    }
    .chip .t{ font-weight:1100; font-size:13px; display:flex; align-items:center; justify-content:space-between; gap:8px; min-width:0; }
    .chip .t span:first-child{ min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .chip .s{ font-size:12px; color:#cfe0ff; opacity:.95; }
    /* Clamp class/trait line to 2 lines so it isn't cut weirdly */
    .chip .m{
      font-size:12px;
      color:var(--muted);
      line-height:1.25;
      white-space: normal;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      padding-top: 1px;
    }

    .rarMini{
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(42,58,99,0.95);
      background:#10192e;
      color:#cfe0ff;
      line-height:1;
      flex:0 0 auto;
      white-space:nowrap;
    }

    .armyHeaderRight{
      display:flex;
      gap:8px;
      align-items:center;
      flex:0 0 auto;
    }
    .armyHeaderRight button{
      min-height:40px;
      padding:10px 12px;
    }

    /* ===== BATTLE ===== */
    .battleWrap{ flex:1 1 auto; min-height:0; display:flex; flex-direction:column; overflow:hidden; }
    .battleCanvasWrap{
      flex:1 1 auto;
      min-height:0;
      background:var(--panel2);
      border:1px solid var(--b);
      border-radius:14px;
      overflow:hidden;
      position:relative;
    }
    canvas{ width:100%; height:100%; display:block; }

    .overlayTop{
      position:absolute;
      top:10px;
      left:10px;
      right:10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
    }
    .overlayTop .left{ display:flex; flex-direction:column; gap:8px; min-width:0; pointer-events:none; }
    .overlayTop .right{ display:flex; gap:8px; align-items:center; pointer-events:none; }
    .overlayTop .left .pill{ white-space:normal; line-height:1.15; max-width: 76vw; }
    .overlayTop button{ pointer-events:auto; }

    .resultBox{
      position:absolute;
      left:10px;
      right:10px;
      top:50%;
      transform:translateY(-50%);
      background:rgba(15,20,32,0.92);
      border:1px solid rgba(42,58,99,0.95);
      border-radius:16px;
      padding:14px;
      backdrop-filter: blur(10px);
      display:none;
      z-index: 30;
    }
    body[data-result="show"] .resultBox{ display:block; }
    .resultBox .rTitle{ font-weight:1200; font-size:16px; margin-bottom:6px; }
    .resultBox .rText{ font-size:13px; color:var(--muted); margin-bottom:10px; line-height:1.35; }
    .resultBox .rBtns{ display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap; }

    /* ===== Fullscreen overlays ===== */
    .fsOverlay{
      position:fixed;
      inset:0;
      z-index: 20000;
      padding: calc(env(safe-area-inset-top) + 10px) 10px calc(env(safe-area-inset-bottom) + 10px) 10px;
      background: rgba(6,8,12,0.78);
      backdrop-filter: blur(10px);
      display:none;
      overflow:hidden;
      touch-action: none;
    }
    body[data-overlay="augment"] #ovAugment{ display:block; }
    body[data-overlay="item"] #ovItem{ display:block; }
    body[data-overlay="node"] #ovNode{ display:block; }
    body[data-overlay="event"] #ovEvent{ display:block; }
    body[data-overlay="inventory"] #ovInventory{ display:block; }
    body[data-overlay="synergies"] #ovSynergies{ display:block; }
    body[data-overlay="replace"] #ovReplace{ display:block; }

    .ovCard{
      height:100%;
      max-width: 560px;
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
      min-height:0;
    }
    .ovHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      min-width:0;
    }
    .ovTitle{ font-size:16px; font-weight:1200; color:#d6e4ff; }
    .ovSub{ font-size:12px; color:var(--muted); line-height:1.35; }
    .ovBody{
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .vStack{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-bottom:2px;
      touch-action: pan-y;
    }
    .choiceCard{
      background: rgba(12,18,32,0.92);
      border: 1px solid rgba(42,58,99,0.95);
      border-radius: 14px;
      padding: 12px;
      display:flex;
      flex-direction:column;
      gap:6px;
      position:relative;
      overflow:hidden;
    }
    .choiceCard .name{ font-weight:1200; display:flex; align-items:center; justify-content:space-between; gap:10px; min-width:0; }
    .choiceCard .name span:first-child{ min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .choiceCard .desc{ font-size:12px; color:var(--muted); line-height:1.35; word-break:break-word; }
    .choiceCard button{ width:100%; }

    /* Inventory layout: ALWAYS 2 columns, both scroll independently */
    .twoCols{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      min-height:0;
      flex:1 1 auto;
      overflow:hidden;
    }
    .invList{
      min-height:0;
      flex:1 1 auto;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      display:flex;
      flex-direction:column;
      gap:10px;
      touch-action: pan-y;
      padding-bottom:2px;
    }

    /* Hide old tab UI completely */
    #invTabsWrap{ display:none !important; }

    .slotRow{
      display:flex; gap:6px; flex-wrap:wrap;
      align-items:center;
    }
    .slotPill{
      font-size:11px;
      padding:5px 8px;
      border-radius:999px;
      border:1px solid rgba(42,58,99,0.95);
      background:#0f1830;
      color:#cfe0ff;
      line-height:1;
      white-space:nowrap;
    }
    .slotEmpty{ opacity:0.55; }

    @media (max-width: 380px){
      .card{ flex-basis: 205px; }
      .chip{ min-width: 156px; }
      button{ padding:12px 12px; }
      .statTile .val{ font-size:19px; }
      #toast{ font-size:13px; }
    }
  </style>
</head>

<body data-screen="menu" data-result="hide" data-howto="closed" data-overlay="none">
  <div id="toast" role="status" aria-live="polite"></div>

  <!-- ===== Fullscreen overlays ===== -->
  <div class="fsOverlay" id="ovAugment" aria-hidden="true">
    <div class="ovCard">
      <div class="panel">
        <div class="ovHeader">
          <div>
            <div class="ovTitle">Choose an Augment</div>
            <div class="ovSub">Pick 1. It lasts for the entire run.</div>
          </div>
        </div>
      </div>
      <div class="ovBody">
        <div class="vStack" id="augmentChoices"></div>
      </div>
    </div>
  </div>

  <div class="fsOverlay" id="ovItem" aria-hidden="true">
    <div class="ovCard">
      <div class="panel">
        <div class="ovHeader">
          <div>
            <div class="ovTitle" id="itemRewardTitle">Item Found</div>
            <div class="ovSub" id="itemRewardSub">Add it to your inventory, then equip in Planning.</div>
          </div>
          <button id="btnItemContinue" class="btnPrimary" style="min-height:40px; padding:10px 12px;">Continue</button>
        </div>
      </div>
      <div class="ovBody">
        <div class="choiceCard" id="itemRewardCard"></div>
      </div>
    </div>
  </div>

  <div class="fsOverlay" id="ovNode" aria-hidden="true">
    <div class="ovCard">
      <div class="panel">
        <div class="ovHeader">
          <div>
            <div class="ovTitle">Choose Next Node</div>
            <div class="ovSub">Battle for progress, Elite for better rewards, or Event for risk/reward.</div>
          </div>
        </div>
      </div>
      <div class="ovBody">
        <div class="vStack" id="nodeChoices"></div>
      </div>
    </div>
  </div>

  <div class="fsOverlay" id="ovEvent" aria-hidden="true">
    <div class="ovCard">
      <div class="panel">
        <div class="ovHeader">
          <div>
            <div class="ovTitle">Event</div>
            <div class="ovSub">Pick one outcome.</div>
          </div>
        </div>
      </div>
      <div class="ovBody">
        <div class="vStack" id="eventChoices"></div>
      </div>
    </div>
  </div>

  <!-- Synergies overlay -->
  <div class="fsOverlay" id="ovSynergies" aria-hidden="true">
    <div class="ovCard">
      <div class="panel">
        <div class="ovHeader">
          <div>
            <div class="ovTitle">Synergies</div>
            <div class="ovSub">All traits + breakpoints (crests included).</div>
          </div>
          <button id="btnSynClose" class="btnPrimary" style="min-height:40px; padding:10px 12px;">Close</button>
        </div>
      </div>
      <div class="ovBody">
        <div class="vStack" id="synergyList"></div>
      </div>
    </div>
  </div>

  <!-- Replace overlay (when item slots full) -->
  <div class="fsOverlay" id="ovReplace" aria-hidden="true">
    <div class="ovCard">
      <div class="panel">
        <div class="ovHeader">
          <div>
            <div class="ovTitle">Replace an Item</div>
            <div class="ovSub" id="replaceSub">Choose which slot to replace.</div>
          </div>
          <button id="btnReplaceCancel" class="btnPrimary" style="min-height:40px; padding:10px 12px;">Cancel</button>
        </div>
      </div>
      <div class="ovBody">
        <div class="vStack" id="replaceChoices"></div>
      </div>
    </div>
  </div>

  <!-- Inventory overlay -->
  <div class="fsOverlay" id="ovInventory" aria-hidden="true">
    <div class="ovCard">
      <div class="panel">
        <div class="ovHeader">
          <div>
            <div class="ovTitle">Inventory</div>
            <div class="ovSub" id="invHint">Tap an item, then tap a unit to equip. Unequip returns to inventory.</div>
          </div>
          <button id="btnInvClose" class="btnPrimary" style="min-height:40px; padding:10px 12px;">Close</button>
        </div>
      </div>

      <!-- old tabs kept but fully hidden via CSS -->
      <div class="panel" style="padding:10px;" id="invTabsWrap">
        <div class="invTabs">
          <button id="btnInvTabItems" class="btnPrimary">Items</button>
          <button id="btnInvTabUnits" class="btnGhost">Units</button>
        </div>
      </div>

      <div class="ovBody twoCols" id="invGrid">
        <div class="panel" id="invPaneItems" style="min-height:0; overflow:hidden; display:flex; flex-direction:column; gap:10px;">
          <div class="panelTop">
            <div class="panelTitle">Items</div>
            <div class="hint" id="invCount">0</div>
          </div>
          <div class="invList" id="invItems"></div>
        </div>

        <div class="panel" id="invPaneUnits" style="min-height:0; overflow:hidden; display:flex; flex-direction:column; gap:10px;">
          <div class="panelTop">
            <div class="panelTitle">Units</div>
            <div class="hint" id="invUnitsCount">0</div>
          </div>
          <div class="invList" id="invUnits"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="app">

    <!-- MENU -->
    <div class="screen screenMenu">
      <div class="menuWrap">
        <div class="menuCard panel">
          <div class="menuTitle">ROGUE WAR</div>
          <div class="menuSub">TFT roguelike: synergies, augments, items, rarity, permadeath.</div>

          <div class="menuBtns">
            <button id="btnNewGame" class="btnPrimary">New Game</button>
            <button id="btnContinue" disabled>Continue</button>
            <button id="btnHowTo" class="btnGhost">How to Play</button>
          </div>

          <div class="howto" id="howtoBox">
            <div style="font-weight:1000; margin-bottom:6px;">How to Play</div>
            <div>1) Buy units (buying removes the offer).</div>
            <div>2) 3-of-a-kind merges → ★ up (items return).</div>
            <div>3) Synergies activate at breakpoints.</div>
            <div>4) Augments every 3 rounds (and from elites).</div>
            <div>5) Items: higher rarity units hold more.</div>
            <div>6) Permadeath: units that die in battle are removed (items return).</div>
          </div>
        </div>
      </div>
    </div>

    <!-- PLANNING -->
    <div class="screen screenPlanning">
      <div class="planningWrap">

        <div class="panel topPlanning">
          <div class="topGrid">
            <div class="phaseRow">
              <div class="phaseLabel">PLANNING</div>
              <div style="display:flex; gap:8px; align-items:center;">
                <div class="pill" id="unitsPill">Units: 0</div>
                <button id="btnInventory" class="btnGhost" style="min-height:40px; padding:10px 12px;">Inventory</button>
                <button id="btnMenu" class="btnGhost" style="min-height:40px; padding:10px 12px;">Menu</button>
              </div>
            </div>

            <div class="statStrip" aria-label="stats">
              <div class="statTile">
                <div class="lab">ROUND</div>
                <div class="val" id="roundVal">1</div>
              </div>
              <div class="statTile">
                <div class="lab">GOLD</div>
                <div class="val" id="goldVal">10</div>
              </div>
              <div class="statTile">
                <div class="lab">HP</div>
                <div class="val" id="hpVal">20</div>
              </div>
              <div class="statTile">
                <div class="lab">STREAK</div>
                <div class="val" id="streakVal">0</div>
              </div>
            </div>

            <div class="actionRow">
              <button id="btnReroll">Reroll</button>
              <button id="btnStart" class="btnPrimary">Start Fight</button>
            </div>
          </div>
        </div>

        <div class="planningBody">
          <div class="panel shopPanel">
            <div class="panelTop">
              <div class="panelTitle">Shop</div>
              <div class="hint">3-of-a-kind merges → ★ up</div>
            </div>
            <div class="shop" id="shop"></div>
          </div>

          <div class="panel armyPanel">
            <div class="panelTop">
              <div class="panelTitle">Your Army</div>
              <div class="armyHeaderRight">
                <button id="btnSynergies" class="btnGhost">Synergies</button>
                <div class="pill">Permadeath ON</div>
              </div>
            </div>
            <div class="armyBar" id="armyBar"></div>
          </div>
        </div>

      </div>
    </div>

    <!-- BATTLE -->
    <div class="screen screenBattle">
      <div class="battleWrap">
        <div class="battleCanvasWrap">
          <canvas id="battle"></canvas>

          <div class="overlayTop">
            <div class="left">
              <div class="pill" id="battleNodePill">BATTLE</div>
              <div class="pill" id="battleStats">Round 1 • Gold 10 • HP 20 • Streak 0</div>
            </div>
            <div class="right">
              <button id="btnNext" disabled>Next</button>
            </div>
          </div>

          <div class="resultBox" id="resultBox">
            <div class="rTitle" id="resultTitle">Result</div>
            <div class="rText" id="resultText">...</div>
            <div class="rBtns">
              <button id="btnResultNext" class="btnPrimary" disabled>Next</button>
            </div>
          </div>

        </div>
      </div>
    </div>

  </div>

<script>
/* ---- iPhone error overlay ---- */
window.addEventListener("error", (e) => {
  const box = document.createElement("pre");
  box.style.position="fixed";
  box.style.left="0"; box.style.right="0"; box.style.bottom="0";
  box.style.maxHeight="45vh"; box.style.overflow="auto";
  box.style.zIndex="99999"; box.style.margin="0"; box.style.padding="12px";
  box.style.background="rgba(0,0,0,0.92)"; box.style.color="white"; box.style.fontSize="12px";
  box.textContent = "JS ERROR:\n" + (e.message||"Unknown") + "\n\n" + (e.filename||"") + ":" + (e.lineno||"") + ":" + (e.colno||"");
  document.body.appendChild(box);
});

/* ===== Toast (override, no queue) ===== */
const toastEl = document.getElementById("toast");
let toastTimer = null;
function showToast(text, type="info"){
  clearTimeout(toastTimer);
  toastEl.classList.remove("good","bad","show");
  if (type === "good") toastEl.classList.add("good");
  if (type === "bad") toastEl.classList.add("bad");
  toastEl.textContent = text;
  void toastEl.offsetWidth;
  toastEl.classList.add("show");
  toastTimer = setTimeout(() => toastEl.classList.remove("show"), 1000);
}

/* ===== Helpers ===== */
function rndId(){ return (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random()).slice(2); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function chance(p){ return Math.random() < p; }
function randi(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

/* ===== Rarity helpers ===== */
const RARITIES = ["Common","Uncommon","Rare","Epic","Legendary"];
function rarityColor(r){
  if (r==="Uncommon") return getCSS("--rar-uncommon");
  if (r==="Rare") return getCSS("--rar-rare");
  if (r==="Epic") return getCSS("--rar-epic");
  if (r==="Legendary") return getCSS("--rar-legendary");
  return getCSS("--rar-common");
}
function raritySlots(r){
  if (r==="Legendary") return 3;
  if (r==="Epic") return 2;
  if (r==="Rare") return 2;
  return 1;
}
function getCSS(varName){
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
}

/* ===== Definitions ===== */
const UNIT_POOL = [
  { name:"Brawler",  rarity:"Common",    cost:1, hp: 260, atk: 18, spd: 1.00, range: 18,  role:"Front",    classTag:"Warrior", originTag:"Kingdom" },
  { name:"Knight",   rarity:"Uncommon",  cost:2, hp: 320, atk: 22, spd: 1.05, range: 18,  role:"Front",    classTag:"Warrior", originTag:"Kingdom" },
  { name:"Archer",   rarity:"Common",    cost:1, hp: 180, atk: 26, spd: 0.95, range: 150, role:"Back",     classTag:"Ranger",  originTag:"Wilds"   },
  { name:"Mage",     rarity:"Uncommon",  cost:2, hp: 170, atk: 34, spd: 1.15, range: 160, role:"Mage",     classTag:"Mage",    originTag:"Cult"    },
  { name:"Assassin", rarity:"Rare",      cost:3, hp: 190, atk: 46, spd: 0.75, range: 22,  role:"Skirmish", classTag:"Rogue",   originTag:"Wilds"   },

  { name:"Spearman",    rarity:"Uncommon",  cost:2, hp: 300, atk: 24, spd: 1.00, range: 26,  role:"Front",    classTag:"Warrior", originTag:"Kingdom" },
  { name:"Healer",      rarity:"Uncommon",  cost:2, hp: 160, atk: 18, spd: 1.25, range: 170, role:"Mage",     classTag:"Mage",    originTag:"Cult"    },
  { name:"Crossbowman", rarity:"Common",    cost:1, hp: 170, atk: 30, spd: 1.10, range: 150, role:"Back",     classTag:"Ranger",  originTag:"Kingdom" },
  { name:"Berserker",   rarity:"Rare",      cost:3, hp: 360, atk: 28, spd: 1.05, range: 18,  role:"Front",    classTag:"Warrior", originTag:"Wilds"   },
  { name:"Invoker",     rarity:"Rare",      cost:3, hp: 175, atk: 32, spd: 1.05, range: 170, role:"Mage",     classTag:"Mage",    originTag:"Cult"    },
  { name:"Trapper",     rarity:"Rare",      cost:3, hp: 180, atk: 24, spd: 0.95, range: 160, role:"Back",     classTag:"Ranger",  originTag:"Wilds"   },
  { name:"Warlord",     rarity:"Epic",      cost:4, hp: 460, atk: 32, spd: 1.10, range: 22,  role:"Front",    classTag:"Warrior", originTag:"Kingdom" },
  { name:"Shade",       rarity:"Legendary", cost:5, hp: 240, atk: 60, spd: 0.75, range: 22,  role:"Skirmish", classTag:"Rogue",   originTag:"Cult"    },
];

const ITEMS = {
  I1:{ id:"I1", name:"Sword",        rarity:"Common",   desc:"+20% ATK",                apply:(c)=>{ c.atk = Math.round(c.atk*1.20); } },
  I2:{ id:"I2", name:"Shield",       rarity:"Common",   desc:"+25% Max HP",             apply:(c)=>{ c.maxHP = Math.round(c.maxHP*1.25); c.hp = c.maxHP; } },
  I3:{ id:"I3", name:"Bowstring",    rarity:"Uncommon", desc:"+15% atk speed (ranged)", apply:(c)=>{ if (isRangedUnit(c)) c.spd = c.spd*0.85; } },
  I4:{ id:"I4", name:"Scope",        rarity:"Uncommon", desc:"+30 range",               apply:(c)=>{ c.range += 30; } },
  I5:{ id:"I5", name:"Vamp Charm",   rarity:"Rare",     desc:"10% lifesteal",           apply:(c)=>{ c.lifesteal = Math.max(c.lifesteal||0, 0.10); } },
  I6:{ id:"I6", name:"Bomb",         rarity:"Rare",     desc:"First hit splashes",      apply:(c)=>{ c.bombReady = true; } },

  I7:{ id:"I7", name:"Iron Ring",    rarity:"Common",   desc:"+10% Max HP",             apply:(c)=>{ c.maxHP = Math.round(c.maxHP*1.10); c.hp = c.maxHP; } },
  I8:{ id:"I8", name:"Boots",        rarity:"Uncommon", desc:"+10% move speed",         apply:(c)=>{ c.moveMult = (c.moveMult||1) * 1.10; } },
  I9:{ id:"I9", name:"Chain Rune",   rarity:"Rare",     desc:"Every 4th hit chains",    apply:(c)=>{ c.chainEvery = 4; c.chainReady = 0; } },
  I10:{id:"I10",name:"Aegis Core",   rarity:"Epic",     desc:"Start with a shield",     apply:(c)=>{ c.startShield = 0.18; } },
  I11:{id:"I11",name:"Phoenix Feather",rarity:"Epic",   desc:"Revive once at 25% HP",   apply:(c)=>{ c.reviveOnce = true; } },
  I12:{id:"I12",name:"Chrono Relic", rarity:"Legendary",desc:"Team +10% atk speed",     apply:(c)=>{ } },
};

const AUGMENTS = {
  A1:{ id:"A1", name:"Rich Get Richer", desc:"+3g now, +1g each round", pickNow:(S)=>{ S.gold += 3; }, },
  A2:{ id:"A2", name:"High Roller", desc:"Reroll costs 1g", },
  A3:{ id:"A3", name:"Windfall", desc:"+8g now", pickNow:(S)=>{ S.gold += 8; }, },

  A4:{ id:"A4", name:"Scoped Weapons", desc:"Ranged +35 range", },
  A5:{ id:"A5", name:"Second Wind", desc:"Once per unit: below 30% HP → heal 20%", },
  A6:{ id:"A6", name:"Knife’s Edge", desc:"+20% dmg, -10% max HP", },
  A7:{ id:"A7", name:"Thick Skin", desc:"Warriors +10% dmg reduction", },
  A8:{ id:"A8", name:"Rapid Fire", desc:"Rangers attack 12% faster", },

  A9:{ id:"A9", name:"Warrior Crest", desc:"+1 Warrior trait", },
  A10:{ id:"A10", name:"Ranger Crest", desc:"+1 Ranger trait", },
  A11:{ id:"A11", name:"Mage Crest", desc:"+1 Mage trait", },
  A12:{ id:"A12", name:"Rogue Crest", desc:"+1 Rogue trait", },
};

const EVENTS = [
  {
    id:"E1", name:"Duplicate", desc:"Duplicate a random unit, lose 3 HP",
    apply:(S)=>{
      if (!S.army.length){ showToast("No units to duplicate", "bad"); return; }
      const u = pick(S.army);
      S.army.push(makeUnit(u.name, u.star, "player"));
      S.hp = Math.max(0, S.hp - 3);
      showToast(`Duplicated ${u.name} ★${u.star} (-3 HP)`, "info");
    }
  },
  {
    id:"E2", name:"Gold Rush", desc:"+10g, next battle enemies +15% HP",
    apply:(S)=>{
      S.gold += 10;
      S.nextEnemyMod = { hpMult: 1.15, atkMult: 1.0 };
      showToast("Gold Rush (+10g) — next battle tougher", "info");
    }
  },
  {
    id:"E3", name:"Heal", desc:"+6 HP, lose 4g (if possible)",
    apply:(S)=>{
      const before = S.hp;
      S.hp += 6;
      const loss = Math.min(4, S.gold);
      S.gold -= loss;
      const healed = S.hp - before;
      showToast(`Healed +${healed} HP (-${loss}g)`, "good");
    }
  },
];

/* ===== State ===== */
const SAVE_KEY_V3 = "roguewar_save_v3";
const SAVE_KEY_V2 = "roguewar_save_v2";
const SAVE_KEY_V1 = "roguewar_save_v1";

const S = {
  round: 1,
  gold: 10,
  hp: 20,
  streak: 0,

  shop: [],
  army: [],

  augments: [],
  items: [],

  node: { type:"battle", isElite:false },
  nextEnemyMod: null,

  overlay: "none",
  overlayQueue: [],

  pendingEquip: null,

  P: [],
  E: [],
  projectiles: [],
  floaters: [],

  screen: "menu",
  phase: "planning",
  combatRunning: false,
};

const el = {
  btnNewGame: document.getElementById("btnNewGame"),
  btnContinue: document.getElementById("btnContinue"),
  btnHowTo: document.getElementById("btnHowTo"),

  roundVal: document.getElementById("roundVal"),
  goldVal: document.getElementById("goldVal"),
  hpVal: document.getElementById("hpVal"),
  streakVal: document.getElementById("streakVal"),
  unitsPill: document.getElementById("unitsPill"),
  btnMenu: document.getElementById("btnMenu"),
  btnInventory: document.getElementById("btnInventory"),
  btnSynergies: document.getElementById("btnSynergies"),
  btnStart: document.getElementById("btnStart"),
  btnReroll: document.getElementById("btnReroll"),
  shop: document.getElementById("shop"),
  armyBar: document.getElementById("armyBar"),

  battleNodePill: document.getElementById("battleNodePill"),
  battleStats: document.getElementById("battleStats"),
  btnNext: document.getElementById("btnNext"),
  resultTitle: document.getElementById("resultTitle"),
  resultText: document.getElementById("resultText"),
  btnResultNext: document.getElementById("btnResultNext"),
  canvas: document.getElementById("battle"),

  augmentChoices: document.getElementById("augmentChoices"),
  itemRewardCard: document.getElementById("itemRewardCard"),
  btnItemContinue: document.getElementById("btnItemContinue"),
  nodeChoices: document.getElementById("nodeChoices"),
  eventChoices: document.getElementById("eventChoices"),

  synergyList: document.getElementById("synergyList"),
  btnSynClose: document.getElementById("btnSynClose"),

  invItems: document.getElementById("invItems"),
  invUnits: document.getElementById("invUnits"),
  invCount: document.getElementById("invCount"),
  invUnitsCount: document.getElementById("invUnitsCount"),
  invHint: document.getElementById("invHint"),
  btnInvClose: document.getElementById("btnInvClose"),

  replaceSub: document.getElementById("replaceSub"),
  replaceChoices: document.getElementById("replaceChoices"),
  btnReplaceCancel: document.getElementById("btnReplaceCancel"),
};

function hasAug(id){ return S.augments.includes(id); }

/* ===== UI state ===== */
function setOverlay(name){
  S.overlay = name;
  document.body.dataset.overlay = name;
  updateButtons();
}

function queueOverlay(name, payload=null){
  S.overlayQueue.push({ name, payload });
}
function nextOverlay(){
  const x = S.overlayQueue.shift();
  if (!x){ setOverlay("none"); return; }
  if (x.name === "augment") openAugmentPick();
  else if (x.name === "item") openItemReward(x.payload);
  else if (x.name === "node") openNodeSelect();
  else if (x.name === "event") openEventSelect();
  else if (x.name === "inventory") openInventory();
  else if (x.name === "synergies") openSynergiesOverlay();
  else setOverlay("none");
}

/* ===== Colors/shapes ===== */
function getClassColor(role){
  if (role === "Front")    return { fill:"#5c86c9", fx:"#8cc0ff" };
  if (role === "Back")     return { fill:"#55d38a", fx:"#78f0ad" };
  if (role === "Mage")     return { fill:"#b27bff", fx:"#d5b6ff" };
  if (role === "Skirmish") return { fill:"#ff8a4c", fx:"#ffd36a" };
  return { fill:"#6aa6ff", fx:"#cfe0ff" };
}
function roleToShape(role){
  if (role === "Front") return "square";
  if (role === "Back") return "triangle";
  if (role === "Skirmish") return "diamond";
  if (role === "Mage") return "hex";
  return "circle";
}
function isRangedUnit(u){
  return (u.role === "Back" || u.role === "Mage" || u.range >= 100);
}

/* ===== Unit creation ===== */
function makeUnit(name, star=1, side="player", forcedId=null){
  const t = UNIT_POOL.find(u=>u.name===name);
  const hpMult = 1 + (star-1)*0.75;
  const atkMult = 1 + (star-1)*0.60;
  const maxHP = Math.round(t.hp * hpMult);
  const clr = getClassColor(t.role);
  return {
    id: forcedId || rndId(),
    name: t.name,
    cost: t.cost,
    rarity: t.rarity || "Common",
    star,
    side,
    role: t.role,
    classTag: t.classTag,
    originTag: t.originTag,

    shape: roleToShape(t.role),
    classFill: clr.fill,
    classFx: clr.fx,

    maxHP,
    hp: maxHP,
    atk: Math.round(t.atk * atkMult),
    spd: t.spd,
    range: t.range,

    itemSlotsMax: raritySlots(t.rarity || "Common"),
    items: [],

    x:0,y:0, cd:0, alive:true,
    swingT:0, aimA:0,
  };
}

function makeOffer(template){
  return {
    offerId: rndId(),
    name: template.name,
    rarity: template.rarity || "Common",
    cost: template.cost,
    hp: template.hp,
    atk: template.atk,
    spd: template.spd,
    range: template.range,
    role: template.role,
    classTag: template.classTag,
    originTag: template.originTag,
    itemSlotsMax: raritySlots(template.rarity || "Common"),
  };
}

/* ===== Save/Load ===== */
function serializeState(){
  return {
    v: 3,
    ended: (S.hp <= 0),
    round: S.round,
    gold: S.gold,
    hp: S.hp,
    streak: S.streak,
    augments: S.augments.slice(),
    items: S.items.slice(),
    node: S.node,
    nextEnemyMod: S.nextEnemyMod,
    army: S.army.map(u => ({
      id:u.id, name:u.name, star:u.star,
      rarity:u.rarity,
      items: (u.items || []).slice(),
      classTag:u.classTag,
      originTag:u.originTag,
    })),
  };
}
function saveGame(){
  try{ localStorage.setItem(SAVE_KEY_V3, JSON.stringify(serializeState())); }catch(e){}
  refreshContinueBtn();
}
function clearSave(){
  try{ localStorage.removeItem(SAVE_KEY_V3); }catch(e){}
  refreshContinueBtn();
}
function loadGame(){
  try{
    const raw = localStorage.getItem(SAVE_KEY_V3);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (!data || data.v !== 3 || data.ended) return false;

    S.round = data.round ?? 1;
    S.gold = data.gold ?? 10;
    S.hp = data.hp ?? 20;
    S.streak = data.streak ?? 0;
    S.augments = Array.isArray(data.augments) ? data.augments : [];
    S.items = Array.isArray(data.items) ? data.items : [];
    S.node = data.node || {type:"battle", isElite:false};
    S.nextEnemyMod = data.nextEnemyMod || null;

    S.army = (data.army || []).map(a=>{
      const u = makeUnit(a.name, a.star, "player", a.id);
      u.rarity = a.rarity || u.rarity;
      u.itemSlotsMax = raritySlots(u.rarity);
      u.items = Array.isArray(a.items) ? a.items : [];
      u.classTag = a.classTag || u.classTag;
      u.originTag = a.originTag || u.originTag;
      return u;
    });

    rerollShop(true);
    renderAll();
    setScreen("planning");
    setPhase("planning");
    showToast("Continued run", "info");
    return true;
  }catch(e){
    return false;
  }
}
function tryMigrateV2(){
  try{
    const raw = localStorage.getItem(SAVE_KEY_V2);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (!data || data.ended) return false;

    S.round = data.round ?? 1;
    S.gold = data.gold ?? 10;
    S.hp = data.hp ?? 20;
    S.streak = data.streak ?? 0;
    S.augments = Array.isArray(data.augments) ? data.augments : [];
    S.items = Array.isArray(data.items) ? data.items : [];
    S.node = data.node || {type:"battle", isElite:false};
    S.nextEnemyMod = data.nextEnemyMod || null;

    S.army = (data.army || []).map(a=>{
      const u = makeUnit(a.name, a.star, "player", a.id);
      if (a.item && a.item.type){
        u.items = [{ id:rndId(), type:a.item.type }];
      } else u.items = [];
      return u;
    });

    rerollShop(true);
    saveGame();
    refreshContinueBtn();
    return true;
  }catch(e){
    return false;
  }
}
function tryMigrateV1(){
  try{
    const raw = localStorage.getItem(SAVE_KEY_V1);
    if (!raw) return false;
    const data = JSON.parse(raw);
    if (!data || data.ended) return false;

    S.round = data.round ?? 1;
    S.gold = data.gold ?? 10;
    S.hp = data.hp ?? 20;
    S.streak = data.streak ?? 0;
    S.augments = [];
    S.items = [];
    S.node = {type:"battle", isElite:false};
    S.nextEnemyMod = null;

    S.army = (data.army || []).map(a => makeUnit(a.name, a.star, "player", a.id));
    rerollShop(true);
    saveGame();
    refreshContinueBtn();
    return true;
  }catch(e){
    return false;
  }
}

function refreshContinueBtn(){
  try{
    const raw = localStorage.getItem(SAVE_KEY_V3);
    if (!raw){ el.btnContinue.disabled = true; return; }
    const data = JSON.parse(raw);
    el.btnContinue.disabled = !data || data.ended;
  }catch(e){
    el.btnContinue.disabled = true;
  }
}

/* ===== Screen state ===== */
function setScreen(screen){
  S.screen = screen;
  document.body.dataset.screen = screen;
  document.body.dataset.result = "hide";
  setTimeout(resizeCanvas, 40);
  renderStats();
  updateButtons();
}
function setPhase(phase){
  S.phase = phase;
  renderStats();
  updateButtons();
}

function renderStats(){
  el.roundVal.textContent = S.round;
  el.goldVal.textContent = S.gold;
  el.hpVal.textContent = S.hp;
  el.streakVal.textContent = S.streak;
  el.unitsPill.textContent = `Units: ${S.army.length}`;
  el.battleStats.textContent = `Round ${S.round} • Gold ${S.gold} • HP ${S.hp} • Streak ${S.streak}`;
  el.battleNodePill.textContent = S.node.isElite ? "ELITE" : (S.node.type || "BATTLE").toUpperCase();
  el.btnReroll.textContent = `Reroll (${hasAug("A2") ? 1 : 2}g)`;
}

function updateButtons(){
  const overlayOpen = (S.overlay !== "none");

  el.btnStart.disabled = overlayOpen || !(S.screen === "planning") || (S.army.length === 0);
  el.btnReroll.disabled = overlayOpen || !(S.screen === "planning");
  el.btnInventory.disabled = !(S.screen === "planning");
  el.btnMenu.disabled = !(S.screen === "planning");
  el.btnSynergies.disabled = !(S.screen === "planning");

  const canAdvance = (!overlayOpen && S.screen === "battle" && S.phase === "result" && S.hp > 0);
  el.btnNext.disabled = !canAdvance;
  el.btnResultNext.disabled = !canAdvance;
}

/* ===== Synergies logic ===== */
function getTraitCounts(units){
  const c = { Warrior:0, Ranger:0, Mage:0, Rogue:0, Kingdom:0, Wilds:0, Cult:0 };
  for (const u of units){
    if (u.classTag && c[u.classTag] != null) c[u.classTag]++;
    if (u.originTag && c[u.originTag] != null) c[u.originTag]++;
  }
  if (hasAug("A9")) c.Warrior++;
  if (hasAug("A10")) c.Ranger++;
  if (hasAug("A11")) c.Mage++;
  if (hasAug("A12")) c.Rogue++;
  return c;
}
function traitTier(name, count){
  const tiers = {
    Warrior:[2,4],
    Ranger:[2,4],
    Mage:[2,3],
    Rogue:[2,3],
    Kingdom:[2,3],
    Wilds:[2,3],
    Cult:[2,3],
  }[name] || [];
  let t = 0;
  for (const req of tiers) if (count >= req) t++;
  const nextReq = tiers[t] ?? null;
  return { tier:t, nextReq, tiers };
}
function openSynergiesOverlay(){
  setOverlay("synergies");
  renderSynergiesOverlay();
}
function renderSynergiesOverlay(){
  el.synergyList.innerHTML = "";
  const counts = getTraitCounts(S.army);
  const order = ["Warrior","Ranger","Mage","Rogue","Kingdom","Wilds","Cult"];

  for (const k of order){
    const n = counts[k] || 0;
    const tt = traitTier(k, n);
    const active = tt.tier > 0;

    const tierText = active ? `ACTIVE (tier ${tt.tier})` : (tt.nextReq ? `Next: ${tt.nextReq}` : "—");
    const card = document.createElement("div");
    card.className = "choiceCard";
    card.style.borderColor = active ? "rgba(85,211,138,0.75)" : "rgba(42,58,99,0.95)";
    card.innerHTML = `
      <div class="name"><span>${k} — ${n}</span><span class="rarMini">${tierText}</span></div>
      <div class="desc">${tt.tiers && tt.tiers.length ? `Breakpoints: ${tt.tiers.join(", ")}` : "No breakpoints"}</div>
    `;
    el.synergyList.appendChild(card);
  }
}

/* ===== Shop RNG (rarity odds by round) ===== */
function rarityOddsByRound(round, isEliteNext=false){
  let o;
  if (round <= 2){
    o = {Common:0.80, Uncommon:0.18, Rare:0.02, Epic:0.00, Legendary:0.00};
  } else if (round <= 5){
    o = {Common:0.55, Uncommon:0.35, Rare:0.09, Epic:0.01, Legendary:0.00};
  } else if (round <= 9){
    o = {Common:0.35, Uncommon:0.40, Rare:0.20, Epic:0.04, Legendary:0.01};
  } else {
    o = {Common:0.20, Uncommon:0.35, Rare:0.30, Epic:0.12, Legendary:0.03};
  }

  if (isEliteNext){
    const addEpic = 0.02, addLeg = 0.01;
    o.Epic += addEpic;
    o.Legendary += addLeg;
    const take = addEpic + addLeg;
    const takeC = Math.min(o.Common, take * 0.75);
    o.Common -= takeC;
    o.Uncommon = Math.max(0, o.Uncommon - (take - takeC));
  }

  const sum = Object.values(o).reduce((a,b)=>a+b,0) || 1;
  for (const k of Object.keys(o)) o[k] /= sum;
  return o;
}
function rollRarity(odds){
  let r = Math.random();
  for (const k of ["Common","Uncommon","Rare","Epic","Legendary"]){
    r -= odds[k] || 0;
    if (r <= 0) return k;
  }
  return "Common";
}
function pickUnitTemplateByRarity(rarity){
  const pool = UNIT_POOL.filter(u => (u.rarity || "Common") === rarity);
  if (!pool.length){
    const fallback = ["Legendary","Epic","Rare","Uncommon","Common"];
    for (const rr of fallback){
      const p2 = UNIT_POOL.filter(u => (u.rarity||"Common") === rr);
      if (p2.length) return pick(p2);
    }
    return UNIT_POOL[0];
  }
  return pick(pool);
}

/* ===== Shop ===== */
function rerollShop(free=false){
  const cost = hasAug("A2") ? 1 : 2;
  if (!free){
    if (S.gold < cost){ showToast("Not enough gold", "bad"); return; }
    S.gold -= cost;
    showToast(`Shop rerolled (-${cost}g)`, "info");
  }

  const odds = rarityOddsByRound(S.round, !!S.node?.isElite);
  S.shop = Array.from({length:5}, ()=>{
    const rar = rollRarity(odds);
    const t = pickUnitTemplateByRarity(rar);
    return makeOffer(t);
  });

  renderAll();
  saveGame();
}

function buyOffer(offerId){
  const idx = S.shop.findIndex(o => o.offerId === offerId);
  if (idx < 0) return;
  const offer = S.shop[idx];
  if (S.gold < offer.cost){ showToast("Not enough gold", "bad"); return; }

  S.gold -= offer.cost;
  const u = makeUnit(offer.name, 1, "player");
  S.army.push(u);
  S.shop.splice(idx, 1);

  showToast(`${offer.name} ★1 recruited`, "info");
  mergeAllSafe();
  renderAll();
  saveGame();
}

/* ===== Items: helpers ===== */
function itemLabel(type){
  return ITEMS[type]?.name || "Item";
}
function itemRarity(type){
  return ITEMS[type]?.rarity || "Common";
}
function renderSlotRowHTML(unit){
  const max = unit.itemSlotsMax || 1;
  const have = (unit.items||[]);
  let html = `<div class="slotRow">`;
  for (let i=0;i<max;i++){
    if (have[i] && have[i].type){
      html += `<span class="slotPill">${itemLabel(have[i].type)}</span>`;
    } else {
      html += `<span class="slotPill slotEmpty">—</span>`;
    }
  }
  html += `</div>`;
  return html;
}

/* ===== Merge (returns items; upgraded unit starts empty) ===== */
function mergeAllSafe(){
  let didMerge = true;
  const mergeMessages = [];
  let totalReturned = 0;

  while (didMerge){
    didMerge = false;

    const map = new Map();
    for (const u of S.army){
      const k = `${u.name}__${u.star}`;
      if (!map.has(k)) map.set(k, []);
      map.get(k).push(u.id);
    }

    let chosen = null;
    for (const [k, ids] of map.entries()){
      if (ids.length >= 3){
        const [name, starStr] = k.split("__");
        const star = Number(starStr);
        if (star >= 3) continue;
        chosen = { name, star, idsToConsume: ids.slice(0,3) };
        break;
      }
    }
    if (!chosen) break;

    const consumeSet = new Set(chosen.idsToConsume);
    const consumedUnits = S.army.filter(u => consumeSet.has(u.id));

    let returnedThisMerge = 0;
    for (const cu of consumedUnits){
      const arr = Array.isArray(cu.items) ? cu.items : [];
      for (const it of arr){
        if (it && it.type){
          S.items.push({ id:rndId(), type: it.type });
          returnedThisMerge++;
        }
      }
    }
    totalReturned += returnedThisMerge;

    S.army = S.army.filter(u => !consumeSet.has(u.id));

    const newStar = Math.min(3, chosen.star + 1);
    const nu = makeUnit(chosen.name, newStar, "player");
    nu.items = [];
    S.army.push(nu);

    mergeMessages.push(`Merged ${chosen.name} ★${chosen.star} → ★${newStar}${returnedThisMerge ? ` (+${returnedThisMerge} items)` : ""}`);
    didMerge = true;
  }

  if (mergeMessages.length){
    const msg = totalReturned
      ? `${mergeMessages[0]}${mergeMessages.length>1 ? ` (+${mergeMessages.length-1} more)` : ""} • returned ${totalReturned} item${totalReturned>1?"s":""}`
      : `${mergeMessages[0]}${mergeMessages.length>1 ? ` (+${mergeMessages.length-1} more)` : ""}`;
    showToast(msg, "good");
    if (S.overlay === "inventory") renderInventory();
  }
}

/* ===== Render ===== */
function renderShop(){
  el.shop.innerHTML = "";
  if (!S.shop.length){
    const empty = document.createElement("div");
    empty.className = "card";
    empty.style.flexBasis = "260px";
    empty.innerHTML = `<div class="rarStrip" style="background:${rarityColor("Common")}"></div><h4>Empty</h4><div class="line">Reroll for new offers.</div>`;
    el.shop.appendChild(empty);
    return;
  }

  for (const offer of S.shop){
    const clr = getClassColor(offer.role);
    const rarCol = rarityColor(offer.rarity);

    const card = document.createElement("div");
    card.className = "card";

    const strip = document.createElement("div");
    strip.className = "rarStrip";
    strip.style.background = rarCol;
    card.appendChild(strip);

    const h = document.createElement("h4");
    h.innerHTML = `<span>${offer.name} (${offer.cost}g)</span>`;
    const badge = document.createElement("span");
    badge.className = "badge";
    badge.style.background = clr.fill;
    h.appendChild(badge);

    const tags = `${offer.classTag}/${offer.originTag}`;
    const l0 = document.createElement("div");
    l0.className="line";
    l0.innerHTML = `<span style="color:${rarCol}; font-weight:1000;">${offer.rarity}</span> • Slots ${offer.itemSlotsMax}`;

    const l1 = document.createElement("div");
    l1.className="line";
    l1.textContent = `HP ${offer.hp} • ATK ${offer.atk} • ${offer.role}`;

    const l2 = document.createElement("div");
    l2.className="line";
    l2.textContent = `${tags} • Range ${offer.range}px • Spd ${offer.spd}s`;

    const btn = document.createElement("button");
    btn.textContent = "Buy";
    btn.disabled = (S.gold < offer.cost);
    btn.addEventListener("click", ()=>buyOffer(offer.offerId));

    card.appendChild(h);
    card.appendChild(l0);
    card.appendChild(l1);
    card.appendChild(l2);
    card.appendChild(btn);
    el.shop.appendChild(card);
  }
}

function renderArmy(){
  el.armyBar.innerHTML = "";
  if (!S.army.length){
    const chip = document.createElement("div");
    chip.className="chip";
    chip.style.opacity="0.85";
    chip.style.minWidth="220px";
    chip.innerHTML = `<div class="t">No units</div><div class="m">Buy units to start</div>`;
    el.armyBar.appendChild(chip);
    return;
  }

  for (const u of S.army){
    const rarCol = rarityColor(u.rarity || "Common");
    const chip = document.createElement("div");
    chip.className="chip";
    chip.style.borderLeftColor = rarCol;

    const slotsMax = u.itemSlotsMax || raritySlots(u.rarity||"Common");
    const slotsHave = (u.items||[]).filter(x=>x && x.type).length;

    chip.innerHTML = `
      <div class="t">
        <span>${u.name} ${"★".repeat(u.star)}</span>
        <span class="rarMini" style="border-color:${rarCol}; color:${rarCol};">${u.rarity}</span>
      </div>
      <div class="s">${u.maxHP} HP • ${u.atk} ATK • Slots ${slotsHave}/${slotsMax}</div>
      ${renderSlotRowHTML(u)}
      <div class="m">${u.classTag}/${u.originTag}</div>
    `;
    el.armyBar.appendChild(chip);
  }
}

function renderAll(){
  renderStats();
  renderShop();
  renderArmy();
  if (S.overlay === "synergies") renderSynergiesOverlay();
  if (S.overlay === "inventory") renderInventory();
  updateButtons();
}

/* ===== Canvas ===== */
const ctx = el.canvas.getContext("2d");
let W=0, H=0;
function resizeCanvas(){
  const rect = el.canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(rect.width * dpr);
  H = Math.floor(rect.height * dpr);
  el.canvas.width = W;
  el.canvas.height = H;
}
window.addEventListener("resize", () => {
  resizeCanvas();
});

/* ===== Combat cloning + bonuses ===== */
function cloneForCombat(rosterU, side){
  const c = JSON.parse(JSON.stringify(rosterU));
  c.side = side;
  c.hp = c.maxHP;
  c.cd = 0;
  c.alive = true;
  c.swingT = 0;
  c.aimA = 0;
  c.rosterId = rosterU.id;

  c.moveMult = 1.0;
  c.damageReduction = 0.0;
  c.regenPerSec = 0.0;
  c.lifesteal = 0.0;
  c.bombReady = false;
  c.firstHitBonus = 0.0;
  c.firstHitReady = true;
  c.secondWindUsed = false;
  c.shield = 0;
  c.shieldTimer = 0;

  c.chainEvery = 0;
  c.chainReady = 0;
  c.startShield = 0;
  c.reviveOnce = false;
  c.revived = false;

  c.healPulseCd = 0;
  c.pierceCounter = 0;
  c.trapUsed = false;
  c.blinkCd = 0;
  c.auraApplied = false;
  c.enrage = 0;

  c.tagCd = 0;

  return c;
}

function applyTeamAura(team, enemyTeam){
  const hasChrono = team.some(u => (u.items||[]).some(it => it.type === "I12"));
  if (hasChrono){
    for (const u of team){
      u.spd *= 0.90;
    }
  }
}

function applyRunBonusesToClone(c, counts){
  { // Warrior
    const n = counts.Warrior || 0;
    let mult = 1.0;
    if (n >= 4) mult = 1.35;
    else if (n >= 2) mult = 1.15;
    c.maxHP = Math.round(c.maxHP * mult);
    c.hp = c.maxHP;
  }

  { // Ranger
    const n = counts.Ranger || 0;
    if (n >= 4) c.spd = c.spd * 0.75;
    else if (n >= 2) c.spd = c.spd * 0.90;
  }

  { // Mage
    const n = counts.Mage || 0;
    if (n >= 3) c.atk = Math.round(c.atk * 1.30);
    else if (n >= 2) c.atk = Math.round(c.atk * 1.15);
  }

  { // Rogue
    const n = counts.Rogue || 0;
    if (n >= 3){ c.firstHitBonus = 0.45; c.moveMult *= 1.20; }
    else if (n >= 2){ c.firstHitBonus = 0.20; c.moveMult *= 1.10; }
  }

  { // Kingdom
    const n = counts.Kingdom || 0;
    if (c.role === "Front"){
      if (n >= 3) c.damageReduction += 0.20;
      else if (n >= 2) c.damageReduction += 0.10;
    }
  }

  { // Wilds
    const n = counts.Wilds || 0;
    if (n >= 3) c.regenPerSec += 0.03 * c.maxHP;
    else if (n >= 2) c.regenPerSec += 0.015 * c.maxHP;
  }

  { // Cult
    const n = counts.Cult || 0;
    c.cultTier = (n >= 3) ? 2 : (n >= 2) ? 1 : 0;
  }

  if (hasAug("A4") && isRangedUnit(c)) c.range += 35;
  if (hasAug("A6")) { c.atk = Math.round(c.atk * 1.20); c.maxHP = Math.round(c.maxHP * 0.90); c.hp = c.maxHP; }
  if (hasAug("A7") && c.classTag === "Warrior") c.damageReduction += 0.10;
  if (hasAug("A8") && c.classTag === "Ranger") c.spd = c.spd * 0.88;

  const arr = Array.isArray(c.items) ? c.items : [];
  for (const it of arr){
    if (!it || !it.type) continue;
    const def = ITEMS[it.type];
    if (def && def.apply) def.apply(c);
  }

  c.damageReduction = clamp(c.damageReduction, 0, 0.65);
}

/* ===== Enemy spawns ===== */
function spawnEnemyWave(){
  const r = S.round;
  const baseCount = Math.min(18, 3 + Math.floor(r/2));
  const count = S.node.isElite ? Math.min(22, baseCount + 2) : baseCount;

  const odds = rarityOddsByRound(r, !!S.node?.isElite);

  let hpMult = 1.0, atkMult = 1.0;
  if (S.node.isElite){ hpMult *= 1.25; atkMult *= 1.10; }
  if (S.nextEnemyMod){
    hpMult *= (S.nextEnemyMod.hpMult || 1.0);
    atkMult *= (S.nextEnemyMod.atkMult || 1.0);
  }

  S.E = [];
  for (let i=0;i<count;i++){
    const rar = rollRarity(odds);
    const t = pickUnitTemplateByRarity(rar);
    const star = (r >= 6 && Math.random()<0.35) ? 2 : 1;
    const e = makeUnit(t.name, star, "enemy");
    e.maxHP = Math.round(e.maxHP * hpMult);
    e.hp = e.maxHP;
    e.atk = Math.round(e.atk * atkMult);
    e.items = [];
    S.E.push(e);
  }

  S.nextEnemyMod = null;
}

/* ===== Formation deployment ===== */
function deployArmies(){
  S.projectiles = [];
  S.floaters = [];

  const counts = getTraitCounts(S.army);
  S.P = S.army.map(u => {
    const c = cloneForCombat(u, "player");
    applyRunBonusesToClone(c, counts);
    return c;
  });
  S.E = S.E.map(u => cloneForCombat(u, "enemy"));

  applyTeamAura(S.P, S.E);

  const centerLineX = W/2;
  const sidePadX = W*0.08;
  const topPadY  = H*0.14;
  const bottomPadY = H*0.10;
  const usableH = Math.max(80, H - topPadY - bottomPadY);

  const frontDepth = W*0.12;
  const backGap = W*0.08;

  function splitGroups(arr){
    const front = [];
    const back = [];
    const flank = [];
    for (const u of arr){
      if (u.role === "Skirmish") flank.push(u);
      else if (isRangedUnit(u)) back.push(u);
      else front.push(u);
    }
    return {front, back, flank};
  }

  function placeRank(units, baseX, sideSign){
    const n = units.length;
    if (!n) return;

    const maxRowsTarget = 10;
    const cols = Math.min(4, Math.max(1, Math.ceil(n / maxRowsTarget)));
    const rows = Math.max(1, Math.ceil(n / cols));
    const yStep = usableH / (rows + 1);

    const colOffset = Math.max(14, W*0.02);

    for (let i=0;i<n;i++){
      const col = Math.floor(i / rows);
      const row = i % rows;

      let x = baseX + sideSign * (col * colOffset);
      let y = topPadY + (row + 1) * yStep;

      y += (i % 2 ? 6 : -6);
      x += ((i % 3) - 1) * 4;

      x = clamp(x, 16, W-16);
      y = clamp(y, 16, H-16);

      units[i].x = x;
      units[i].y = y;
    }
  }

  function placeFlanks(units, baseX, sideSign){
    const n = units.length;
    if (!n) return;

    const half = Math.ceil(n / 2);
    const topCount = half;
    const botCount = n - half;

    const band = usableH * 0.28;
    const topStart = topPadY;
    const botStart = topPadY + usableH - band;

    const colOffset = Math.max(14, W*0.02);
    const cols = Math.min(3, Math.max(1, Math.ceil(n / 8)));
    const rows = Math.max(1, Math.ceil(n / cols));
    const yStepTop = band / (Math.min(topCount, rows) + 1);
    const yStepBot = band / (Math.min(botCount, rows) + 1);

    for (let i=0;i<n;i++){
      const col = Math.floor(i / rows);
      const row = i % rows;

      let x = baseX + sideSign * (col * colOffset + backGap*0.35);
      let y;

      if (i < topCount){
        y = topStart + (Math.min(row, topCount-1) + 1) * yStepTop;
      } else {
        const j = i - topCount;
        y = botStart + (Math.min(j % rows, Math.max(1, botCount)-1) + 1) * yStepBot;
      }

      y += (i % 2 ? 6 : -6);
      x += ((i % 3) - 1) * 4;

      x = clamp(x, 16, W-16);
      y = clamp(y, 16, H-16);

      units[i].x = x;
      units[i].y = y;
    }
  }

  function placeSide(arr, side){
    const sideSign = (side === "player") ? -1 : 1;
    const {front, back, flank} = splitGroups(arr);

    const frontX = centerLineX + sideSign * frontDepth;
    const backX  = centerLineX + sideSign * (frontDepth + backGap);

    const minX = sidePadX;
    const maxX = W - sidePadX;
    const clampX = (x)=> clamp(x, minX, maxX);

    placeRank(front, clampX(frontX), sideSign);
    placeRank(back,  clampX(backX), sideSign);
    placeFlanks(flank, clampX(frontX), sideSign);
  }

  placeSide(S.P, "player");
  placeSide(S.E, "enemy");

  for (const u of S.P){
    if (u.startShield && u.startShield > 0){
      const amt = u.maxHP * u.startShield;
      u.shield = Math.max(u.shield||0, amt);
      u.shieldTimer = 3.0;
      pushTag(u, "Shield");
    }
  }
}

function alive(arr){ return arr.filter(u => u.alive && u.hp > 0); }
function findNearest(att, enemies){
  let best=null, bestD=1e18;
  for (const e of enemies){
    if (!e.alive) continue;
    const dx = e.x - att.x;
    const dy = e.y - att.y;
    const d = dx*dx + dy*dy;
    if (d < bestD){ bestD=d; best=e; }
  }
  return best;
}
function findWeakestBackliner(enemies){
  const cand = enemies.filter(e=>e.alive && (isRangedUnit(e) || e.role==="Mage"));
  const list = cand.length ? cand : enemies.filter(e=>e.alive);
  if (!list.length) return null;
  let best=list[0];
  for (const e of list){
    if (e.hp < best.hp) best = e;
  }
  return best;
}
function findByIdAnySide(id){
  for (const u of S.P) if (u.id === id) return u;
  for (const u of S.E) if (u.id === id) return u;
  return null;
}

/* ===== Floating numbers ===== */
function pushFloater(x, y, text, kind){
  if (S.floaters.length > 80) S.floaters.shift();
  S.floaters.push({
    x, y,
    text: String(text),
    kind,
    ttl: 0.9,
    vy: -28,
    vx: (Math.random()*18 - 9),
    alpha: 1
  });
}
function pushDamage(tgt, amount){
  pushFloater(tgt.x + (Math.random()*10-5), tgt.y - 18 + (Math.random()*6-3), Math.round(amount), "dmg");
}
function pushHeal(tgt, amount){
  pushFloater(tgt.x + (Math.random()*10-5), tgt.y - 18 + (Math.random()*6-3), `+${Math.round(amount)}`, "heal");
}
function pushShield(tgt, amount){
  pushFloater(tgt.x + (Math.random()*10-5), tgt.y - 18 + (Math.random()*6-3), `Abs ${Math.round(amount)}`, "shield");
}
function pushTag(u, txt){
  if (u.tagCd && u.tagCd > 0) return;
  u.tagCd = 0.5;
  pushFloater(u.x + (Math.random()*10-5), u.y - 34, txt, "tag");
}
function updateFloaters(dt){
  for (let i=S.floaters.length-1;i>=0;i--){
    const f = S.floaters[i];
    f.ttl -= dt;
    f.y += f.vy * dt;
    f.x += f.vx * dt;
    f.alpha = clamp(f.ttl / 0.9, 0, 1);
    if (f.ttl <= 0) S.floaters.splice(i,1);
  }
}

/* ===== Damage system ===== */
function applyDamage(att, tgt, rawDmg){
  if (!tgt.alive) return;
  let dmg = rawDmg;

  if (att && att.firstHitReady && att.firstHitBonus > 0){
    dmg = dmg * (1 + att.firstHitBonus);
    att.firstHitReady = false;
    pushTag(att, "First Hit");
  }

  if (att && att.name === "Berserker"){
    const pct = 1 - (att.hp / att.maxHP);
    if (pct > 0.15){
      const mult = 1 + Math.min(0.35, pct*0.45);
      dmg *= mult;
      if (pct > 0.35) pushTag(att, "Enrage");
    }
  }

  dmg = dmg * (1 - (tgt.damageReduction || 0));

  let absorbed = 0;
  if (tgt.shield && tgt.shield > 0){
    absorbed = Math.min(tgt.shield, dmg);
    tgt.shield -= absorbed;
    dmg -= absorbed;
    if (absorbed > 0) pushShield(tgt, absorbed);
  }

  dmg = Math.max(0, dmg);
  if (dmg > 0) pushDamage(tgt, dmg);

  if (dmg <= 0) return;

  tgt.hp = Math.max(0, tgt.hp - dmg);

  if (att && att.chainEvery && att.chainEvery > 0){
    att.chainReady = (att.chainReady||0) + 1;
    if (att.chainReady >= att.chainEvery){
      att.chainReady = 0;
      const foes = (att.side === "player") ? alive(S.E) : alive(S.P);
      let near=null, best=1e18;
      for (const f of foes){
        if (f.id === tgt.id) continue;
        const dx = f.x - tgt.x;
        const dy = f.y - tgt.y;
        const d = dx*dx + dy*dy;
        if (d < best){ best=d; near=f; }
      }
      if (near && best <= (80*80)){
        pushTag(att, "Chain");
        applyDamage(att, near, dmg * 0.30);
      }
    }
  }

  if (tgt.hp <= 0){
    if (tgt.reviveOnce && !tgt.revived){
      tgt.revived = true;
      tgt.hp = Math.max(1, Math.round(tgt.maxHP * 0.25));
      pushTag(tgt, "Revive");
      pushHeal(tgt, tgt.hp);
    } else {
      tgt.alive = false;
      onKill(att, tgt);
    }
  }

  if (att && att.lifesteal && att.lifesteal > 0 && att.alive){
    const heal = dmg * att.lifesteal;
    const before = att.hp;
    att.hp = Math.min(att.maxHP, att.hp + heal);
    const actual = att.hp - before;
    if (actual > 0) pushHeal(att, actual);
  }

  if (att && att.bombReady){
    const foes = (att.side === "player") ? alive(S.E) : alive(S.P);
    let near=null, best=1e18;
    for (const f of foes){
      if (f.id === tgt.id) continue;
      const dx = f.x - tgt.x;
      const dy = f.y - tgt.y;
      const d = dx*dx + dy*dy;
      if (d < best){ best=d; near=f; }
    }
    if (near && best <= (50*50)){
      pushTag(att, "Splash");
      applyDamage(att, near, dmg * 0.35);
    }
    att.bombReady = false;
  }
}

function onKill(att, deadTarget){
  if (!att || !att.alive) return;

  if (att.cultTier && att.cultTier > 0){
    const pct = (att.cultTier === 2) ? 0.16 : 0.08;
    const amt = att.maxHP * pct;
    att.shield = Math.max(att.shield || 0, amt);
    att.shieldTimer = 2.0;
    pushTag(att, "Cult");
    pushShield(att, amt);
  }
}

/* ===== Projectiles + melee swing ===== */
function spawnProjectile(att, target, extra={}) {
  if (S.projectiles.length > 90) S.projectiles.shift();

  const dx = target.x - att.x;
  const dy = target.y - att.y;
  const dist = Math.max(1, Math.sqrt(dx*dx + dy*dy));
  const flight = Math.max(0.22, Math.min(0.45, dist / 520));
  const vx = dx / flight;
  const vy = dy / flight;

  S.projectiles.push({
    x: att.x, y: att.y,
    vx, vy,
    ttl: flight + 0.08,
    targetId: target.id,
    damage: att.atk,
    color: att.classFx || "#cfe0ff",
    attackerId: att.id,
    pierce: !!extra.pierce,
    root: !!extra.root,
    rootDur: extra.rootDur || 0,
  });
}

function updateProjectiles(dt){
  for (let i=S.projectiles.length-1; i>=0; i--){
    const p = S.projectiles[i];
    p.ttl -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    const tgt = findByIdAnySide(p.targetId);
    if (!tgt || !tgt.alive){
      S.projectiles.splice(i,1);
      continue;
    }

    const dx = tgt.x - p.x;
    const dy = tgt.y - p.y;
    const d = Math.sqrt(dx*dx + dy*dy);

    if (d < 14 || p.ttl <= 0){
      const att = findByIdAnySide(p.attackerId);

      if (p.root && tgt.alive){
        tgt.rootT = Math.max(tgt.rootT||0, p.rootDur);
        pushTag(tgt, "Root");
      }

      applyDamage(att, tgt, p.damage);

      if (p.pierce){
        p.ttl = 0.12;
        p.targetId = "";
        p.pierce = false;
      } else {
        S.projectiles.splice(i,1);
      }
    }
  }
}

/* ===== Combat step ===== */
function stepCombat(dt){
  const P = alive(S.P);
  const E = alive(S.E);

  if (P.length === 0 || E.length === 0){
    endCombat(P.length > 0);
    return;
  }

  for (const u of S.P){
    u.swingT = Math.max(0, u.swingT - dt);
    u.tagCd = Math.max(0, (u.tagCd||0) - dt);

    if (u.shieldTimer && u.shieldTimer > 0){
      u.shieldTimer -= dt;
      if (u.shieldTimer <= 0) u.shield = 0;
    }

    if (u.rootT && u.rootT > 0) u.rootT -= dt;

    if (u.regenPerSec && u.regenPerSec > 0 && u.alive){
      const before = u.hp;
      u.hp = Math.min(u.maxHP, u.hp + u.regenPerSec * dt);
      const healed = u.hp - before;
      if (healed > 0 && chance(0.25)) pushHeal(u, healed);
    }

    if (hasAug("A5") && !u.secondWindUsed && u.hp > 0 && u.hp < 0.30*u.maxHP){
      const before = u.hp;
      u.hp = Math.min(u.maxHP, u.hp + 0.20*u.maxHP);
      const healed = u.hp - before;
      u.secondWindUsed = true;
      if (healed > 0){ pushTag(u, "Second Wind"); pushHeal(u, healed); }
    }

    if (u.name === "Healer" && u.alive){
      u.healPulseCd -= dt;
      if (u.healPulseCd <= 0){
        u.healPulseCd = 2.5;
        let low = null;
        for (const a of P){
          if (!a.alive) continue;
          if (!low || (a.hp/a.maxHP) < (low.hp/low.maxHP)) low = a;
        }
        if (low){
          const amt = 18 + (u.star-1)*12;
          const before = low.hp;
          low.hp = Math.min(low.maxHP, low.hp + amt);
          const healed = low.hp - before;
          if (healed > 0){
            pushTag(u, "Heal");
            pushHeal(low, healed);
          }
        }
      }
    }

    if (u.name === "Shade" && u.alive){
      u.blinkCd -= dt;
      if (u.blinkCd <= 0){
        u.blinkCd = 4.0;
        const target = findWeakestBackliner(E);
        if (target){
          u.x = clamp(target.x - 26, 18, W-18);
          u.y = clamp(target.y + (Math.random()*18-9), 18, H-18);
          pushTag(u, "Blink");
        }
      }
    }

    if (u.name === "Warlord" && u.alive){
      for (const a of P){
        if (!a.alive) continue;
        const dx = a.x - u.x, dy = a.y - u.y;
        if (dx*dx + dy*dy <= (110*110)){
          a.damageReduction = clamp((a.damageReduction||0) + 0.0008, 0, 0.65);
        }
      }
    }
  }

  for (const u of S.E){
    u.swingT = Math.max(0, u.swingT - dt);
    if (u.rootT && u.rootT > 0) u.rootT -= dt;
  }

  updateProjectiles(dt);
  updateFloaters(dt);

  function stepSide(friends, foes){
    for (const u of friends){
      u.cd -= dt;
      const t = findNearest(u, foes);
      if (!t) continue;

      const dx = t.x - u.x;
      const dy = t.y - u.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const inRange = dist <= u.range;

      const rooted = (u.rootT && u.rootT > 0);

      if (!inRange && !rooted){
        const baseSpeed = 62 + (u.star-1)*8;
        const speed = baseSpeed * (u.moveMult || 1);
        const nx = dx / (dist||1);
        const ny = dy / (dist||1);
        u.x += nx * speed * dt;
        u.y += ny * speed * dt;
        u.x = clamp(u.x, 18, W-18);
        u.y = clamp(u.y, 18, H-18);
      }

      if (u.cd <= 0 && inRange){
        const ang = Math.atan2(dy, dx);
        u.aimA = ang;

        if (isRangedUnit(u)){
          let extra = {};
          if (u.name === "Trapper" && !u.trapUsed){
            u.trapUsed = true;
            extra.root = true;
            extra.rootDur = 0.7;
            pushTag(u, "Trap");
          }
          if (u.name === "Invoker"){
            u.pierceCounter = (u.pierceCounter||0) + 1;
            if (u.pierceCounter >= 3){
              u.pierceCounter = 0;
              extra.pierce = true;
              pushTag(u, "Pierce");
            }
          }
          spawnProjectile(u, t, extra);
        } else {
          let dmg = u.atk;
          if (u.name === "Spearman" && t.role === "Skirmish"){
            dmg *= 1.25;
            pushTag(u, "Counter");
          }
          applyDamage(u, t, dmg);
          u.swingT = 0.18;
        }

        u.cd = u.spd;
      }
    }
  }

  stepSide(P, E);
  stepSide(E, P);
}

/* ===== Drawing ===== */
function drawPoly(points){
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}
function drawShape(x,y,r,shape){
  const pts = [];
  if (shape === "square"){
    const s = r * 0.95;
    pts.push({x:x-s, y:y-s},{x:x+s, y:y-s},{x:x+s, y:y+s},{x:x-s, y:y+s});
    drawPoly(pts); return;
  }
  if (shape === "triangle"){
    const s = r * 1.05;
    pts.push({x:x, y:y-s},{x:x+s, y:y+s},{x:x-s, y:y+s});
    drawPoly(pts); return;
  }
  if (shape === "diamond"){
    const s = r * 1.05;
    pts.push({x:x, y:y-s},{x:x+s, y:y},{x:x, y:y+s},{x:x-s, y:y});
    drawPoly(pts); return;
  }
  if (shape === "hex"){
    const s = r * 1.02;
    for (let i=0;i<6;i++){
      const a = (Math.PI/3)*i - Math.PI/6;
      pts.push({x: x + Math.cos(a)*s, y: y + Math.sin(a)*s});
    }
    drawPoly(pts); return;
  }
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
}
function drawSwing(u, r){
  if (u.swingT <= 0) return;
  const p = Math.min(1, u.swingT / 0.18);
  const len = r * 1.7;
  const a = u.aimA;
  ctx.save();
  ctx.globalAlpha = 0.10 + 0.35 * p;
  ctx.strokeStyle = u.classFx || "#ffd36a";
  ctx.lineWidth = 2 + 2*p;

  const x1 = u.x + Math.cos(a - 0.55) * (r*0.7);
  const y1 = u.y + Math.sin(a - 0.55) * (r*0.7);
  const x2 = u.x + Math.cos(a + 0.35) * len;
  const y2 = u.y + Math.sin(a + 0.35) * len;

  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();
  ctx.restore();
}
function drawProjectiles(){
  for (const p of S.projectiles){
    ctx.save();
    ctx.globalAlpha = 0.45;
    ctx.strokeStyle = p.color || "#cfe0ff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(p.x - p.vx*0.02, p.y - p.vy*0.02);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#e8eefc";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}
function drawFloaters(){
  if (!S.floaters.length) return;
  ctx.save();
  const base = Math.max(12, Math.floor(W/70));
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  for (const f of S.floaters){
    ctx.globalAlpha = 0.95 * f.alpha;
    let color = getCSS("--tag");
    let size = base;
    if (f.kind === "dmg"){ color = getCSS("--dmg"); size = base + 1; }
    if (f.kind === "heal"){ color = getCSS("--heal"); size = base + 0; }
    if (f.kind === "shield"){ color = getCSS("--shield"); size = base - 1; }
    if (f.kind === "tag"){ color = getCSS("--tag"); size = base - 1; ctx.globalAlpha = 0.75 * f.alpha; }

    ctx.fillStyle = color;
    ctx.font = `${size}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(f.text, f.x, f.y);
  }
  ctx.restore();
}
function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#0b1020";
  ctx.fillRect(0,0,W,H);

  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "#141d35";
  for (let i=0;i<10;i++){
    ctx.fillRect(i*(W/10), 0, (W/10)-2, H);
  }
  ctx.globalAlpha = 1;

  ctx.globalAlpha = 0.55;
  ctx.strokeStyle = "#233357";
  ctx.lineWidth = Math.max(2, Math.floor(W/320));
  ctx.beginPath();
  ctx.moveTo(W/2, 10);
  ctx.lineTo(W/2, H-10);
  ctx.stroke();
  ctx.globalAlpha = 1;

  drawProjectiles();

  function drawUnit(u){
    const r = 14 + (u.star-1)*4;

    ctx.fillStyle = u.classFill || "#6aa6ff";
    ctx.strokeStyle = (u.side==="player") ? "#cfe0ff" : "#ffd0d9";
    ctx.lineWidth = 2;
    drawShape(u.x, u.y, r, u.shape);

    if (u.shield && u.shield > 0){
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = "#8cc0ff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(u.x, u.y, r+5, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    drawSwing(u, r);

    ctx.fillStyle = "#e8eefc";
    ctx.font = `${Math.max(11, Math.floor(W/60))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(u.name, u.x, u.y - r - 4);

    ctx.fillStyle = "#cfe0ff";
    ctx.font = `${Math.max(10, Math.floor(W/70))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textBaseline = "top";
    ctx.fillText("★".repeat(u.star), u.x, u.y + r + 2);

    const barW = 52 + (u.star-1)*10;
    const barH = 6;
    const x = u.x - barW/2;
    const y = u.y - r - 14;
    ctx.fillStyle = "#1d2638";
    ctx.fillRect(x, y, barW, barH);
    ctx.fillStyle = (u.side==="player") ? "#55d38a" : "#ff5c7a";
    ctx.fillRect(x, y, barW * (u.hp/u.maxHP), barH);
  }

  for (const u of S.P) if (u.alive) drawUnit(u);
  for (const u of S.E) if (u.alive) drawUnit(u);

  drawFloaters();
}

/* ===== Main loop ===== */
let lastT = 0;
let rafId = null;
function loop(t){
  if (!lastT) lastT = t;
  const dt = Math.min(0.05, (t-lastT)/1000);
  lastT = t;

  if (S.combatRunning) stepCombat(dt);
  if (S.screen === "battle") draw();

  rafId = requestAnimationFrame(loop);
}

/* ===== Permadeath ===== */
function applyPermadeath(){
  const dead = S.P.filter(u => !u.alive || u.hp <= 0);
  if (!dead.length) return;

  const deadIds = new Set(dead.map(u => u.rosterId).filter(Boolean));
  const deadNames = dead.map(u => `${u.name} ★${u.star}`);

  let returned = 0;
  for (const roster of S.army){
    if (deadIds.has(roster.id)){
      const arr = Array.isArray(roster.items) ? roster.items : [];
      for (const it of arr){
        if (it && it.type){
          S.items.push({ id:rndId(), type: it.type });
          returned++;
        }
      }
      roster.items = [];
    }
  }

  S.army = S.army.filter(u => !deadIds.has(u.id));

  const extra = returned ? ` • returned ${returned} item${returned>1?"s":""}` : "";
  if (deadNames.length === 1) showToast(`${deadNames[0]} died${extra}`, "bad");
  else if (deadNames.length > 1) showToast(`Units lost: ${deadNames.join(", ")}${extra}`, "bad");

  if (S.overlay === "inventory") renderInventory();
}

/* ===== Battle flow ===== */
function startCombat(){
  if (S.army.length === 0){ showToast("Not enough units", "bad"); return; }
  if (S.overlay !== "none") return;

  setScreen("battle");
  setPhase("combat");
  S.combatRunning = true;

  showToast("Battle started", "info");
  resizeCanvas();

  spawnEnemyWave();
  deployArmies();

  document.body.dataset.result = "hide";
  updateButtons();
}

function showResult(win, summary, type){
  S.combatRunning = false;
  setPhase("result");

  document.body.dataset.result = "show";
  el.resultTitle.textContent = win ? "Victory" : "Defeat";
  el.resultTitle.style.color = win ? "var(--good)" : "var(--bad)";
  el.resultText.textContent = summary;
  showToast(summary, type);

  updateButtons();
  renderStats();
}

function endCombat(win){
  applyPermadeath();
  renderAll();

  if (win){
    S.streak += 1;
    const base = 4 + Math.floor(S.round/2);
    const streakBonus = Math.min(4, Math.floor(S.streak/2));
    const goldGain = base + streakBonus;
    S.gold += goldGain;
    showResult(true, `Victory! +${goldGain}g`, "good");
  } else {
    S.streak = 0;
    const dmg = 2 + Math.floor(S.round/2);
    S.hp = Math.max(0, S.hp - dmg);
    S.gold += 3;

    if (S.hp <= 0){
      document.body.dataset.result = "show";
      el.resultTitle.textContent = "Game Over";
      el.resultTitle.style.color = "var(--bad)";
      el.resultText.textContent = "You ran out of HP. Start a new run from the menu.";
      showToast("Game Over", "bad");

      el.btnNext.disabled = true;
      el.btnResultNext.disabled = true;

      try{
        const data = serializeState();
        data.ended = true;
        localStorage.setItem(SAVE_KEY_V3, JSON.stringify(data));
      }catch(e){}
      refreshContinueBtn();
      return;
    } else {
      showResult(false, `Defeat. -${dmg} HP, +3g`, "bad");
    }
  }

  saveGame();
}

/* ===== Post-battle roguelike pipeline ===== */
function randomItemDrop(){
  const r = S.round;
  let odds;
  if (r <= 3) odds = {Common:0.70, Uncommon:0.25, Rare:0.05, Epic:0.00, Legendary:0.00};
  else if (r <= 7) odds = {Common:0.45, Uncommon:0.35, Rare:0.16, Epic:0.04, Legendary:0.00};
  else odds = {Common:0.30, Uncommon:0.35, Rare:0.22, Epic:0.10, Legendary:0.03};

  if (S.node.isElite){
    odds.Epic += 0.03; odds.Legendary += 0.01;
    odds.Common = Math.max(0, odds.Common - 0.03);
    odds.Uncommon = Math.max(0, odds.Uncommon - 0.01);
  }
  const sum = Object.values(odds).reduce((a,b)=>a+b,0) || 1;
  for (const k of Object.keys(odds)) odds[k]/=sum;

  const rar = rollRarity(odds);
  const pool = Object.keys(ITEMS).filter(id => (ITEMS[id].rarity||"Common") === rar);
  const id = pool.length ? pick(pool) : pick(Object.keys(ITEMS));
  return { id:rndId(), type:id };
}

function beginPostBattleFlow(){
  if (S.hp <= 0) return;

  S.overlayQueue = [];

  const lastWasWin = (el.resultTitle.textContent === "Victory");
  if (lastWasWin){
    if (S.node.isElite){
      const it = randomItemDrop();
      S.items.push(it);
      queueOverlay("item", it);
      queueOverlay("augment");
    } else {
      if (chance(0.40)){
        const it = randomItemDrop();
        S.items.push(it);
        queueOverlay("item", it);
      }
      if (S.round % 3 === 0) queueOverlay("augment");
    }
  } else {
    if (S.round % 3 === 0) queueOverlay("augment");
  }

  queueOverlay("node");

  saveGame();
  nextOverlay();
}

function startNextRoundPlanning(){
  S.round += 1;
  S.gold += 2;
  if (hasAug("A1")) S.gold += 1;

  if (!S.node) S.node = { type:"battle", isElite:false };

  showToast(`Round ${S.round} — +${hasAug("A1") ? 3 : 2}g`, "info");

  setScreen("planning");
  setPhase("planning");
  rerollShop(true);
  renderAll();
  saveGame();
}

/* ===== Overlays ===== */
function openAugmentPick(){
  setOverlay("augment");
  el.augmentChoices.innerHTML = "";

  const pool = Object.keys(AUGMENTS).filter(id => !S.augments.includes(id));
  const picks = [];
  while (picks.length < 3 && pool.length){
    const id = pool.splice(Math.floor(Math.random()*pool.length), 1)[0];
    picks.push(id);
  }
  while (picks.length < 3){
    picks.push(pick(Object.keys(AUGMENTS)));
  }

  for (const id of picks){
    const a = AUGMENTS[id];
    const card = document.createElement("div");
    card.className = "choiceCard";
    card.innerHTML = `<div class="name"><span>${a.name}</span><span class="rarMini">Augment</span></div><div class="desc">${a.desc}</div>`;
    const btn = document.createElement("button");
    btn.className = "btnPrimary";
    btn.textContent = "Pick";
    btn.addEventListener("click", ()=>{
      S.augments.push(id);
      if (a.pickNow) a.pickNow(S);
      showToast(`Augment: ${a.name}`, "good");
      renderAll();
      saveGame();
      nextOverlay();
    });
    card.appendChild(btn);
    el.augmentChoices.appendChild(card);
  }
}

function openItemReward(itemObj){
  setOverlay("item");
  const def = ITEMS[itemObj.type];
  const rarCol = rarityColor(def.rarity || "Common");
  el.itemRewardCard.innerHTML = `
    <div class="name"><span>${def.name}</span><span class="rarMini" style="border-color:${rarCol}; color:${rarCol};">${def.rarity||"Common"}</span></div>
    <div class="desc">${def.desc}</div>
    <div class="desc" style="margin-top:6px;">Inventory → equip (higher rarity units hold more). Unequip returns items.</div>
  `;
}
el.btnItemContinue.addEventListener("click", ()=>{ nextOverlay(); });

function openNodeSelect(){
  setOverlay("node");
  el.nodeChoices.innerHTML = "";

  const nodes = [
    { type:"battle", isElite:false, title:"Battle", desc:"Normal fight." },
    { type:"battle", isElite:true,  title:"Elite",  desc:"Harder enemies. Guaranteed item + augment on win." },
    { type:"event",  isElite:false, title:"Event",  desc:"Pick one risk/reward outcome." },
  ];

  for (const n of nodes){
    const card = document.createElement("div");
    card.className = "choiceCard";
    card.innerHTML = `<div class="name"><span>${n.title}</span><span class="rarMini">${n.isElite?"Elite":"Node"}</span></div><div class="desc">${n.desc}</div>`;
    const btn = document.createElement("button");
    btn.className = "btnPrimary";
    btn.textContent = "Choose";
    btn.addEventListener("click", ()=>{
      if (n.type === "event"){
        S.node = { type:"event", isElite:false };
        saveGame();
        openEventSelect();
      } else {
        S.node = { type:"battle", isElite: !!n.isElite };
        saveGame();
        setOverlay("none");
        startNextRoundPlanning();
      }
    });
    card.appendChild(btn);
    el.nodeChoices.appendChild(card);
  }
}

function openEventSelect(){
  setOverlay("event");
  el.eventChoices.innerHTML = "";

  const pool = EVENTS.slice();
  const picks = [];
  while (picks.length < 3 && pool.length){
    picks.push(pool.splice(Math.floor(Math.random()*pool.length), 1)[0]);
  }

  for (const ev of picks){
    const card = document.createElement("div");
    card.className = "choiceCard";
    card.innerHTML = `<div class="name"><span>${ev.name}</span><span class="rarMini">Event</span></div><div class="desc">${ev.desc}</div>`;
    const btn = document.createElement("button");
    btn.className = "btnPrimary";
    btn.textContent = "Take";
    btn.addEventListener("click", ()=>{
      ev.apply(S);
      mergeAllSafe();
      renderAll();
      saveGame();

      S.node = { type:"battle", isElite:false };
      setOverlay("none");
      startNextRoundPlanning();
    });
    card.appendChild(btn);
    el.eventChoices.appendChild(card);
  }
}

/* ===== Inventory overlay (ALWAYS 2 columns + independent scrolling) ===== */
let selectedInvItemId = null;

function openInventory(){
  setOverlay("inventory");
  selectedInvItemId = null;
  el.invHint.textContent = "Tap an item, then tap Equip Here on a unit. Unequip returns to inventory.";
  renderInventory();
}

function renderInventory(){
  el.invItems.innerHTML = "";
  el.invUnits.innerHTML = "";
  el.invCount.textContent = `${S.items.length} item${S.items.length===1?"":"s"}`;
  el.invUnitsCount.textContent = `${S.army.length} unit${S.army.length===1?"":"s"}`;

  // Items column
  for (const it of S.items){
    const def = ITEMS[it.type];
    const rarCol = rarityColor(def.rarity || "Common");
    const card = document.createElement("div");
    card.className = "choiceCard";
    const sel = (selectedInvItemId === it.id);
    card.style.borderColor = sel ? "rgba(106,166,255,0.95)" : "rgba(42,58,99,0.95)";
    card.innerHTML = `
      <div class="name"><span>${def.name}</span><span class="rarMini" style="border-color:${rarCol}; color:${rarCol};">${def.rarity||"Common"}</span></div>
      <div class="desc">${def.desc}</div>
    `;
    const btn = document.createElement("button");
    btn.className = sel ? "btnPrimary" : "";
    btn.textContent = sel ? "Selected" : "Select";
    btn.addEventListener("click", ()=>{
      selectedInvItemId = it.id;
      el.invHint.textContent = `Selected: ${def.name} — now tap “Equip Here” on a unit.`;
      renderInventory();
    });
    card.appendChild(btn);
    el.invItems.appendChild(card);
  }
  if (!S.items.length){
    const empty = document.createElement("div");
    empty.className = "choiceCard";
    empty.innerHTML = `<div class="name">No items</div><div class="desc">Win fights to find items.</div>`;
    el.invItems.appendChild(empty);
  }

  // Units column
  for (const u of S.army){
    const card = document.createElement("div");
    card.className = "choiceCard";

    const rarCol = rarityColor(u.rarity || "Common");
    const have = (u.items||[]).filter(x=>x && x.type).length;
    const max = u.itemSlotsMax || 1;

    card.innerHTML = `
      <div class="name">
        <span>${u.name} ${"★".repeat(u.star)}</span>
        <span class="rarMini" style="border-color:${rarCol}; color:${rarCol};">${u.rarity}</span>
      </div>
      <div class="desc">${u.classTag}/${u.originTag} • Slots ${have}/${max}</div>
      ${renderSlotRowHTML(u)}
    `;

    const equipBtn = document.createElement("button");
    equipBtn.className = "btnPrimary";
    equipBtn.textContent = "Equip Here";
    equipBtn.disabled = !selectedInvItemId;

    equipBtn.addEventListener("click", ()=>{
      if (!selectedInvItemId){
        showToast("Select an item first", "bad");
        return;
      }
      const invIdx = S.items.findIndex(x => x.id === selectedInvItemId);
      if (invIdx < 0){
        showToast("Item not found", "bad");
        selectedInvItemId = null;
        renderInventory();
        return;
      }
      const pickedItem = S.items[invIdx];

      const cur = Array.isArray(u.items) ? u.items : (u.items=[]);
      const maxSlots = u.itemSlotsMax || 1;

      if (cur.length < maxSlots){
        S.items.splice(invIdx, 1);
        cur.push({ id:rndId(), type:pickedItem.type });
        selectedInvItemId = null;
        el.invHint.textContent = "Equipped. Select another item to equip more.";
        showToast(`${itemLabel(pickedItem.type)} equipped to ${u.name}`, "good");
        renderAll();
        saveGame();
        renderInventory();
      } else {
        S.pendingEquip = {
          unitId: u.id,
          pickedItemType: pickedItem.type,
          pickedItemId: pickedItem.id,
          prevOverlay: "inventory"
        };
        openReplaceOverlay();
      }
    });

    const unequipWrap = document.createElement("div");
    unequipWrap.style.display = "flex";
    unequipWrap.style.flexDirection = "column";
    unequipWrap.style.gap = "8px";

    const curItems = Array.isArray(u.items) ? u.items : [];
    if (curItems.length){
      for (let i=0;i<curItems.length;i++){
        const it = curItems[i];
        if (!it || !it.type) continue;
        const row = document.createElement("div");
        row.style.display = "grid";
        row.style.gridTemplateColumns = "1.2fr 1fr";
        row.style.gap = "8px";
        const def = ITEMS[it.type];
        const rar = def?.rarity || "Common";
        const col = rarityColor(rar);

        const label = document.createElement("div");
        label.className = "pill";
        label.style.display = "flex";
        label.style.justifyContent = "space-between";
        label.style.alignItems = "center";
        label.style.minWidth = "0";
        label.innerHTML = `<span style="min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${def?.name || "Item"}</span><span style="color:${col}; font-weight:1000; margin-left:8px;">${rar}</span>`;

        const btn = document.createElement("button");
        btn.className = "btnGhost";
        btn.textContent = "Unequip";
        btn.addEventListener("click", ()=>{
          const removed = u.items.splice(i,1)[0];
          if (removed && removed.type){
            S.items.push({ id:rndId(), type: removed.type });
            selectedInvItemId = null;
            el.invHint.textContent = "Unequipped. Select an item to equip again.";
            showToast(`Unequipped ${itemLabel(removed.type)} from ${u.name}`, "info");
            renderAll();
            saveGame();
            renderInventory();
          }
        });

        row.appendChild(label);
        row.appendChild(btn);
        unequipWrap.appendChild(row);
      }
    }

    card.appendChild(equipBtn);
    if (curItems.length) card.appendChild(unequipWrap);

    el.invUnits.appendChild(card);
  }

  if (!S.army.length){
    const empty = document.createElement("div");
    empty.className = "choiceCard";
    empty.innerHTML = `<div class="name">No units</div><div class="desc">Buy units in the shop.</div>`;
    el.invUnits.appendChild(empty);
  }
}

/* ===== Replace overlay ===== */
function openReplaceOverlay(){
  if (!S.pendingEquip) return;
  setOverlay("replace");
  renderReplaceOverlay();
}
function renderReplaceOverlay(){
  el.replaceChoices.innerHTML = "";
  const pe = S.pendingEquip;
  const unit = S.army.find(u=>u.id===pe.unitId);
  if (!unit){
    S.pendingEquip = null;
    setOverlay("inventory");
    renderInventory();
    return;
  }

  const pickedDef = ITEMS[pe.pickedItemType];
  el.replaceSub.textContent = `Replace an item on ${unit.name} with ${pickedDef?.name || "Item"}.`;

  const items = Array.isArray(unit.items) ? unit.items : [];
  for (let i=0;i<items.length;i++){
    const it = items[i];
    const def = ITEMS[it.type];
    const rarCol = rarityColor(def?.rarity || "Common");

    const card = document.createElement("div");
    card.className = "choiceCard";
    card.innerHTML = `
      <div class="name"><span>Replace: ${def?.name || "Item"}</span><span class="rarMini" style="border-color:${rarCol}; color:${rarCol};">${def?.rarity || "Common"}</span></div>
      <div class="desc">${def?.desc || ""}</div>
    `;
    const btn = document.createElement("button");
    btn.className = "btnPrimary";
    btn.textContent = "Replace this slot";
    btn.addEventListener("click", ()=>{
      commitReplace(i);
    });
    card.appendChild(btn);
    el.replaceChoices.appendChild(card);
  }
}
function commitReplace(slotIndex){
  const pe = S.pendingEquip;
  const unit = S.army.find(u=>u.id===pe.unitId);
  if (!pe || !unit){ S.pendingEquip=null; setOverlay("inventory"); renderInventory(); return; }

  const invIdx = S.items.findIndex(x => x.id === pe.pickedItemId);
  if (invIdx < 0){
    showToast("Item not in inventory", "bad");
    S.pendingEquip=null;
    setOverlay("inventory");
    renderInventory();
    return;
  }

  const cur = Array.isArray(unit.items) ? unit.items : (unit.items=[]);
  const replaced = cur[slotIndex];
  if (replaced && replaced.type){
    S.items.push({ id:rndId(), type: replaced.type });
  }

  const picked = S.items.splice(invIdx,1)[0];
  cur[slotIndex] = { id:rndId(), type: picked.type };

  showToast(`${itemLabel(picked.type)} equipped to ${unit.name}`, "good");
  selectedInvItemId = null;
  S.pendingEquip = null;

  renderAll();
  saveGame();

  setOverlay("inventory");
  renderInventory();
}
el.btnReplaceCancel.addEventListener("click", ()=>{
  S.pendingEquip = null;
  setOverlay("inventory");
  renderInventory();
});

/* ===== Result "Next" handling ===== */
function proceedFromResult(){
  if (S.overlay !== "none") return;
  document.body.dataset.result = "hide";
  setOverlay("none");
  beginPostBattleFlow();
}

/* ===== Events wiring ===== */
el.btnReroll.addEventListener("click", () => rerollShop(false));
el.btnStart.addEventListener("click", startCombat);
el.btnNext.addEventListener("click", proceedFromResult);
el.btnResultNext.addEventListener("click", proceedFromResult);

el.btnMenu.addEventListener("click", () => {
  setOverlay("none");
  setScreen("menu");
  showToast("Menu", "info");
  refreshContinueBtn();
});
el.btnInventory.addEventListener("click", () => openInventory());
el.btnSynergies.addEventListener("click", () => openSynergiesOverlay());
el.btnSynClose.addEventListener("click", () => { setOverlay("none"); });

el.btnInvClose.addEventListener("click", ()=>{
  setOverlay("none");
  renderAll();
});

el.btnHowTo.addEventListener("click", () => {
  document.body.dataset.howto = (document.body.dataset.howto === "open") ? "closed" : "open";
});
el.btnNewGame.addEventListener("click", () => newGame());
el.btnContinue.addEventListener("click", () => {
  const ok = loadGame();
  if (!ok) showToast("No save found", "bad");
});

/* ===== Init / New Game ===== */
function newGame(){
  clearSave();
  S.round = 1;
  S.gold = 10;
  S.hp = 20;
  S.streak = 0;
  S.shop = [];
  S.army = [];
  S.augments = [];
  S.items = [];
  S.node = { type:"battle", isElite:false };
  S.nextEnemyMod = null;
  S.overlay = "none";
  S.overlayQueue = [];
  S.pendingEquip = null;

  S.projectiles = [];
  S.floaters = [];
  S.P = []; S.E = [];
  S.combatRunning = false;

  S.army.push(makeUnit("Brawler", 1, "player"));
  S.army.push(makeUnit("Archer", 1, "player"));

  setScreen("planning");
  setPhase("planning");
  rerollShop(true);
  renderAll();
  showToast("New Game", "good");
  saveGame();
}

function init(){
  resizeCanvas();
  refreshContinueBtn();

  if (!localStorage.getItem(SAVE_KEY_V3)){
    if (!tryMigrateV2()) tryMigrateV1();
  }

  setScreen("menu");
  setPhase("planning");
  showToast("Welcome", "info");
  if (!rafId) rafId = requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
