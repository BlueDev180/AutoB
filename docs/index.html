<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Rogue War Autobattler</title>
  <style>
    :root{
      --bg0:#070b16;
      --bg1:#0a1022;
      --card:#0c142b;
      --card2:#0b1226;
      --stroke:rgba(120,170,255,.18);
      --stroke2:rgba(120,170,255,.28);
      --txt:rgba(235,245,255,.92);
      --muted:rgba(235,245,255,.68);
      --muted2:rgba(235,245,255,.52);
      --good:#3ddc84;
      --warn:#ffd166;
      --bad:#ff5a7a;
      --accent:#7bb0ff;
      --shadow: 0 14px 40px rgba(0,0,0,.45);
      --radius:18px;
      --radius2:14px;
      --gap:12px;
      --chip: rgba(130,170,255,.12);
      --chipStroke: rgba(130,170,255,.25);
      --glass: rgba(18,30,60,.55);
    }

    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 30% 10%, #111a33 0%, var(--bg0) 55%) fixed;color:var(--txt);font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
    button{font:inherit}
    .app{min-height:100%;display:flex;flex-direction:column;padding:12px;gap:12px;max-width:900px;margin:0 auto}
    .panel{
      background: linear-gradient(180deg, rgba(15,24,50,.7), rgba(10,16,34,.78));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;padding:10px 12px}
    .titleWrap{display:flex;flex-direction:column;gap:2px}
    .title{font-weight:800;letter-spacing:.2px}
    .subtitle{font-size:12px;color:var(--muted)}
    .pills{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;align-items:center}
    .pill{
      background: rgba(110,160,255,.10);
      border: 1px solid rgba(110,160,255,.22);
      padding:8px 10px;
      border-radius: 999px;
      color:var(--txt);
      font-weight:650;
      font-size:13px;
      white-space:nowrap;
    }
    .pill.small{padding:6px 10px;font-weight:650;font-size:12px;color:var(--muted)}
    .pill.good{border-color: rgba(61,220,132,.35); background: rgba(61,220,132,.10)}
    .pill.bad{border-color: rgba(255,90,122,.35); background: rgba(255,90,122,.10)}
    .btn{
      background: rgba(120,170,255,.12);
      border: 1px solid rgba(120,170,255,.28);
      color:var(--txt);
      padding:12px 14px;
      border-radius: 16px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow: 0 10px 25px rgba(0,0,0,.25);
      cursor:pointer;
      touch-action: manipulation;
    }
    .btn:active{transform: translateY(1px)}
    .btn.primary{background: rgba(120,170,255,.18); border-color: rgba(120,170,255,.45)}
    .btn.ghost{background: transparent;border-color: rgba(120,170,255,.22);color:var(--muted)}
    .btn:disabled{opacity:.45;cursor:not-allowed}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px;padding:12px}
    .stat{
      padding:14px 14px;
      border-radius: 16px;
      border:1px solid rgba(120,170,255,.16);
      background: rgba(12,20,43,.55);
      min-height:74px;
      display:flex;flex-direction:column;justify-content:center;gap:6px;
    }
    .stat .k{font-size:12px;color:var(--muted);font-weight:700;letter-spacing:.2px}
    .stat .v{font-size:26px;font-weight:900}
    .controlsRow{display:grid;grid-template-columns:1fr 1fr;gap:12px;padding:0 12px 12px}
    .section{padding:12px}
    .sectionHeader{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .sectionTitle{font-weight:900;letter-spacing:.2px}
    .hint{font-size:12px;color:var(--muted)}
    .shopGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .card{
      background: rgba(12,20,43,.58);
      border:1px solid rgba(120,170,255,.16);
      border-radius: 18px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height: 146px;
      position:relative;
      overflow:hidden;
    }
    .card:before{
      content:"";
      position:absolute;inset:-1px;
      background: radial-gradient(400px 200px at 10% 10%, rgba(120,170,255,.12), transparent 60%);
      pointer-events:none;
    }
    .cardTop{display:flex;justify-content:space-between;gap:8px;align-items:flex-start;position:relative}
    .name{font-weight:900;font-size:18px}
    .meta{font-size:12px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap;position:relative}
    .badge{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(120,170,255,.22);
      background: rgba(120,170,255,.10);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      font-weight:800;
    }
    .rar-common{border-color:rgba(130,170,255,.22); color:rgba(235,245,255,.70)}
    .rar-uncommon{border-color:rgba(61,220,132,.35); color:rgba(160,255,205,.92); background:rgba(61,220,132,.10)}
    .rar-rare{border-color:rgba(99,155,255,.40); color:rgba(190,220,255,.95); background:rgba(99,155,255,.14)}
    .rar-epic{border-color:rgba(185,120,255,.45); color:rgba(230,205,255,.95); background:rgba(185,120,255,.14)}
    .rar-legendary{border-color:rgba(255,209,102,.55); color:rgba(255,240,205,.98); background:rgba(255,209,102,.12)}
    .line{height:1px;background:rgba(120,170,255,.12);margin:4px 0}
    .buyRow{display:flex;gap:10px;align-items:center;justify-content:space-between;position:relative}
    .stars{font-size:14px;color:var(--muted);font-weight:800;letter-spacing:.15px}
    .traitLine{
      color:var(--muted);
      font-size:12px;
      line-height:1.25;
      display:-webkit-box;
      -webkit-line-clamp:2;
      -webkit-box-orient:vertical;
      overflow:hidden;
      white-space:normal;
      max-width:100%;
    }
    .armyStrip{
      display:flex;gap:10px;overflow:auto;padding-bottom:2px;
      -webkit-overflow-scrolling: touch;
    }
    .armyStrip::-webkit-scrollbar{height:0}
    .unitChip{
      min-width: 240px;
      background: rgba(12,20,43,.62);
      border:1px solid rgba(120,170,255,.16);
      border-radius: 18px;
      padding:12px;
      position:relative;
      overflow:hidden;
      flex:0 0 auto;
    }
    .unitChip .chipTop{display:flex;justify-content:space-between;gap:8px;align-items:flex-start}
    .unitChip .chipName{font-weight:900}
    .unitChip .chipMeta{font-size:12px;color:var(--muted);display:flex;gap:8px;flex-wrap:wrap}
    .chipStats{font-size:12px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;margin-top:6px}
    .chipActions{display:flex;gap:8px;margin-top:10px;align-items:center;justify-content:space-between}
    .miniBtn{
      background: rgba(120,170,255,.10);
      border:1px solid rgba(120,170,255,.22);
      color:var(--txt);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:900;
      cursor:pointer;
      touch-action: manipulation;
    }
    .miniBtn.ghost{background:transparent;color:var(--muted)}
    .miniBtn.bad{border-color:rgba(255,90,122,.35); background:rgba(255,90,122,.10)}
    .miniBtn.good{border-color:rgba(61,220,132,.35); background:rgba(61,220,132,.10)}
    .itemsInline{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .itemPill{
      font-size:11px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(120,170,255,.18);
      background: rgba(120,170,255,.08);
      color:var(--muted);
      max-width: 100%;
      display:flex;gap:6px;align-items:center;
    }
    .itemPill button{
      border:none;background:transparent;color:rgba(255,255,255,.8);
      font-weight:900;cursor:pointer;padding:0 2px
    }

    /* overlays */
    .overlay{
      position:fixed;inset:0;
      background: rgba(2,4,10,.62);
      display:none;
      z-index: 50;
      padding: 12px;
    }
    .overlay.show{display:flex}
    .overlayCard{
      width:min(900px,100%);
      margin:auto;
      background: linear-gradient(180deg, rgba(14,22,48,.92), rgba(8,12,26,.94));
      border:1px solid rgba(120,170,255,.20);
      border-radius: 22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      max-height: calc(100vh - 24px);
      min-height: 60vh;
    }
    .overlayHeader{
      padding:12px 12px 10px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      border-bottom:1px solid rgba(120,170,255,.12);
      background: rgba(10,16,34,.55);
      flex:0 0 auto;
    }
    .overlayHeader .hTitle{font-weight:950;font-size:18px}
    .overlayHeader .hSub{font-size:12px;color:var(--muted);margin-top:2px}
    .overlayHeader .hLeft{display:flex;flex-direction:column}
    .overlayBody{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0; /* critical */
      flex:1 1 auto;
    }

    /* Inventory two columns always */
    .invGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      min-height:0; /* critical */
      flex:1 1 auto;
    }
    .invPane{
      background: rgba(12,20,43,.52);
      border:1px solid rgba(120,170,255,.14);
      border-radius: 18px;
      padding:10px;
      display:flex;
      flex-direction:column;
      min-height:0; /* critical */
    }
    .invPaneHeader{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      margin-bottom:8px;
      flex:0 0 auto;
    }
    .invPaneHeader .t{font-weight:950}
    .invPaneHeader .c{font-size:12px;color:var(--muted)}
    .invList{
      flex:1 1 auto;
      min-height:0; /* critical */
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding-bottom:4px;
    }
    .invRow{
      border:1px solid rgba(120,170,255,.14);
      background: rgba(10,16,34,.60);
      border-radius: 16px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .invRowTop{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .invRowTop .n{font-weight:950}
    .invRowTop .d{font-size:12px;color:var(--muted);margin-top:2px}
    .invRowActions{display:flex;gap:10px;align-items:center;justify-content:flex-end;flex-wrap:wrap}
    .invRow .traitLine{font-size:12px}
    .invRow .slotLine{font-size:12px;color:var(--muted2);font-weight:800}
    .selectedRow{outline: 2px solid rgba(123,176,255,.55); outline-offset: 2px}
    .toast{
      position:fixed;left:50%;top:10px;transform:translateX(-50%);
      background: rgba(10,16,34,.92);
      border:1px solid rgba(120,170,255,.22);
      border-radius: 999px;
      padding:10px 14px;
      color:var(--txt);
      font-weight:900;
      display:none;
      z-index: 80;
      box-shadow: 0 16px 40px rgba(0,0,0,.45);
      max-width: calc(100vw - 24px);
      text-overflow:ellipsis;overflow:hidden;white-space:nowrap;
    }
    .toast.show{display:block}

    /* Battle screen */
    .battleOverlay{
      position:fixed;inset:0;z-index:60;
      background: radial-gradient(1200px 900px at 30% 10%, #111a33 0%, var(--bg0) 55%) fixed;
      display:none;
      flex-direction:column;
    }
    .battleOverlay.show{display:flex}
    .battleHud{
      padding:10px 12px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
    }
    .battleHud .left{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .battleHud .right{display:flex;gap:8px;align-items:center}
    canvas{display:block;width:100%;height:100%}
    .battleWrap{flex:1 1 auto;min-height:0;position:relative}
    .numFloat{
      position:absolute;
      font-weight:950;
      font-size:13px;
      pointer-events:none;
      text-shadow: 0 2px 10px rgba(0,0,0,.65);
      will-change: transform, opacity;
    }
    .numDmg{color: rgba(255,110,140,.98)}
    .numHeal{color: rgba(90,255,170,.98)}
    .numCrit{color: rgba(255,209,102,.98)}
    .modalSmall{
      position:fixed;inset:0;z-index:70;
      background: rgba(2,4,10,.62);
      display:none;padding:12px;
    }
    .modalSmall.show{display:flex}
    .modalCard{
      margin:auto;
      width:min(540px,100%);
      background: linear-gradient(180deg, rgba(14,22,48,.94), rgba(8,12,26,.96));
      border:1px solid rgba(120,170,255,.22);
      border-radius: 20px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalCard .mHead{padding:12px;border-bottom:1px solid rgba(120,170,255,.12)}
    .modalCard .mHead .t{font-weight:950}
    .modalCard .mHead .s{font-size:12px;color:var(--muted);margin-top:4px}
    .modalCard .mBody{padding:12px;display:flex;flex-direction:column;gap:10px}
    .replaceRow{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px;border:1px solid rgba(120,170,255,.14);border-radius:16px;background:rgba(10,16,34,.60)}
    .replaceRow .l{display:flex;flex-direction:column;gap:4px}
    .replaceRow .l .n{font-weight:950}
    .replaceRow .l .d{font-size:12px;color:var(--muted)}
    .footerNote{padding:10px 12px;font-size:12px;color:var(--muted);border-top:1px solid rgba(120,170,255,.12);background: rgba(10,16,34,.55)}
  </style>
</head>
<body>
  <div class="toast" id="toast"></div>

  <div class="app">

    <div class="panel">
      <div class="topbar">
        <div class="titleWrap">
          <div class="title">Rogue War Autobattler</div>
          <div class="subtitle" id="phaseText">Planning: buy/merge • Start Fight to battle</div>
        </div>
        <div class="pills">
          <div class="pill small" id="nextTag">Next: Normal</div>
          <div class="pill small" id="unitsTag">Units: 0</div>
          <button class="btn ghost" id="btnInventory">Inventory</button>
          <button class="btn ghost" id="btnMenu">Menu</button>
        </div>
      </div>

      <div class="grid2">
        <div class="stat"><div class="k">ROUND</div><div class="v" id="roundV">1</div></div>
        <div class="stat"><div class="k">GOLD</div><div class="v" id="goldV">0</div></div>
        <div class="stat"><div class="k">HP</div><div class="v" id="hpV">20</div></div>
        <div class="stat"><div class="k">STREAK</div><div class="v" id="streakV">0</div></div>
      </div>

      <div class="controlsRow">
        <button class="btn" id="btnReroll">Reroll (1g)</button>
        <button class="btn primary" id="btnStartFight">Start Fight</button>
      </div>
    </div>

    <div class="panel">
      <div class="section">
        <div class="sectionHeader">
          <div>
            <div class="sectionTitle">Shop</div>
            <div class="hint">3-of-a-kind merges → ★ up (merging returns items)</div>
          </div>
        </div>
        <div class="shopGrid" id="shopGrid"></div>
      </div>
    </div>

    <div class="panel">
      <div class="section">
        <div class="sectionHeader">
          <div class="sectionTitle">Your Army</div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <button class="miniBtn ghost" id="btnSynergies">Synergies</button>
            <div class="pill small" id="permaTag">Permadeath ON</div>
          </div>
        </div>
        <div class="armyStrip" id="armyStrip"></div>
      </div>
      <div class="footerNote" id="armyNote"></div>
    </div>
  </div>

  <!-- INVENTORY OVERLAY -->
  <div class="overlay" id="invOverlay" aria-hidden="true">
    <div class="overlayCard">
      <div class="overlayHeader">
        <div class="hLeft">
          <div class="hTitle">Inventory</div>
          <div class="hSub" id="invSub">Select an item, then tap “Equip” on a unit.</div>
        </div>
        <button class="btn" id="btnInvClose">Close</button>
      </div>
      <div class="overlayBody">
        <div class="invGrid">
          <div class="invPane">
            <div class="invPaneHeader">
              <div class="t">Items</div>
              <div class="c" id="invItemsCount">0 items</div>
            </div>
            <div class="invList" id="invItems"></div>
          </div>

          <div class="invPane">
            <div class="invPaneHeader">
              <div class="t">Units</div>
              <div class="c" id="invUnitsCount">0 units</div>
            </div>
            <div class="invList" id="invUnits"></div>
          </div>
        </div>
      </div>
      <div class="footerNote">Tip: Unequip returns items here. If a unit is full, you can replace an item.</div>
    </div>
  </div>

  <!-- SYNERGIES OVERLAY -->
  <div class="overlay" id="synOverlay" aria-hidden="true">
    <div class="overlayCard" style="min-height:50vh">
      <div class="overlayHeader">
        <div class="hLeft">
          <div class="hTitle">Synergies</div>
          <div class="hSub" id="synSub">Active bonuses apply in battle.</div>
        </div>
        <button class="btn" id="btnSynClose">Close</button>
      </div>
      <div class="overlayBody" style="min-height:0">
        <div class="invPane" style="min-height:0">
          <div class="invList" id="synList"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- MENU OVERLAY -->
  <div class="overlay" id="menuOverlay" aria-hidden="true">
    <div class="overlayCard" style="min-height:45vh">
      <div class="overlayHeader">
        <div class="hLeft">
          <div class="hTitle">Menu</div>
          <div class="hSub">Run settings + restart.</div>
        </div>
        <button class="btn" id="btnMenuClose">Close</button>
      </div>
      <div class="overlayBody" style="gap:10px">
        <div class="invPane">
          <div class="invList">
            <div class="invRow">
              <div class="invRowTop">
                <div>
                  <div class="n">Permadeath</div>
                  <div class="d">If ON, dead units are removed permanently.</div>
                </div>
                <div class="badge" id="menuPermaBadge">ON</div>
              </div>
              <div class="invRowActions">
                <button class="btn" id="btnTogglePerma">Toggle</button>
              </div>
            </div>

            <div class="invRow">
              <div class="invRowTop">
                <div>
                  <div class="n">Restart Run</div>
                  <div class="d">Resets round, gold, HP, units, items.</div>
                </div>
              </div>
              <div class="invRowActions">
                <button class="btn bad" id="btnRestart">Restart</button>
              </div>
            </div>

            <div class="invRow">
              <div class="invRowTop">
                <div>
                  <div class="n">Help</div>
                  <div class="d">Buy units, merge 3-of-a-kind to ★ up. Equip items from Inventory. Start Fight to battle. Damage/heal numbers appear in battle.</div>
                </div>
              </div>
            </div>

          </div>
        </div>
      </div>
      <div class="footerNote">Designed for phone. Two-column Inventory always visible.</div>
    </div>
  </div>

  <!-- Replace item modal -->
  <div class="modalSmall" id="replaceModal" aria-hidden="true">
    <div class="modalCard">
      <div class="mHead">
        <div class="t">Unit is full</div>
        <div class="s" id="replaceSub">Choose an item to replace.</div>
      </div>
      <div class="mBody" id="replaceBody"></div>
      <div class="footerNote">Replacing returns the old item to Inventory.</div>
    </div>
  </div>

  <!-- BATTLE SCREEN -->
  <div class="battleOverlay" id="battleOverlay" aria-hidden="true">
    <div class="battleHud">
      <div class="left">
        <div class="pill small" id="battleRound">Round 1</div>
        <div class="pill small" id="battleInfo">Battle</div>
      </div>
      <div class="right">
        <button class="btn ghost" id="btnSkipBattle">Skip</button>
      </div>
    </div>
    <div class="battleWrap" id="battleWrap">
      <canvas id="battleCanvas"></canvas>
    </div>
  </div>

  <script>
    // ----------------------------
    // Utilities
    // ----------------------------
    const $ = (q)=>document.querySelector(q);
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>Math.random()*(b-a)+a;
    const choice = (arr)=>arr[Math.floor(Math.random()*arr.length)];
    const uid = ()=>Math.random().toString(16).slice(2)+Date.now().toString(16);

    function showToast(msg){
      const el = $("#toast");
      el.textContent = msg;
      el.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>el.classList.remove("show"), 1000);
    }

    // ----------------------------
    // Data: rarities, classes, items
    // ----------------------------
    const RARITIES = ["Common","Uncommon","Rare","Epic","Legendary"];
    const rarityColorClass = {
      "Common":"rar-common",
      "Uncommon":"rar-uncommon",
      "Rare":"rar-rare",
      "Epic":"rar-epic",
      "Legendary":"rar-legendary"
    };

    // Item slot capacity by rarity (units)
    const slotsByRarity = {
      "Common": 1,
      "Uncommon": 1,
      "Rare": 2,
      "Epic": 2,
      "Legendary": 3
    };

    // Unit pools
    const UNIT_TEMPLATES = [
      // Common
      {id:"brawler",   name:"Brawler",   cost:1, rarity:"Common",   role:"melee", classTag:"Warrior", originTag:"Kingdom", hp:260, atk:18, range:18,  spd:0.95,  shape:"square"},
      {id:"archer",    name:"Archer",    cost:1, rarity:"Common",   role:"ranged",classTag:"Ranger",  originTag:"Wilds",   hp:180, atk:26, range:150, spd:0.95,  shape:"circle"},
      {id:"thug",      name:"Thug",      cost:1, rarity:"Common",   role:"melee", classTag:"Rogue",   originTag:"Wilds",   hp:210, atk:20, range:16,  spd:1.00,  shape:"diamond"},
      {id:"acolyte",   name:"Acolyte",   cost:1, rarity:"Common",   role:"ranged",classTag:"Mage",    originTag:"Cult",    hp:160, atk:22, range:170, spd:1.10,  shape:"hex"},
      // Uncommon
      {id:"healer",    name:"Healer",    cost:2, rarity:"Uncommon", role:"ranged",classTag:"Mage",    originTag:"Cult",    hp:160, atk:10, range:160, spd:1.10,  shape:"circle", healer:true},
      {id:"knight",    name:"Knight",    cost:2, rarity:"Uncommon", role:"melee", classTag:"Warrior", originTag:"Kingdom", hp:320, atk:22, range:16,  spd:1.05,  shape:"square"},
      {id:"crossbow",  name:"Crossbowman",cost:2,rarity:"Uncommon", role:"ranged",classTag:"Ranger",  originTag:"Kingdom", hp:220, atk:30, range:170, spd:1.05,  shape:"triangle"},
      // Rare
      {id:"assassin",  name:"Assassin",  cost:3, rarity:"Rare",     role:"melee", classTag:"Rogue",   originTag:"Wilds",   hp:190, atk:46, range:16,  spd:0.85,  shape:"diamond"},
      {id:"mage",      name:"Mage",      cost:3, rarity:"Rare",     role:"ranged",classTag:"Mage",    originTag:"Cult",    hp:170, atk:34, range:180, spd:1.15,  shape:"hex"},
      {id:"warden",    name:"Warden",    cost:3, rarity:"Rare",     role:"melee", classTag:"Warrior", originTag:"Cult",    hp:420, atk:24, range:18,  spd:1.10,  shape:"square"},
      // Epic
      {id:"warlord",   name:"Warlord",   cost:4, rarity:"Epic",     role:"melee", classTag:"Warrior", originTag:"Kingdom", hp:520, atk:34, range:20,  spd:0.90,  shape:"square"},
      {id:"sniper",    name:"Sniper",    cost:4, rarity:"Epic",     role:"ranged",classTag:"Ranger",  originTag:"Wilds",   hp:260, atk:58, range:220, spd:1.20,  shape:"triangle"},
      {id:"shade",     name:"Shade",     cost:4, rarity:"Epic",     role:"melee", classTag:"Rogue",   originTag:"Cult",    hp:280, atk:52, range:18,  spd:0.90,  shape:"diamond"},
      // Legendary
      {id:"champion",  name:"Champion",  cost:5, rarity:"Legendary",role:"melee", classTag:"Warrior", originTag:"Wilds",   hp:700, atk:56, range:20,  spd:0.85,  shape:"square"},
      {id:"archmage",  name:"Archmage",  cost:5, rarity:"Legendary",role:"ranged",classTag:"Mage",    originTag:"Cult",    hp:320, atk:70, range:240, spd:1.10,  shape:"hex"},
    ];

    // Item templates (simple, visible effects + battle numbers)
    const ITEM_TEMPLATES = [
      {id:"sword",     name:"Sword",     rarity:"Common",    desc:"+20% ATK", mod:{atkPct:0.20}},
      {id:"shield",    name:"Shield",    rarity:"Common",    desc:"+25% Max HP", mod:{hpPct:0.25}},
      {id:"scope",     name:"Scope",     rarity:"Uncommon",  desc:"+30 Range", mod:{rangeAdd:30}},
      {id:"vamp",      name:"Vamp Charm",rarity:"Uncommon",  desc:"+10% Lifesteal", mod:{lifesteal:0.10}},
      {id:"bomb",      name:"Bomb",      rarity:"Rare",      desc:"First hit splashes", mod:{splashFirst:true}},
      {id:"wand",      name:"Wand",      rarity:"Rare",      desc:"+25% ATK for Mages", mod:{atkPct:0.12, classBoost:"Mage", classAtkPct:0.25}},
      {id:"cloak",     name:"Cloak",     rarity:"Epic",      desc:"+20% Dodge (Rogues)", mod:{dodge:0.20, classBoost:"Rogue"}},
      {id:"banner",    name:"War Banner",rarity:"Epic",      desc:"+10% ATK aura (allies)", mod:{auraAtkPct:0.10}},
      {id:"relic",     name:"Ancient Relic",rarity:"Legendary",desc:"+15% ATK + 15% HP", mod:{atkPct:0.15, hpPct:0.15}},
    ];

    // Synergy definitions (thresholds + effect functions)
    const SYNERGIES = {
      "Warrior": {
        thresholds: [2,4,6],
        desc: ["+10% Max HP"," +20% Max HP"," +30% Max HP"],
        apply(unit, tier){ // tier = 0..2
          const pct = [0.10,0.20,0.30][tier];
          unit.maxHp *= (1+pct);
          unit.hp = Math.min(unit.hp, unit.maxHp);
        }
      },
      "Ranger": {
        thresholds: [2,4,6],
        desc: ["+10% ATK","+20% ATK","+30% ATK"],
        apply(unit, tier){
          const pct = [0.10,0.20,0.30][tier];
          unit.atk *= (1+pct);
        }
      },
      "Mage": {
        thresholds: [2,4,6],
        desc: ["+15 Range","+35 Range","+60 Range"],
        apply(unit, tier){
          const add = [15,35,60][tier];
          unit.range += add;
        }
      },
      "Rogue": {
        thresholds: [2,4,6],
        desc: ["+10% Crit","+20% Crit","+30% Crit"],
        apply(unit, tier){
          const add = [0.10,0.20,0.30][tier];
          unit.crit = (unit.crit||0) + add;
        }
      },
      "Kingdom": {
        thresholds: [2,4,6],
        desc: ["+5% ATK aura","+10% ATK aura","+15% ATK aura"],
        aura(tier){
          return [0.05,0.10,0.15][tier];
        }
      },
      "Cult": {
        thresholds: [2,4,6],
        desc: ["+3% Lifesteal","+6% Lifesteal","+10% Lifesteal"],
        apply(unit,tier){
          const add = [0.03,0.06,0.10][tier];
          unit.lifesteal = (unit.lifesteal||0) + add;
        }
      },
      "Wilds": {
        thresholds: [2,4,6],
        desc: ["+8% Attack Speed","+16% Attack Speed","+24% Attack Speed"],
        apply(unit,tier){
          const pct = [0.08,0.16,0.24][tier];
          unit.spd *= (1-pct); // lower interval = faster
          unit.spd = Math.max(0.35, unit.spd);
        }
      }
    };

    // ----------------------------
    // Game state
    // ----------------------------
    const state = {
      round: 1,
      gold: 6,
      hp: 20,
      streak: 0,
      permaDeath: true,
      phase: "planning",
      shop: [],
      army: [],        // unit instances
      inventory: [],   // item instances
      selectedItemId: null, // inventory item instance id
      nextType: "Normal", // Normal/Elite/Boss
      // battle
      battle: null,
    };

    function templateById(id){ return UNIT_TEMPLATES.find(u=>u.id===id); }
    function itemTplById(id){ return ITEM_TEMPLATES.find(i=>i.id===id); }

    // ----------------------------
    // Economy + RNG
    // ----------------------------
    function roundType(round){
      if (round % 10 === 0) return "Boss";
      if (round % 5 === 0) return "Elite";
      return "Normal";
    }

    // Shop rarity chances by round (simple TFT-like curve)
    function shopChances(round){
      // returns array weights aligned to RARITIES
      if (round <= 3)  return [0.78,0.20,0.02,0.00,0.00];
      if (round <= 6)  return [0.58,0.30,0.10,0.02,0.00];
      if (round <= 10) return [0.40,0.32,0.20,0.07,0.01];
      if (round <= 15) return [0.26,0.30,0.26,0.14,0.04];
      if (round <= 20) return [0.16,0.24,0.30,0.22,0.08];
      return              [0.10,0.18,0.28,0.28,0.16];
    }

    function rollRarity(weights){
      const r = Math.random();
      let acc = 0;
      for (let i=0;i<weights.length;i++){
        acc += weights[i];
        if (r <= acc) return RARITIES[i];
      }
      return RARITIES[RARITIES.length-1];
    }

    function rollUnitOffer(){
      const weights = shopChances(state.round);
      const rar = rollRarity(weights);
      const pool = UNIT_TEMPLATES.filter(u=>u.rarity===rar);
      // if pool empty (shouldn't), fallback
      return choice(pool.length?pool:UNIT_TEMPLATES);
    }

    function itemDropChance(round){
      // chance to get an item after a win; elites/bosses give more
      const type = roundType(round);
      if (type === "Boss") return 1.00;
      if (type === "Elite") return 0.70;
      return 0.35;
    }

    function rollItem(){
      // item rarity curve by round
      let weights;
      if (state.round <= 5) weights = [0.70,0.22,0.08,0.00,0.00];
      else if (state.round <= 12) weights = [0.50,0.26,0.16,0.07,0.01];
      else if (state.round <= 20) weights = [0.34,0.25,0.22,0.15,0.04];
      else weights = [0.25,0.22,0.22,0.21,0.10];
      const rar = rollRarity(weights);
      const pool = ITEM_TEMPLATES.filter(i=>i.rarity===rar);
      return choice(pool.length?pool:ITEM_TEMPLATES);
    }

    // ----------------------------
    // Units + items: instances and stats
    // ----------------------------
    function makeUnitInstance(tpl){
      return {
        id: uid(),
        tplId: tpl.id,
        name: tpl.name,
        rarity: tpl.rarity,
        cost: tpl.cost,
        classTag: tpl.classTag,
        originTag: tpl.originTag,
        role: tpl.role,         // melee/ranged
        healer: !!tpl.healer,   // if true: heals allies instead of damaging enemies
        stars: 1,
        base: {
          hp: tpl.hp,
          atk: tpl.atk,
          range: tpl.range,
          spd: tpl.spd
        },
        items: [], // equipped item instance ids
      };
    }

    function makeItemInstance(tpl){
      return { id: uid(), tplId: tpl.id, name: tpl.name, rarity: tpl.rarity, desc: tpl.desc };
    }

    function unitSlotMax(unit){
      return slotsByRarity[unit.rarity] || 1;
    }

    function computeUnitBattleStats(unit, synergyPack, allAlliesForAura){
      const tpl = templateById(unit.tplId);
      const starMult = 1 + (unit.stars-1) * 0.60; // simple scaling
      let maxHp = tpl.hp * starMult;
      let atk = tpl.atk * starMult;
      let range = tpl.range;
      let spd = tpl.spd; // attack interval seconds
      let lifesteal = 0;
      let dodge = 0;
      let crit = 0.05; // base crit
      let splashFirst = false;
      let auraAtkPct = 0;

      // Apply equipped items
      const equipped = unit.items.map(id => state.inventory.find(x=>x.id===id)).filter(Boolean);
      // NOTE: equipped items are removed from inventory in our system, so we store "equipped" differently:
      // We'll keep a separate storage in unit for equipped item objects at battle time.
      // (See buildBattleUnits)
      // So here, equipped will be empty; we pass equippedObjects in buildBattleUnits.

      // Synergy base
      if (synergyPack && synergyPack.applyTo){
        synergyPack.applyTo({ // dummy? no, we apply to computed stats below via direct ops
          get maxHp(){ return maxHp }, set maxHp(v){ maxHp=v },
          get hp(){ return maxHp }, set hp(v){ /* ignore */ },
          get atk(){ return atk }, set atk(v){ atk=v },
          get range(){ return range }, set range(v){ range=v },
          get spd(){ return spd }, set spd(v){ spd=v },
          get lifesteal(){ return lifesteal }, set lifesteal(v){ lifesteal=v },
          get dodge(){ return dodge }, set dodge(v){ dodge=v },
          get crit(){ return crit }, set crit(v){ crit=v },
        }, unit);
      }

      // aura from Kingdom + banner item etc is handled separately in battle builder

      return { maxHp, atk, range, spd, lifesteal, dodge, crit, splashFirst, auraAtkPct };
    }

    // ----------------------------
    // Merging (3-of-a-kind) with item return
    // ----------------------------
    function tryAutoMerge(){
      // group by tplId + stars
      let merged = false;
      let didSomething = true;

      while (didSomething){
        didSomething = false;
        const keyMap = new Map();
        for (const u of state.army){
          const key = u.tplId + "|"+u.stars;
          if (!keyMap.has(key)) keyMap.set(key, []);
          keyMap.get(key).push(u);
        }
        for (const [key, arr] of keyMap.entries()){
          if (arr.length >= 3){
            // pick 3
            const a = arr.slice(0,3);
            // return items from consumed units
            for (const cu of a){
              // return equipped items (if any) to inventory
              if (cu.equipped && cu.equipped.length){
                for (const it of cu.equipped){
                  state.inventory.push(it);
                }
                cu.equipped = [];
              }
              // also return any legacy storage
              if (cu.items && cu.items.length){
                // these ids may reference inventory items; ensure safe:
                // treat as item objects if we stored objects previously
                // (we won't, but keep safe)
                cu.items = [];
              }
            }

            // remove the three
            state.army = state.army.filter(x => !a.some(y=>y.id===x.id));

            // create upgraded
            const base = makeUnitInstance(templateById(a[0].tplId));
            base.stars = a[0].stars + 1;
            base.equipped = []; // holds equipped item objects (not ids)
            state.army.push(base);

            showToast(`Merged 3x ${base.name} → ★${base.stars}! (items returned)`);
            merged = true;
            didSomething = true;
            break;
          }
        }
      }
      if (merged) renderAll();
    }

    // ----------------------------
    // Shop actions
    // ----------------------------
    function fillShop(){
      state.shop = [rollUnitOffer(), rollUnitOffer()].map(tpl => ({
        offerId: uid(),
        tplId: tpl.id,
        name: tpl.name,
        rarity: tpl.rarity,
        cost: tpl.cost
      }));
    }

    function buyOffer(offerId){
      const offer = state.shop.find(o=>o.offerId===offerId);
      if (!offer) return;
      if (state.gold < offer.cost){
        showToast("Not enough gold");
        return;
      }
      state.gold -= offer.cost;
      const unit = makeUnitInstance(templateById(offer.tplId));
      unit.equipped = []; // equipped item objects live here
      state.army.push(unit);
      // remove offer
      state.shop = state.shop.filter(o=>o.offerId!==offerId);
      showToast(`${unit.name} ★1 recruited`);
      tryAutoMerge();
      renderAll();
    }

    function reroll(){
      const cost = 1;
      if (state.gold < cost){ showToast("Not enough gold"); return; }
      state.gold -= cost;
      fillShop();
      showToast("Shop rerolled");
      renderAll();
    }

    // ----------------------------
    // Inventory: equip / unequip
    // ----------------------------
    function getEquippedItems(unit){
      unit.equipped = unit.equipped || [];
      return unit.equipped;
    }

    function selectItem(itemInstanceId){
      state.selectedItemId = itemInstanceId;
      const it = state.inventory.find(x=>x.id===itemInstanceId);
      $("#invSub").textContent = it ? `Selected: ${it.name}. Tap “Equip” on a unit.` : "Select an item, then tap “Equip” on a unit.";
      renderInventory();
    }

    function equipSelectedToUnit(unitId){
      const itemId = state.selectedItemId;
      if (!itemId) return;
      const item = state.inventory.find(x=>x.id===itemId);
      const unit = state.army.find(u=>u.id===unitId);
      if (!item || !unit) return;

      const eq = getEquippedItems(unit);
      const slots = unitSlotMax(unit);

      if (eq.length >= slots){
        openReplaceModal(unit, item);
        return;
      }

      // remove from inventory
      state.inventory = state.inventory.filter(x=>x.id!==itemId);

      // equip
      eq.push(item);
      state.selectedItemId = null;
      $("#invSub").textContent = "Select an item, then tap “Equip” on a unit.";
      showToast(`${item.name} equipped`);
      renderAll();
      renderInventory();
    }

    function unequipItem(unitId, itemInstanceId){
      const unit = state.army.find(u=>u.id===unitId);
      if (!unit) return;
      const eq = getEquippedItems(unit);
      const idx = eq.findIndex(x=>x.id===itemInstanceId);
      if (idx === -1) return;
      const [it] = eq.splice(idx,1);
      state.inventory.push(it);
      showToast(`${it.name} unequipped`);
      renderAll();
      renderInventory();
    }

    // Replace modal (unit full)
    let replaceCtx = null;
    function openReplaceModal(unit, newItem){
      replaceCtx = { unitId: unit.id, newItem };
      $("#replaceSub").textContent = `${unit.name} ★${unit.stars} has full slots. Replace one:`;
      const body = $("#replaceBody");
      body.innerHTML = "";

      const eq = getEquippedItems(unit);
      for (const it of eq){
        const row = document.createElement("div");
        row.className = "replaceRow";
        row.innerHTML = `
          <div class="l">
            <div class="n">${escapeHtml(it.name)} <span class="badge ${rarityColorClass[it.rarity]||""}">${escapeHtml(it.rarity)}</span></div>
            <div class="d">${escapeHtml(it.desc||"")}</div>
          </div>
          <button class="btn">Replace</button>
        `;
        row.querySelector("button").onclick = ()=>replaceItem(it.id);
        body.appendChild(row);
      }

      const cancel = document.createElement("div");
      cancel.style.display="flex";
      cancel.style.justifyContent="flex-end";
      cancel.innerHTML = `<button class="btn ghost">Cancel</button>`;
      cancel.querySelector("button").onclick = closeReplaceModal;
      body.appendChild(cancel);

      $("#replaceModal").classList.add("show");
      $("#replaceModal").setAttribute("aria-hidden","false");
    }

    function closeReplaceModal(){
      replaceCtx = null;
      $("#replaceModal").classList.remove("show");
      $("#replaceModal").setAttribute("aria-hidden","true");
    }

    function replaceItem(oldItemId){
      const ctx = replaceCtx;
      if (!ctx) return;
      const unit = state.army.find(u=>u.id===ctx.unitId);
      if (!unit) return closeReplaceModal();

      const eq = getEquippedItems(unit);
      const oldIdx = eq.findIndex(x=>x.id===oldItemId);
      if (oldIdx === -1) return closeReplaceModal();

      const selectedId = state.selectedItemId;
      const newItem = state.inventory.find(x=>x.id===selectedId);
      if (!newItem){
        // If selection was lost, use ctx.newItem if still in inventory
        const fallback = state.inventory.find(x=>x.id===ctx.newItem.id);
        if (!fallback) return closeReplaceModal();
      }

      const actualNew = state.inventory.find(x=>x.id===selectedId) || ctx.newItem;

      // remove actualNew from inventory
      state.inventory = state.inventory.filter(x=>x.id!==actualNew.id);

      // return old item to inventory
      const [oldIt] = eq.splice(oldIdx,1);
      state.inventory.push(oldIt);

      // equip new
      eq.push(actualNew);

      state.selectedItemId = null;
      $("#invSub").textContent = "Select an item, then tap “Equip” on a unit.";
      showToast(`Replaced ${oldIt.name} → ${actualNew.name}`);
      closeReplaceModal();
      renderAll();
      renderInventory();
    }

    // ----------------------------
    // Synergies
    // ----------------------------
    function countSynergies(){
      const counts = {};
      for (const u of state.army){
        counts[u.classTag] = (counts[u.classTag]||0) + 1;
        counts[u.originTag] = (counts[u.originTag]||0) + 1;
      }
      return counts;
    }

    function activeTierFor(key, count){
      const def = SYNERGIES[key];
      if (!def) return -1;
      let tier = -1;
      for (let i=0;i<def.thresholds.length;i++){
        if (count >= def.thresholds[i]) tier = i;
      }
      return tier;
    }

    function renderSynergies(){
      const list = $("#synList");
      list.innerHTML = "";
      const counts = countSynergies();
      const keys = Object.keys(SYNERGIES);

      for (const k of keys){
        const c = counts[k] || 0;
        const tier = activeTierFor(k, c);
        const def = SYNERGIES[k];
        const row = document.createElement("div");
        row.className = "invRow";
        const active = tier >= 0;
        row.innerHTML = `
          <div class="invRowTop">
            <div>
              <div class="n">${k} <span class="badge ${active ? "rar-uncommon":"rar-common"}">${active ? "ACTIVE" : "INACTIVE"}</span></div>
              <div class="d">Count: <b>${c}</b> • Thresholds: ${def.thresholds.join("/")}</div>
            </div>
          </div>
          <div class="traitLine">${def.desc.map((d,i)=>`${def.thresholds[i]}: ${d}${i===tier?" ✅":""}`).join(" • ")}</div>
        `;
        list.appendChild(row);
      }
    }

    // ----------------------------
    // Battle system (simple DOM+canvas)
    // ----------------------------
    const canvas = $("#battleCanvas");
    const ctx = canvas.getContext("2d");
    function resizeCanvas(){
      const wrap = $("#battleWrap");
      const r = wrap.getBoundingClientRect();
      canvas.width = Math.floor(r.width * devicePixelRatio);
      canvas.height = Math.floor(r.height * devicePixelRatio);
    }
    window.addEventListener("resize", ()=>{ if ($("#battleOverlay").classList.contains("show")) { resizeCanvas(); } });

    function buildBattleUnits(){
      // compute synergies and apply modifiers into battle instances
      const counts = countSynergies();
      const auraFromKingdomTier = (() => {
        const t = activeTierFor("Kingdom", counts["Kingdom"]||0);
        if (t<0) return 0;
        return SYNERGIES["Kingdom"].aura(t);
      })();

      // detect banner items (aura)
      let bannerAura = 0;
      for (const u of state.army){
        const eq = getEquippedItems(u);
        for (const it of eq){
          if (itTplById(it.tplId)?.mod?.auraAtkPct){
            bannerAura = Math.max(bannerAura, itTplById(it.tplId).mod.auraAtkPct);
          }
        }
      }

      const totalAuraAtk = auraFromKingdomTier + bannerAura;

      // synergy applicator for class + origin (excluding Kingdom aura which is handled as aura)
      function applySynergiesToStats(stats, unit){
        // class
        const classCount = counts[unit.classTag]||0;
        const classTier = activeTierFor(unit.classTag, classCount);
        if (classTier >= 0 && SYNERGIES[unit.classTag]?.apply) {
          SYNERGIES[unit.classTag].apply(stats, classTier);
        }
        // origin (non-kingdom auras)
        const orgCount = counts[unit.originTag]||0;
        const orgTier = activeTierFor(unit.originTag, orgCount);
        if (unit.originTag !== "Kingdom" && orgTier >= 0 && SYNERGIES[unit.originTag]?.apply){
          SYNERGIES[unit.originTag].apply(stats, orgTier);
        }
      }

      // create player battle units
      const player = state.army.map((u,i)=>{
        const tpl = templateById(u.tplId);
        const starMult = 1 + (u.stars-1) * 0.60;

        const stats = {
          maxHp: tpl.hp * starMult,
          hp: tpl.hp * starMult,
          atk: tpl.atk * starMult,
          range: tpl.range,
          spd: tpl.spd,
          lifesteal: 0,
          dodge: 0,
          crit: 0.05,
          splashFirst: false,
        };

        // Apply synergies
        applySynergiesToStats(stats, u);

        // Apply equipped items (objects)
        const eq = getEquippedItems(u);
        let firstHit = true;
        for (const it of eq){
          const itTpl = itemTplById(it.tplId);
          if (!itTpl) continue;
          const m = itTpl.mod || {};
          if (m.atkPct) stats.atk *= (1+m.atkPct);
          if (m.hpPct){ stats.maxHp *= (1+m.hpPct); stats.hp = stats.maxHp; }
          if (m.rangeAdd) stats.range += m.rangeAdd;
          if (m.lifesteal) stats.lifesteal += m.lifesteal;
          if (m.dodge) stats.dodge = Math.max(stats.dodge, m.dodge);
          if (m.splashFirst) stats.splashFirst = true;
          if (m.classBoost && m.classBoost === u.classTag && m.classAtkPct){
            stats.atk *= (1+m.classAtkPct);
          }
        }

        // Aura atk
        if (totalAuraAtk > 0) stats.atk *= (1+totalAuraAtk);

        // rare+ units have more slots already; no extra needed

        return {
          side:"P",
          id:u.id,
          name:u.name,
          rarity:u.rarity,
          classTag:u.classTag,
          originTag:u.originTag,
          role:u.role,
          healer: !!tpl.healer,
          stars:u.stars,
          shape: tpl.shape || "circle",
          x: 0, y: 0,
          vx: 0, vy: 0,
          target: null,
          atkCooldown: rand(0, .25),
          ...stats,
          didSplash: false,
        };
      });

      // create enemy army based on round
      const enemyCount = clamp(3 + Math.floor(state.round/3), 3, 12);
      const enemy = [];
      for (let i=0;i<enemyCount;i++){
        // enemy uses same pool but slightly round-scaled
        const tpl = rollUnitOffer(); // using same rarity curve
        const stars = (Math.random() < (state.round>=10?0.25:0.12)) ? 2 : 1;
        const starMult = 1 + (stars-1) * 0.55;
        const hp = tpl.hp * starMult * (1 + Math.min(0.6, state.round*0.02));
        const atk = tpl.atk * starMult * (1 + Math.min(0.45, state.round*0.015));
        enemy.push({
          side:"E",
          id:uid(),
          name:tpl.name,
          rarity:tpl.rarity,
          classTag:tpl.classTag,
          originTag:tpl.originTag,
          role:tpl.role,
          healer:!!tpl.healer,
          stars,
          shape: tpl.shape || "circle",
          x:0,y:0,vx:0,vy:0,
          target:null,
          atkCooldown: rand(0,.25),
          maxHp: hp,
          hp: hp,
          atk: atk,
          range: tpl.range,
          spd: tpl.spd * (1-rand(0,0.08)),
          lifesteal: 0,
          dodge: 0,
          crit: 0.04,
          splashFirst: false,
          didSplash: false,
        });
      }

      // position in battlefield: melee front, ranged back
      function place(sideArr, isEnemy){
        const melee = sideArr.filter(u=>u.role==="melee");
        const ranged = sideArr.filter(u=>u.role!=="melee");
        const W = canvas.width / devicePixelRatio;
        const H = canvas.height / devicePixelRatio;

        const frontX = isEnemy ? W*0.72 : W*0.28;
        const backX  = isEnemy ? W*0.84 : W*0.16;

        function spread(arr, x){
          const n = arr.length;
          if (!n) return;
          for (let i=0;i<n;i++){
            const t = (i+1)/(n+1);
            arr[i].x = x;
            arr[i].y = H*(0.15 + 0.70*t);
          }
        }
        spread(melee, frontX);
        spread(ranged, backX);
      }

      place(player,false);
      place(enemy,true);

      return { player, enemy };
    }

    function startBattle(){
      if (state.phase !== "planning") return;
      if (state.army.length === 0){ showToast("Buy units first"); return; }
      state.phase = "battle";
      $("#phaseText").textContent = "Combat: full-screen battlefield";
      $("#battleOverlay").classList.add("show");
      $("#battleOverlay").setAttribute("aria-hidden","false");
      $("#battleRound").textContent = `Round ${state.round} • ${roundType(state.round)}`;
      resizeCanvas();

      const built = buildBattleUnits();
      state.battle = {
        t:0,
        done:false,
        winner:null,
        player: built.player,
        enemy: built.enemy,
        floats: [],
        lastFrame: performance.now(),
      };

      requestAnimationFrame(stepBattle);
      renderAll();
    }

    function endBattle(winner, skipped=false){
      const battle = state.battle;
      if (!battle) return;

      battle.done = true;
      battle.winner = winner;

      const win = winner === "P";
      if (win){
        state.streak += 1;
        state.gold += 4 + Math.min(6, Math.floor(state.streak/2)); // base + streak bonus
        showToast(skipped ? "WIN (skipped)" : "WIN!");
        // item drop
        if (Math.random() < itemDropChance(state.round)){
          const itTpl = rollItem();
          const it = makeItemInstance(itTpl);
          state.inventory.push(it);
          showToast(`Loot: ${it.name}`);
        }
      } else {
        state.streak = 0;
        state.hp -= (roundType(state.round)==="Boss")?3:(roundType(state.round)==="Elite")?2:1;
        showToast(skipped ? "LOSS (skipped)" : "LOSS!");
        if (state.hp <= 0){
          state.hp = 0;
          showToast("Run ended. Restart in Menu.");
        }
      }

      // permadeath: remove dead units if ON
      if (state.permaDeath){
        const survivors = [];
        const deadIds = new Set();
        for (const pu of battle.player){
          if (pu.hp <= 0) deadIds.add(pu.id);
        }
        for (const u of state.army){
          if (!deadIds.has(u.id)) survivors.push(u);
        }
        if (deadIds.size){
          showToast(`Permadeath: ${deadIds.size} unit(s) lost`);
        }
        state.army = survivors;
      }

      // advance to next round (directly into shop/planning)
      state.round += 1;
      state.nextType = roundType(state.round);
      state.phase = "planning";

      // end screen
      $("#battleOverlay").classList.remove("show");
      $("#battleOverlay").setAttribute("aria-hidden","true");
      state.battle = null;

      // refill shop + income
      state.gold += 2; // small start-of-round income
      fillShop();

      // auto merge (in case new units got added earlier)
      tryAutoMerge();
      renderAll();
    }

    function nearestTarget(attacker, enemies){
      let best = null, bestD = 1e9;
      for (const e of enemies){
        if (e.hp <= 0) continue;
        const dx = e.x - attacker.x;
        const dy = e.y - attacker.y;
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD){ bestD=d2; best=e; }
      }
      return best;
    }

    function nearestAllyNeedingHeal(healer, allies){
      let best=null, bestScore=1e9;
      for (const a of allies){
        if (a.hp<=0) continue;
        if (a.hp >= a.maxHp*0.999) continue;
        const dx=a.x-healer.x, dy=a.y-healer.y;
        const d2=dx*dx+dy*dy;
        if (d2<bestScore){bestScore=d2;best=a;}
      }
      return best;
    }

    function spawnFloat(x,y,text,kind){
      const wrap = $("#battleWrap");
      const el = document.createElement("div");
      el.className = `numFloat ${kind}`;
      el.textContent = text;
      wrap.appendChild(el);

      const start = performance.now();
      const dur = 650;
      const ox = rand(-10,10);
      const oy = rand(-6,6);

      function tick(){
        const t = (performance.now()-start)/dur;
        if (t>=1){
          el.remove();
          return;
        }
        const yy = y - 18 - t*38 + oy;
        const xx = x + ox;
        el.style.transform = `translate(${xx}px, ${yy}px)`;
        el.style.opacity = String(1 - t);
        requestAnimationFrame(tick);
      }
      tick();
    }

    function drawUnit(u){
      const W = canvas.width, H = canvas.height;
      const scale = devicePixelRatio;
      const x = u.x * scale;
      const y = u.y * scale;

      // color by class
      const col = ({
        "Warrior":"rgba(110,170,255,.95)",
        "Ranger":"rgba(90,255,170,.95)",
        "Mage":"rgba(185,120,255,.95)",
        "Rogue":"rgba(255,150,90,.95)"
      })[u.classTag] || "rgba(140,190,255,.95)";

      const enemyTint = u.side==="E" ? "rgba(255,90,122,.92)" : col;
      const size = (u.role==="melee"? 14 : 12) * scale;

      // body
      ctx.save();
      ctx.translate(x,y);
      ctx.globalAlpha = (u.hp>0?1:0.25);

      // shape
      ctx.fillStyle = enemyTint;
      ctx.strokeStyle = "rgba(255,255,255,.15)";
      ctx.lineWidth = 2*scale;

      if (u.shape==="square"){
        ctx.beginPath();
        ctx.roundRect(-size, -size, size*2, size*2, 6*scale);
        ctx.fill(); ctx.stroke();
      } else if (u.shape==="triangle"){
        ctx.beginPath();
        ctx.moveTo(0,-size);
        ctx.lineTo(size, size);
        ctx.lineTo(-size, size);
        ctx.closePath();
        ctx.fill(); ctx.stroke();
      } else if (u.shape==="diamond"){
        ctx.beginPath();
        ctx.moveTo(0,-size);
        ctx.lineTo(size,0);
        ctx.lineTo(0,size);
        ctx.lineTo(-size,0);
        ctx.closePath();
        ctx.fill(); ctx.stroke();
      } else if (u.shape==="hex"){
        ctx.beginPath();
        for (let i=0;i<6;i++){
          const ang = (Math.PI/3)*i - Math.PI/6;
          const px = Math.cos(ang)*size;
          const py = Math.sin(ang)*size;
          if (i===0) ctx.moveTo(px,py);
          else ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.fill(); ctx.stroke();
      } else { // circle
        ctx.beginPath();
        ctx.arc(0,0,size,0,Math.PI*2);
        ctx.fill(); ctx.stroke();
      }

      // hp bar
      const bw = 44*scale, bh = 6*scale;
      const p = clamp(u.hp/u.maxHp,0,1);
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(-bw/2, -size-14*scale, bw, bh);
      ctx.fillStyle = u.side==="E" ? "rgba(255,90,122,.95)" : "rgba(90,255,170,.95)";
      ctx.fillRect(-bw/2, -size-14*scale, bw*p, bh);

      // stars
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.font = `${11*scale}px ui-sans-serif, system-ui`;
      ctx.textAlign="center";
      ctx.fillText("★".repeat(u.stars), 0, size+16*scale);

      ctx.restore();
    }

    function stepBattle(now){
      const battle = state.battle;
      if (!battle) return;
      const dt = Math.min(0.033, (now - battle.lastFrame)/1000);
      battle.lastFrame = now;

      const W = canvas.width / devicePixelRatio;
      const H = canvas.height / devicePixelRatio;

      // background
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.scale(devicePixelRatio, devicePixelRatio);
      ctx.fillStyle = "rgba(255,255,255,.03)";
      for (let x=0;x<W;x+=40){
        ctx.fillRect(x,0,1,H);
      }
      ctx.restore();

      const P = battle.player;
      const E = battle.enemy;

      // victory check
      const pAlive = P.some(u=>u.hp>0);
      const eAlive = E.some(u=>u.hp>0);
      if (!pAlive || !eAlive){
        // stop & resolve
        endBattle(pAlive ? "P" : "E");
        return;
      }

      // update all units
      function updateSide(sideArr, enemyArr, allyArr){
        for (const u of sideArr){
          if (u.hp<=0) continue;

          // choose target
          if (u.healer){
            u.target = nearestAllyNeedingHeal(u, allyArr);
          } else {
            u.target = nearestTarget(u, enemyArr);
          }
          if (!u.target) continue;

          const tx = u.target.x, ty = u.target.y;
          const dx = tx - u.x, dy = ty - u.y;
          const dist = Math.hypot(dx,dy);

          // if in range -> attack
          u.atkCooldown -= dt;
          if (dist <= u.range){
            if (u.atkCooldown <= 0){
              u.atkCooldown = u.spd;
              if (u.healer){
                // heal
                const base = u.atk; // healer "atk" is heal power
                const amount = Math.max(6, Math.floor(base));
                u.target.hp = Math.min(u.target.maxHp, u.target.hp + amount);
                spawnFloat(u.target.x, u.target.y, `+${amount}`, "numHeal");
              } else {
                // hit
                // dodge
                if (Math.random() < (u.target.dodge||0)){
                  spawnFloat(u.target.x, u.target.y, "DODGE", "numCrit");
                } else {
                  let dmg = u.atk;
                  let crit = false;
                  const critChance = (u.crit||0.05);
                  if (Math.random() < critChance){
                    dmg *= 1.6;
                    crit = true;
                  }
                  dmg = Math.max(3, Math.floor(dmg));

                  // splash (first hit)
                  if (u.splashFirst && !u.didSplash){
                    u.didSplash = true;
                    // primary
                    u.target.hp -= dmg;
                    spawnFloat(u.target.x, u.target.y, `-${dmg}`, crit ? "numCrit":"numDmg");
                    // splash nearby
                    for (const e of enemyArr){
                      if (e.hp<=0 || e.id===u.target.id) continue;
                      const dd = Math.hypot(e.x-u.target.x, e.y-u.target.y);
                      if (dd < 55){
                        const sd = Math.floor(dmg*0.45);
                        e.hp -= sd;
                        spawnFloat(e.x, e.y, `-${sd}`, "numDmg");
                      }
                    }
                  } else {
                    u.target.hp -= dmg;
                    spawnFloat(u.target.x, u.target.y, `-${dmg}`, crit ? "numCrit":"numDmg");
                  }

                  // lifesteal
                  const ls = (u.lifesteal||0);
                  if (ls>0){
                    const heal = Math.floor(dmg * ls);
                    if (heal>0){
                      u.hp = Math.min(u.maxHp, u.hp + heal);
                      spawnFloat(u.x, u.y, `+${heal}`, "numHeal");
                    }
                  }
                }
              }
            }
          } else {
            // move toward target
            const speed = 65; // px/sec
            const nx = dx/(dist||1), ny = dy/(dist||1);
            u.x += nx * speed * dt;
            u.y += ny * speed * dt;
            u.x = clamp(u.x, 16, W-16);
            u.y = clamp(u.y, 16, H-16);
          }
        }
      }

      updateSide(P, E, P);
      updateSide(E, P, E);

      // draw units
      ctx.save();
      ctx.scale(devicePixelRatio, devicePixelRatio);
      for (const u of [...P,...E]){
        drawUnit(u);
      }
      ctx.restore();

      requestAnimationFrame(stepBattle);
    }

    // ----------------------------
    // Render
    // ----------------------------
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (m)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[m]));
    }

    function renderShop(){
      const grid = $("#shopGrid");
      grid.innerHTML = "";
      if (state.shop.length === 0){
        const empty = document.createElement("div");
        empty.className = "card";
        empty.innerHTML = `<div class="name">Empty</div><div class="traitLine">Reroll for new offers.</div>`;
        grid.appendChild(empty);
        return;
      }

      for (const offer of state.shop){
        const tpl = templateById(offer.tplId);
        const el = document.createElement("div");
        el.className = "card";
        el.innerHTML = `
          <div class="cardTop">
            <div>
              <div class="name">${escapeHtml(tpl.name)} (${tpl.cost}g)</div>
              <div class="meta">
                <span class="badge ${rarityColorClass[tpl.rarity]||""}">${escapeHtml(tpl.rarity)}</span>
                <span class="badge">${escapeHtml(tpl.role==="melee"?"Front":"Back")}</span>
              </div>
            </div>
            <div class="stars">★</div>
          </div>
          <div class="traitLine">${escapeHtml(tpl.classTag)}/${escapeHtml(tpl.originTag)} • HP ${tpl.hp} • ATK ${tpl.atk} • Range ${tpl.range}px • Spd ${tpl.spd.toFixed(2)}s</div>
          <div class="buyRow">
            <button class="btn primary">Buy</button>
            <div class="badge">${escapeHtml(tpl.classTag)}</div>
          </div>
        `;
        el.querySelector("button").onclick = ()=>buyOffer(offer.offerId);
        grid.appendChild(el);
      }
    }

    function renderArmy(){
      const strip = $("#armyStrip");
      strip.innerHTML = "";
      $("#unitsTag").textContent = `Units: ${state.army.length}`;
      $("#permaTag").textContent = `Permadeath ${state.permaDeath ? "ON":"OFF"}`;
      $("#permaTag").className = `pill small ${state.permaDeath ? "":"bad"}`;

      if (!state.army.length){
        const p = document.createElement("div");
        p.className = "hint";
        p.textContent = "No units yet. Buy from the shop.";
        strip.appendChild(p);
        $("#armyNote").textContent = "Tip: 3-of-a-kind merges automatically. Merging returns items to Inventory.";
        return;
      }

      const counts = countSynergies();
      const active = [];
      for (const k of Object.keys(SYNERGIES)){
        const tier = activeTierFor(k, counts[k]||0);
        if (tier>=0) active.push(`${k}: ${counts[k]} (ACTIVE)`);
      }
      $("#armyNote").textContent = active.length
        ? `Active: ${active.slice(0,4).join(" • ")}${active.length>4 ? " • +" + (active.length-4) + " more" : ""}`
        : "No synergies active yet. Mix traits to activate bonuses.";

      for (const u of state.army){
        const tpl = templateById(u.tplId);
        const eq = getEquippedItems(u);
        const slots = unitSlotMax(u);

        const chip = document.createElement("div");
        chip.className = "unitChip";
        chip.innerHTML = `
          <div class="chipTop">
            <div>
              <div class="chipName">${escapeHtml(tpl.name)} ${"★".repeat(u.stars)}</div>
              <div class="chipMeta">
                <span class="badge ${rarityColorClass[u.rarity]||""}">${escapeHtml(u.rarity)}</span>
                <span class="badge">Slots ${eq.length}/${slots}</span>
              </div>
            </div>
          </div>
          <div class="chipStats">
            <span>HP ${Math.floor(tpl.hp*(1+(u.stars-1)*0.60))}</span>
            <span>ATK ${Math.floor(tpl.atk*(1+(u.stars-1)*0.60))}</span>
            <span>${escapeHtml(tpl.role==="melee"?"Front":"Back")}</span>
          </div>
          <div class="traitLine">${escapeHtml(u.classTag)}/${escapeHtml(u.originTag)}</div>
          <div class="itemsInline" id="items-${u.id}"></div>
          <div class="chipActions">
            <button class="miniBtn ghost" data-sell="${u.id}">Sell (+${Math.max(1, Math.floor(u.cost*0.6))}g)</button>
            <button class="miniBtn" data-openinv="${u.id}">Equip</button>
          </div>
        `;

        // items inline
        const itemsWrap = chip.querySelector(`#items-${CSS.escape(u.id)}`);
        if (!eq.length){
          const sp = document.createElement("div");
          sp.className = "itemPill";
          sp.textContent = "No items";
          itemsWrap.appendChild(sp);
        } else {
          for (const it of eq){
            const pill = document.createElement("div");
            pill.className = "itemPill";
            pill.innerHTML = `${escapeHtml(it.name)} <span class="badge ${rarityColorClass[it.rarity]||""}">${escapeHtml(it.rarity)}</span> <button title="Unequip">×</button>`;
            pill.querySelector("button").onclick = ()=>unequipItem(u.id, it.id);
            itemsWrap.appendChild(pill);
          }
        }

        chip.querySelector(`[data-sell="${u.id}"]`).onclick = ()=>{
          const idx = state.army.findIndex(x=>x.id===u.id);
          if (idx===-1) return;
          // return items
          const eq2 = getEquippedItems(u);
          for (const it of eq2){ state.inventory.push(it); }
          u.equipped = [];
          state.army.splice(idx,1);
          state.gold += Math.max(1, Math.floor(u.cost*0.6));
          showToast(`Sold ${u.name} (items returned)`);
          renderAll();
        };
        chip.querySelector(`[data-openinv="${u.id}"]`).onclick = ()=>{
          openInventory();
        };

        strip.appendChild(chip);
      }
    }

    function renderInventory(){
      $("#invItemsCount").textContent = `${state.inventory.length} item${state.inventory.length===1?"":"s"}`;
      $("#invUnitsCount").textContent = `${state.army.length} unit${state.army.length===1?"":"s"}`;

      // Items
      const itemsEl = $("#invItems");
      itemsEl.innerHTML = "";
      if (!state.inventory.length){
        const row = document.createElement("div");
        row.className = "invRow";
        row.innerHTML = `<div class="invRowTop"><div><div class="n">No items</div><div class="d">Win fights to loot items.</div></div></div>`;
        itemsEl.appendChild(row);
      } else {
        for (const it of state.inventory){
          const tpl = itemTplById(it.tplId);
          const row = document.createElement("div");
          row.className = "invRow" + (state.selectedItemId===it.id ? " selectedRow":"");
          row.innerHTML = `
            <div class="invRowTop">
              <div>
                <div class="n">${escapeHtml(tpl.name)} <span class="badge ${rarityColorClass[tpl.rarity]||""}">${escapeHtml(tpl.rarity)}</span></div>
                <div class="d">${escapeHtml(tpl.desc)}</div>
              </div>
            </div>
            <div class="invRowActions">
              <button class="btn ${state.selectedItemId===it.id ? "primary":"ghost"}">${state.selectedItemId===it.id ? "Selected":"Select"}</button>
            </div>
          `;
          row.querySelector("button").onclick = ()=>selectItem(it.id);
          itemsEl.appendChild(row);
        }
      }

      // Units
      const unitsEl = $("#invUnits");
      unitsEl.innerHTML = "";
      if (!state.army.length){
        const row = document.createElement("div");
        row.className = "invRow";
        row.innerHTML = `<div class="invRowTop"><div><div class="n">No units</div><div class="d">Buy units in the shop.</div></div></div>`;
        unitsEl.appendChild(row);
      } else {
        for (const u of state.army){
          const tpl = templateById(u.tplId);
          const eq = getEquippedItems(u);
          const slots = unitSlotMax(u);

          const row = document.createElement("div");
          row.className = "invRow";
          row.innerHTML = `
            <div class="invRowTop">
              <div>
                <div class="n">${escapeHtml(tpl.name)} ${"★".repeat(u.stars)} <span class="badge ${rarityColorClass[u.rarity]||""}">${escapeHtml(u.rarity)}</span></div>
                <div class="traitLine">${escapeHtml(u.classTag)}/${escapeHtml(u.originTag)} • ${escapeHtml(tpl.role==="melee"?"Front":"Back")}</div>
                <div class="slotLine">Slots ${eq.length}/${slots}</div>
              </div>
              <div class="badge">${escapeHtml(u.classTag)}</div>
            </div>

            <div class="itemsInline" id="invEq-${u.id}"></div>

            <div class="invRowActions">
              <button class="btn primary" ${state.selectedItemId ? "" : "disabled"}>Equip</button>
            </div>
          `;

          // equipped list with unequip
          const eqWrap = row.querySelector(`#invEq-${CSS.escape(u.id)}`);
          if (!eq.length){
            const sp = document.createElement("div");
            sp.className = "itemPill";
            sp.textContent = "No items equipped";
            eqWrap.appendChild(sp);
          } else {
            for (const it of eq){
              const pill = document.createElement("div");
              pill.className = "itemPill";
              pill.innerHTML = `${escapeHtml(it.name)} <span class="badge ${rarityColorClass[it.rarity]||""}">${escapeHtml(it.rarity)}</span> <button title="Unequip">×</button>`;
              pill.querySelector("button").onclick = ()=>unequipItem(u.id, it.id);
              eqWrap.appendChild(pill);
            }
          }

          row.querySelector("button").onclick = ()=>equipSelectedToUnit(u.id);
          unitsEl.appendChild(row);
        }
      }
    }

    function renderAll(){
      $("#roundV").textContent = state.round;
      $("#goldV").textContent = state.gold;
      $("#hpV").textContent = state.hp;
      $("#streakV").textContent = state.streak;
      $("#nextTag").textContent = `Next: ${state.nextType}`;
      $("#btnStartFight").disabled = state.phase !== "planning" || state.hp<=0;
      $("#btnReroll").disabled = state.phase !== "planning" || state.hp<=0;

      renderShop();
      renderArmy();
      renderSynergies();
      if ($("#invOverlay").classList.contains("show")) renderInventory();
      if (state.phase === "planning"){
        $("#phaseText").textContent = "Planning: buy/merge • Start Fight to battle";
      }
    }

    // ----------------------------
    // Overlay open/close
    // ----------------------------
    function openInventory(){
      $("#invOverlay").classList.add("show");
      $("#invOverlay").setAttribute("aria-hidden","false");
      renderInventory();
    }
    function closeInventory(){
      $("#invOverlay").classList.remove("show");
      $("#invOverlay").setAttribute("aria-hidden","true");
      state.selectedItemId = null;
      $("#invSub").textContent = "Select an item, then tap “Equip” on a unit.";
    }

    function openSynergies(){
      $("#synOverlay").classList.add("show");
      $("#synOverlay").setAttribute("aria-hidden","false");
      renderSynergies();
    }
    function closeSynergies(){
      $("#synOverlay").classList.remove("show");
      $("#synOverlay").setAttribute("aria-hidden","true");
    }

    function openMenu(){
      $("#menuOverlay").classList.add("show");
      $("#menuOverlay").setAttribute("aria-hidden","false");
      $("#menuPermaBadge").textContent = state.permaDeath ? "ON":"OFF";
      $("#menuPermaBadge").className = `badge ${state.permaDeath ? "rar-uncommon":"rar-rare"}`;
    }
    function closeMenu(){
      $("#menuOverlay").classList.remove("show");
      $("#menuOverlay").setAttribute("aria-hidden","true");
    }

    // ----------------------------
    // Wiring
    // ----------------------------
    $("#btnInventory").onclick = openInventory;
    $("#btnInvClose").onclick = closeInventory;

    $("#btnSynergies").onclick = openSynergies;
    $("#btnSynClose").onclick = closeSynergies;

    $("#btnMenu").onclick = openMenu;
    $("#btnMenuClose").onclick = closeMenu;

    $("#btnReroll").onclick = reroll;
    $("#btnStartFight").onclick = startBattle;

    $("#btnSkipBattle").onclick = ()=>{
      const b = state.battle;
      if (!b) return;
      // decide winner quickly based on total power
      const pPow = b.player.reduce((s,u)=>s + Math.max(0,u.hp) + u.atk*8, 0);
      const ePow = b.enemy.reduce((s,u)=>s + Math.max(0,u.hp) + u.atk*8, 0);
      endBattle(pPow >= ePow ? "P":"E", true);
    };

    $("#btnTogglePerma").onclick = ()=>{
      state.permaDeath = !state.permaDeath;
      $("#menuPermaBadge").textContent = state.permaDeath ? "ON":"OFF";
      $("#menuPermaBadge").className = `badge ${state.permaDeath ? "rar-uncommon":"rar-rare"}`;
      renderAll();
    };

    $("#btnRestart").onclick = ()=>{
      // reset state
      state.round = 1;
      state.gold = 6;
      state.hp = 20;
      state.streak = 0;
      state.phase = "planning";
      state.shop = [];
      state.army = [];
      state.inventory = [];
      state.selectedItemId = null;
      state.nextType = roundType(state.round);
      fillShop();
      showToast("Run restarted");
      renderAll();
      closeMenu();
    };

    // Close overlays on backdrop tap (but not on card)
    for (const [overlayId, closeFn] of [
      ["invOverlay", closeInventory],
      ["synOverlay", closeSynergies],
      ["menuOverlay", closeMenu],
    ]){
      const ov = $("#"+overlayId);
      ov.addEventListener("click", (e)=>{
        if (e.target === ov) closeFn();
      });
    }
    $("#replaceModal").addEventListener("click",(e)=>{ if (e.target===$("#replaceModal")) closeReplaceModal(); });

    // ----------------------------
    // Init
    // ----------------------------
    function init(){
      state.nextType = roundType(state.round);
      fillShop();

      // Start with a couple items to test equip flow
      // (Remove if you don't want freebies)
      state.inventory.push(makeItemInstance(itemTplById("shield")));
      state.inventory.push(makeItemInstance(itemTplById("sword")));

      renderAll();
    }
    init();
  </script>
</body>
</html>
