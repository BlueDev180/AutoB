<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Rogue War — TFT Roguelike</title>
  <style>
    :root{
      --bg:#0b0e14;
      --panel:#0f1420;
      --panel2:#0c1220;
      --b:#1d2638;
      --b2:#2a3a63;
      --text:#e8eefc;
      --muted:#9fb0d8;
      --good:#55d38a;
      --bad:#ff5c7a;
      --accent:#6aa6ff;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html, body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden;
    }

    .app{
      height:100dvh;
      padding: env(safe-area-inset-top) 10px env(safe-area-inset-bottom) 10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
      overflow:hidden;
    }

    .screen{
      display:none;
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
    }
    body[data-screen="menu"] .screenMenu{ display:flex; }
    body[data-screen="planning"] .screenPlanning{ display:flex; }
    body[data-screen="battle"] .screenBattle{ display:flex; }

    /* ===== Toast override (no queue) ===== */
    #toast{
      position:fixed;
      left:50%;
      top: calc(env(safe-area-inset-top) + 10px);
      transform: translateX(-50%) translateY(-8px);
      max-width: 92vw;
      padding: 10px 14px;
      border-radius: 999px;
      background: rgba(15,20,32,0.92);
      border: 1px solid rgba(42,58,99,0.95);
      color: var(--text);
      font-weight: 1000;
      font-size: 14px;
      line-height: 1.2;
      text-align:center;
      z-index: 9999;
      opacity: 0;
      pointer-events: none;
      backdrop-filter: blur(10px);
      transition: opacity 120ms ease, transform 250ms ease, box-shadow 250ms ease, border-color 250ms ease;

      white-space: normal;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #toast.show{ opacity: 1; transform: translateX(-50%) translateY(0px); }
    #toast.good{
      border-color: rgba(85,211,138,0.70);
      box-shadow: 0 0 0 1px rgba(85,211,138,0.12) inset;
    }
    #toast.bad{
      border-color: rgba(255,92,122,0.70);
      box-shadow: 0 0 0 1px rgba(255,92,122,0.12) inset;
    }

    .panel{
      background:var(--panel);
      border:1px solid var(--b);
      border-radius:14px;
      padding:10px;
      overflow:hidden;
    }
    .panelTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:8px;
      min-width:0;
    }
    .panelTitle{
      font-size:13px;
      font-weight:1000;
      color:#cfe0ff;
      white-space:nowrap;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 62vw;
    }

    button{
      background:#1a2540;
      color:var(--text);
      border:1px solid var(--b2);
      border-radius:12px;
      padding:12px 14px;
      font-weight:1000;
      font-size:13px;
      line-height:1;
      min-height:44px;
      touch-action: manipulation;
      white-space:nowrap;
    }
    button:disabled{ opacity:.5; }
    .btnPrimary{
      border-color: rgba(106,166,255,0.85);
      box-shadow: 0 0 0 1px rgba(106,166,255,0.20) inset;
    }
    .btnGhost{
      background:#121a2c;
      border-color:#24345b;
    }

    .pill{
      border:1px solid var(--b2);
      background:#111a2c;
      padding:7px 10px;
      border-radius:999px;
      font-size:12px;
      color:#b9c6e6;
      white-space:nowrap;
    }
    .pillGood{
      border-color: rgba(85,211,138,0.65);
      box-shadow: 0 0 0 1px rgba(85,211,138,0.12) inset;
    }

    /* ===== MENU ===== */
    .menuWrap{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
      justify-content:center;
    }
    .menuCard{
      width:min(520px, 100%);
      margin:0 auto;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .menuTitle{
      font-size:18px;
      font-weight:1200;
      letter-spacing:0.4px;
      color:#d6e4ff;
      margin-bottom:2px;
      text-align:center;
    }
    .menuSub{
      font-size:12px;
      color:var(--muted);
      text-align:center;
      line-height:1.35;
      margin-bottom:6px;
    }
    .menuBtns{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .howto{
      display:none;
      background:rgba(12,18,32,0.92);
      border:1px solid rgba(42,58,99,0.95);
      border-radius:14px;
      padding:12px;
      line-height:1.35;
      color:#cfe0ff;
      font-size:13px;
    }
    body[data-howto="open"] .howto{ display:block; }

    /* ===== PLANNING ===== */
    .planningWrap{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
    }
    .topPlanning{ flex:0 0 auto; }
    .topGrid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    .phaseRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .phaseLabel{
      font-weight:1100;
      font-size:12px;
      letter-spacing:1px;
      color:#cfe0ff;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--b2);
      background:#0e1627;
      white-space:nowrap;
    }

    .statStrip{
      display:grid;
      grid-template-columns: repeat(4, minmax(0,1fr));
      gap:8px;
    }
    @media (max-width: 420px){
      .statStrip{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    .statTile{
      background:var(--panel2);
      border:1px solid var(--b);
      border-radius:14px;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:2px;
      min-height:64px;
    }
    .statTile .lab{
      font-size:11px;
      color:#b9c6e6;
      font-weight:900;
      letter-spacing:0.3px;
    }
    .statTile .val{
      font-size:20px;
      font-weight:1200;
      color:var(--text);
      line-height:1.05;
    }

    .actionRow{
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap:8px;
    }
    @media (max-width: 420px){
      .actionRow{ grid-template-columns: 1fr 1fr; }
    }

    .planningBody{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
    }
    .shopPanel{ flex: 1 1 56%; min-height:0; display:flex; flex-direction:column; }
    .armyPanel{ flex: 1 1 44%; min-height:0; display:flex; flex-direction:column; }

    .shop{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      gap:10px;
      overflow-x:auto;
      overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      scrollbar-width:none;
      padding-bottom:2px;
    }
    .shop::-webkit-scrollbar{ display:none; }
    .card{
      flex: 0 0 205px;
      background:var(--panel2);
      border:1px solid var(--b);
      border-radius:14px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .card h4{
      margin:0;
      font-size:15px;
      color:var(--text);
      font-weight:1100;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .card .badge{
      width:10px; height:10px; border-radius:999px;
      background:#fff;
      flex:0 0 auto;
      box-shadow: 0 0 0 2px rgba(0,0,0,0.25);
    }
    .line{ font-size:12px; color:var(--muted); }

    .armyBar{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      gap:10px;
      overflow-x:auto;
      overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      scrollbar-width:none;
      padding-bottom:2px;
    }
    .armyBar::-webkit-scrollbar{ display:none; }
    .chip{
      flex:0 0 auto;
      background:#12203b;
      border:1px solid var(--b2);
      border-radius:12px;
      padding:10px 12px;
      min-width: 160px;
      display:flex;
      flex-direction:column;
      gap:4px;
      position:relative;
      overflow:hidden;
      border-left: 6px solid #6aa6ff;
    }
    .chip .t{ font-weight:1100; font-size:13px; display:flex; justify-content:space-between; gap:8px; }
    .chip .s{ font-size:12px; color:#cfe0ff; opacity:.95; }
    .chip .m{ font-size:12px; color:var(--muted); }
    .tinyTag{
      font-size:10px;
      color:#b9c6e6;
      border:1px solid rgba(42,58,99,0.7);
      background:#101a2e;
      padding:3px 6px;
      border-radius:999px;
      white-space:nowrap;
      align-self:flex-start;
    }

    /* Synergy panel */
    .synergyRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .synergyRow .pill{ padding:6px 9px; }

    /* ===== BATTLE ===== */
    .battleWrap{
      flex:1 1 auto;
      min-height:0;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .battleCanvasWrap{
      flex:1 1 auto;
      min-height:0;
      background:var(--panel2);
      border:1px solid var(--b);
      border-radius:14px;
      overflow:hidden;
      position:relative;
    }
    canvas{ width:100%; height:100%; display:block; }

    .overlayTop{
      position:absolute;
      top:10px;
      left:10px;
      right:10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      pointer-events:none;
    }
    .overlayTop .left{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:0;
      pointer-events:none;
    }
    .overlayTop .right{
      display:flex;
      gap:8px;
      align-items:center;
      pointer-events:none;
    }
    .overlayTop .left .pill{
      white-space:normal;
      line-height:1.15;
      max-width: 76vw;
    }
    .overlayTop button{ pointer-events:auto; }

    .resultBox{
      position:absolute;
      left:10px;
      right:10px;
      top:50%;
      transform:translateY(-50%);
      background:rgba(15,20,32,0.92);
      border:1px solid rgba(42,58,99,0.95);
      border-radius:16px;
      padding:14px;
      backdrop-filter: blur(10px);
      display:none;
    }
    body[data-result="show"] .resultBox{ display:block; }
    .resultBox .rTitle{
      font-weight:1200;
      font-size:16px;
      margin-bottom:6px;
    }
    .resultBox .rText{
      font-size:13px;
      color:var(--muted);
      margin-bottom:10px;
      line-height:1.35;
    }
    .resultBox .rBtns{
      display:flex;
      gap:8px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    /* ===== FULLSCREEN OVERLAYS (AUGMENTS / ITEMS / NODES / EVENTS / INVENTORY) ===== */
    .overlay{
      position:fixed;
      inset:0;
      z-index: 9998;
      padding: calc(env(safe-area-inset-top) + 10px) 10px calc(env(safe-area-inset-bottom) + 10px) 10px;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      display:none;
      overflow:hidden;
    }
    body[data-overlay="open"] .overlay{ display:block; }
    .overlayCard{
      height:100%;
      max-width: 620px;
      margin:0 auto;
      background: rgba(15,20,32,0.94);
      border:1px solid rgba(42,58,99,0.95);
      border-radius:16px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:hidden;
    }
    .overlayHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .overlayHeader .title{
      font-weight:1200;
      font-size:16px;
      color:#d6e4ff;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .overlayBody{
      flex:1 1 auto;
      min-height:0;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .overlayList{
      flex:1 1 auto;
      min-height:0;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      border:1px solid rgba(29,38,56,0.75);
      border-radius:14px;
      padding:10px;
      background:#0c1220;
    }
    .overlayList::-webkit-scrollbar{ display:none; }
    .bigCard{
      border:1px solid rgba(42,58,99,0.9);
      border-radius:14px;
      padding:12px;
      background:#0f172b;
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:10px;
    }
    .bigCard:last-child{ margin-bottom:0; }
    .bigCard .h{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      font-weight:1200;
      font-size:15px;
    }
    .bigCard .d{
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }
    .bigCard .tag{
      font-size:11px;
      color:#b9c6e6;
      border:1px solid rgba(42,58,99,0.7);
      background:#101a2e;
      padding:4px 8px;
      border-radius:999px;
      white-space:nowrap;
    }
    .split2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      min-height:0;
      flex:1 1 auto;
      overflow:hidden;
    }
    .col{
      min-height:0;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .col .overlayList{ flex:1 1 auto; }

    @media (max-width: 380px){
      .card{ flex-basis: 195px; }
      .chip{ min-width: 150px; }
      button{ padding:12px 12px; }
      .statTile .val{ font-size:19px; }
      #toast{ font-size:13px; }
    }
  </style>
</head>

<body data-screen="menu" data-result="hide" data-howto="closed" data-overlay="closed">
  <div id="toast" role="status" aria-live="polite"></div>

  <!-- GLOBAL OVERLAY -->
  <div class="overlay" id="overlayRoot" aria-hidden="true">
    <div class="overlayCard">
      <div class="overlayHeader">
        <div class="title" id="ovTitle">Overlay</div>
        <button id="ovClose" class="btnGhost" style="min-height:40px; padding:10px 12px;">Close</button>
      </div>
      <div class="overlayBody" id="ovBody"></div>
    </div>
  </div>

  <div class="app">

    <!-- MENU -->
    <div class="screen screenMenu">
      <div class="menuWrap">
        <div class="menuCard panel">
          <div class="menuTitle">ROGUE WAR</div>
          <div class="menuSub">TFT roguelike: traits, augments, items, and node choices. Permadeath is ON.</div>

          <div class="menuBtns">
            <button id="btnNewGame" class="btnPrimary">New Game</button>
            <button id="btnContinue" disabled>Continue</button>
            <button id="btnHowTo" class="btnGhost">How to Play</button>
          </div>

          <div class="howto" id="howtoBox">
            <div style="font-weight:1000; margin-bottom:6px;">How to Play</div>
            <div>1) Buy units (purchases remove offers). 3-of-a-kind merges → ★ up.</div>
            <div>2) Traits give breakpoint bonuses (Warrior/Ranger/Mage/Rogue + Origins).</div>
            <div>3) Every 3 rounds, pick 1 Augment from 3 choices.</div>
            <div>4) Items drop and can be equipped (1 slot per unit).</div>
            <div>5) After fights, pick your next node: Battle / Elite / Event.</div>
            <div>6) Permadeath: units that die in battle are removed from your roster.</div>
          </div>
        </div>
      </div>
    </div>

    <!-- PLANNING -->
    <div class="screen screenPlanning">
      <div class="planningWrap">

        <div class="panel topPlanning">
          <div class="topGrid">
            <div class="phaseRow">
              <div class="phaseLabel" id="phaseLabel">PLANNING</div>
              <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end;">
                <div class="pill" id="nodePill">Next: Battle</div>
                <div class="pill" id="unitsPill">Units: 0</div>
                <button id="btnInventory" class="btnGhost" style="min-height:40px; padding:10px 12px;">Inventory</button>
                <button id="btnMenu" class="btnGhost" style="min-height:40px; padding:10px 12px;">Menu</button>
              </div>
            </div>

            <div class="statStrip" aria-label="stats">
              <div class="statTile">
                <div class="lab">ROUND</div>
                <div class="val" id="roundVal">1</div>
              </div>
              <div class="statTile">
                <div class="lab">GOLD</div>
                <div class="val" id="goldVal">10</div>
              </div>
              <div class="statTile">
                <div class="lab">HP</div>
                <div class="val" id="hpVal">20</div>
              </div>
              <div class="statTile">
                <div class="lab">STREAK</div>
                <div class="val" id="streakVal">0</div>
              </div>
            </div>

            <div class="actionRow">
              <button id="btnReroll">Reroll (2g)</button>
              <button id="btnStart" class="btnPrimary">Start Fight</button>
            </div>
          </div>
        </div>

        <div class="planningBody">
          <div class="panel shopPanel">
            <div class="panelTop">
              <div class="panelTitle">Shop</div>
              <div class="hint">3-of-a-kind merges → ★ up</div>
            </div>
            <div class="shop" id="shop"></div>
          </div>

          <div class="panel armyPanel">
            <div class="panelTop">
              <div class="panelTitle">Synergies</div>
              <div class="pill">Augments: <span id="augCount">0</span></div>
            </div>
            <div class="synergyRow" id="synergyRow" style="margin-bottom:10px;"></div>

            <div class="panelTop" style="margin-top:2px;">
              <div class="panelTitle">Your Army</div>
              <div class="pill">Permadeath ON</div>
            </div>
            <div class="armyBar" id="armyBar"></div>
          </div>
        </div>

      </div>
    </div>

    <!-- BATTLE -->
    <div class="screen screenBattle">
      <div class="battleWrap">
        <div class="battleCanvasWrap">
          <canvas id="battle"></canvas>

          <div class="overlayTop">
            <div class="left">
              <div class="pill">BATTLE</div>
              <div class="pill" id="battleStats">Round 1 • Gold 10 • HP 20 • Streak 0</div>
            </div>
            <div class="right">
              <button id="btnNext" disabled>Continue</button>
            </div>
          </div>

          <div class="resultBox" id="resultBox">
            <div class="rTitle" id="resultTitle">Result</div>
            <div class="rText" id="resultText">...</div>
            <div class="rBtns">
              <button id="btnResultNext" class="btnPrimary" disabled>Continue</button>
            </div>
          </div>

        </div>
      </div>
    </div>

  </div>

<script>
/* ---- iPhone error overlay ---- */
window.addEventListener("error", (e) => {
  const box = document.createElement("pre");
  box.style.position="fixed";
  box.style.left="0"; box.style.right="0"; box.style.bottom="0";
  box.style.maxHeight="45vh"; box.style.overflow="auto";
  box.style.zIndex="99999"; box.style.margin="0"; box.style.padding="12px";
  box.style.background="rgba(0,0,0,0.92)"; box.style.color="white"; box.style.fontSize="12px";
  box.textContent = "JS ERROR:\n" + (e.message||"Unknown") + "\n\n" + (e.filename||"") + ":" + (e.lineno||"") + ":" + (e.colno||"");
  document.body.appendChild(box);
});

/* ===== Toast override (no queue) ===== */
const toastEl = document.getElementById("toast");
let toastTimer = null;
function showToast(text, type="info"){
  clearTimeout(toastTimer);
  toastEl.classList.remove("good","bad","show");
  if (type === "good") toastEl.classList.add("good");
  if (type === "bad") toastEl.classList.add("bad");
  toastEl.textContent = text;
  void toastEl.offsetWidth;
  toastEl.classList.add("show");
  toastTimer = setTimeout(() => toastEl.classList.remove("show"), 1000);
}

function rndId(){ return (crypto && crypto.randomUUID) ? crypto.randomUUID() : String(Math.random()).slice(2); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* ===== Augments / Items (definitions) ===== */
const AUGMENTS = {
  A1: { name:"Rich Get Richer", desc:"+3g now, +1g at start of each round" },
  A2: { name:"High Roller", desc:"Reroll costs 1g (permanent)" },
  A3: { name:"Windfall", desc:"+8g now (one-time)" },
  A4: { name:"Scoped Weapons", desc:"Ranged units +35 range" },
  A5: { name:"Second Wind", desc:"Once per unit per battle, below 30% HP heal 20% maxHP" },
  A6: { name:"Knife’s Edge", desc:"All units +20% damage, -10% maxHP" },
  A7: { name:"Thick Skin", desc:"Warriors gain +10% damage reduction" },
  A8: { name:"Rapid Fire", desc:"Rangers attack 12% faster" },
  A9:  { name:"Warrior Crest", desc:"+1 Warrior trait count (virtual)" },
  A10: { name:"Ranger Crest",  desc:"+1 Ranger trait count (virtual)" },
  A11: { name:"Mage Crest",    desc:"+1 Mage trait count (virtual)" },
  A12: { name:"Rogue Crest",   desc:"+1 Rogue trait count (virtual)" },
};

const ITEMS = {
  I1: { name:"Sword", desc:"+20% ATK" },
  I2: { name:"Shield", desc:"+25% maxHP" },
  I3: { name:"Bowstring", desc:"+15% attack speed (ranged only)" },
  I4: { name:"Scope", desc:"+30 range" },
  I5: { name:"Vamp Charm", desc:"10% lifesteal" },
  I6: { name:"Bomb", desc:"First hit splashes 35% damage nearby" },
};

function pickRandomKey(obj, excludeKeys=[]){
  const keys = Object.keys(obj).filter(k => !excludeKeys.includes(k));
  return keys[Math.floor(Math.random()*keys.length)];
}

/* ===== Overlay system ===== */
const ov = {
  root: document.getElementById("overlayRoot"),
  title: document.getElementById("ovTitle"),
  body: document.getElementById("ovBody"),
  close: document.getElementById("ovClose"),
};
function setOverlayOpen(open){
  document.body.dataset.overlay = open ? "open" : "closed";
  ov.root.setAttribute("aria-hidden", open ? "false" : "true");
}
function openOverlay(title, canClose=false){
  ov.title.textContent = title;
  ov.body.innerHTML = "";
  ov.close.style.display = canClose ? "" : "none";
  setOverlayOpen(true);
}
function closeOverlay(){
  setOverlayOpen(false);
  ov.body.innerHTML = "";
}
ov.close.addEventListener("click", () => {
  // only used for Inventory overlay (canClose=true)
  closeOverlay();
  saveGame();
  renderAll();
});

/* ===== Save/Load ===== */
const SAVE_V1 = "roguewar_save_v1";
const SAVE_V2 = "roguewar_save_v2";

function serializeState(){
  return {
    v: 2,
    ended: (S.hp <= 0),
    round: S.round,
    gold: S.gold,
    hp: S.hp,
    streak: S.streak,
    maxHp: S.maxHp,
    node: S.node,
    nextEnemyMod: S.nextEnemyMod,
    augments: S.augments,
    items: S.items,
    army: S.army.map(u => ({
      id:u.id, name:u.name, star:u.star,
      item: u.item,
      classTag: u.classTag, originTag: u.originTag
    })),
  };
}
function saveGame(){
  try{
    localStorage.setItem(SAVE_V2, JSON.stringify(serializeState()));
    refreshContinueBtn();
  }catch(e){}
}
function clearSave(){
  try{ localStorage.removeItem(SAVE_V2); }catch(e){}
  refreshContinueBtn();
}
function refreshContinueBtn(){
  try{
    const raw = localStorage.getItem(SAVE_V2) || localStorage.getItem(SAVE_V1);
    if (!raw){ el.btnContinue.disabled = true; return; }
    const data = JSON.parse(raw);
    el.btnContinue.disabled = !data || data.ended;
  }catch(e){
    el.btnContinue.disabled = true;
  }
}

function migrateV1ToV2(v1){
  // v1 had: round,gold,hp,streak,army(id,name,star)
  return {
    v: 2,
    ended: !!v1.ended,
    round: v1.round ?? 1,
    gold: v1.gold ?? 10,
    hp: v1.hp ?? 20,
    streak: v1.streak ?? 0,
    maxHp: 20,
    node: { type:"battle", isElite:false },
    nextEnemyMod: null,
    augments: [],
    items: [],
    army: (v1.army || []).map(a => {
      const base = unitTemplate(a.name);
      return {
        id: a.id || rndId(),
        name: a.name,
        star: a.star || 1,
        item: null,
        classTag: base.classTag,
        originTag: base.originTag
      };
    }),
  };
}

function loadGame(){
  try{
    let raw = localStorage.getItem(SAVE_V2);
    let data = raw ? JSON.parse(raw) : null;

    if (!data){
      const raw1 = localStorage.getItem(SAVE_V1);
      if (!raw1) return false;
      const v1 = JSON.parse(raw1);
      data = migrateV1ToV2(v1);
      localStorage.setItem(SAVE_V2, JSON.stringify(data));
    }

    if (!data || data.v !== 2) return false;
    if (data.ended) return false;

    S.round = data.round ?? 1;
    S.gold = data.gold ?? 10;
    S.hp = data.hp ?? 20;
    S.streak = data.streak ?? 0;
    S.maxHp = data.maxHp ?? 20;

    S.node = data.node || { type:"battle", isElite:false };
    S.nextEnemyMod = data.nextEnemyMod || null;

    S.augments = Array.isArray(data.augments) ? data.augments : [];
    S.items = Array.isArray(data.items) ? data.items : [];

    S.army = (data.army || []).map(a => makeUnit(a.name, a.star, "player", a.id, a.item, a.classTag, a.originTag));

    rerollShop(true);
    renderAll();
    setScreen("planning");
    setPhase("planning");
    showToast("Continued run", "info");
    return true;
  }catch(e){
    return false;
  }
}

/* -------- Data -------- */
const UNIT_POOL = [
  { name:"Brawler",  cost:1, hp: 260, atk: 18, spd: 1.00, range: 18,  role:"Front",    classTag:"Warrior", originTag:"Kingdom" },
  { name:"Knight",   cost:2, hp: 320, atk: 22, spd: 1.05, range: 18,  role:"Front",       classTag:"Warrior", originTag:"Kingdom" },
  { name:"Archer",   cost:1, hp: 180, atk: 26, spd: 0.95, range: 150, role:"Back",     classTag:"Ranger",  originTag:"Wilds"   },
  { name:"Mage",     cost:2, hp: 170, atk: 34, spd: 1.15, range: 160, role:"Mage",     classTag:"Mage",    originTag:"Cult"    },
  { name:"Assassin", cost:3, hp: 190, atk: 46, spd: 0.75, range: 22,  role:"Skirmish", classTag:"Rogue",   originTag:"Wilds"   },
];

function unitTemplate(name){
  return UNIT_POOL.find(u=>u.name===name) || UNIT_POOL[0];
}

function getClassColor(role){
  if (role === "Front")    return { fill:"#5c86c9", fx:"#8cc0ff" };
  if (role === "Back")     return { fill:"#55d38a", fx:"#78f0ad" };
  if (role === "Mage")     return { fill:"#b27bff", fx:"#d5b6ff" };
  if (role === "Skirmish") return { fill:"#ff8a4c", fx:"#ffd36a" };
  return { fill:"#6aa6ff", fx:"#cfe0ff" };
}
function roleToShape(role){
  if (role === "Front") return "square";
  if (role === "Back") return "triangle";
  if (role === "Skirmish") return "diamond";
  if (role === "Mage") return "hex";
  return "circle";
}
function isRangedUnit(u){
  return (u.role === "Back" || u.role === "Mage" || u.range >= 100);
}

function makeUnit(name, star=1, side="player", forcedId=null, item=null, forcedClass=null, forcedOrigin=null){
  const t = unitTemplate(name);
  const hpMult = 1 + (star-1)*0.75;
  const atkMult = 1 + (star-1)*0.60;
  const maxHP = Math.round(t.hp * hpMult);
  const clr = getClassColor(t.role);
  return {
    id: forcedId || rndId(),
    name: t.name,
    cost: t.cost,
    star,
    side,
    role: t.role,
    shape: roleToShape(t.role),
    classFill: clr.fill,
    classFx: clr.fx,
    classTag: forcedClass || t.classTag,
    originTag: forcedOrigin || t.originTag,
    item: item || null,

    maxHP,
    hp: maxHP,
    atk: Math.round(t.atk * atkMult),
    spd: t.spd,     // seconds per attack
    range: t.range, // px
    x: 0, y: 0,
    cd: 0,
    alive: true,
    swingT: 0,
    aimA: 0
  };
}

function makeOffer(template){
  return {
    offerId: rndId(),
    name: template.name,
    cost: template.cost,
    hp: template.hp,
    atk: template.atk,
    spd: template.spd,
    range: template.range,
    role: template.role,
    classTag: template.classTag,
    originTag: template.originTag
  };
}

const S = {
  round: 1,
  gold: 10,
  hp: 20,
  maxHp: 20,
  streak: 0,

  shop: [],
  army: [],

  // TFT roguelike
  augments: [],
  items: [], // inventory items: {id,type}
  node: { type:"battle", isElite:false },
  nextEnemyMod: null, // {hpMult, atkMult} for NEXT battle only (event)
  postBattle: null, // { win, itemDrop, augmentNeeded, eliteReward, goldDeltaText, deadNames }

  // combat
  P: [],
  E: [],
  projectiles: [],
  screen: "menu",
  phase: "planning",
  combatRunning: false,
};

const el = {
  // menu
  btnNewGame: document.getElementById("btnNewGame"),
  btnContinue: document.getElementById("btnContinue"),
  btnHowTo: document.getElementById("btnHowTo"),
  howtoBox: document.getElementById("howtoBox"),

  // planning header
  phaseLabel: document.getElementById("phaseLabel"),
  roundVal: document.getElementById("roundVal"),
  goldVal: document.getElementById("goldVal"),
  hpVal: document.getElementById("hpVal"),
  streakVal: document.getElementById("streakVal"),
  unitsPill: document.getElementById("unitsPill"),
  nodePill: document.getElementById("nodePill"),
  btnMenu: document.getElementById("btnMenu"),
  btnInventory: document.getElementById("btnInventory"),

  // planning content
  shop: document.getElementById("shop"),
  armyBar: document.getElementById("armyBar"),
  btnStart: document.getElementById("btnStart"),
  btnReroll: document.getElementById("btnReroll"),

  // synergies
  synergyRow: document.getElementById("synergyRow"),
  augCount: document.getElementById("augCount"),

  // battle
  battleStats: document.getElementById("battleStats"),
  btnNext: document.getElementById("btnNext"),
  resultBox: document.getElementById("resultBox"),
  resultTitle: document.getElementById("resultTitle"),
  resultText: document.getElementById("resultText"),
  btnResultNext: document.getElementById("btnResultNext"),

  canvas: document.getElementById("battle")
};

function nodeLabel(){
  if (S.node.type === "event") return "Event";
  if (S.node.isElite) return "Elite";
  return "Battle";
}

/* ===== Traits/Synergies ===== */
function getTraitCounts(units){
  const c = {
    Warrior:0, Ranger:0, Mage:0, Rogue:0,
    Kingdom:0, Wilds:0, Cult:0
  };
  for (const u of units){
    c[u.classTag] = (c[u.classTag]||0) + 1;
    c[u.originTag] = (c[u.originTag]||0) + 1;
  }
  // crests (virtual +1)
  if (S.augments.includes("A9"))  c.Warrior += 1;
  if (S.augments.includes("A10")) c.Ranger  += 1;
  if (S.augments.includes("A11")) c.Mage    += 1;
  if (S.augments.includes("A12")) c.Rogue   += 1;
  return c;
}
function tierFor(count, breaks){
  // breaks like [2,4] => tier 0 none, tier1 if >=2, tier2 if >=4
  let t=0;
  for (let i=0;i<breaks.length;i++){
    if (count >= breaks[i]) t = i+1;
  }
  return t;
}
function nextBreakpoint(count, breaks){
  for (const b of breaks) if (count < b) return b;
  return null;
}

/* ===== Stats / Buttons / Screens ===== */
function renderStats(){
  el.roundVal.textContent = S.round;
  el.goldVal.textContent = S.gold;
  el.hpVal.textContent = S.hp;
  el.streakVal.textContent = S.streak;
  el.unitsPill.textContent = `Units: ${S.army.length}`;
  el.nodePill.textContent = `Next: ${nodeLabel()}`;
  el.augCount.textContent = String(S.augments.length);
  el.battleStats.textContent = `Round ${S.round} • Gold ${S.gold} • HP ${S.hp} • Streak ${S.streak}`;
  el.phaseLabel.textContent = "PLANNING";
}
function updateButtons(){
  const overlayOpen = (document.body.dataset.overlay === "open");
  el.btnStart.disabled = overlayOpen || !(S.screen === "planning") || (S.army.length === 0) || (S.node.type === "event");
  el.btnReroll.disabled = overlayOpen || !(S.screen === "planning");
  const canContinue = (!overlayOpen && S.screen === "battle" && S.phase === "result" && S.hp > 0);
  el.btnNext.disabled = !canContinue;
  el.btnResultNext.disabled = !canContinue;
}
function setScreen(screen){
  S.screen = screen;
  document.body.dataset.screen = screen;
  document.body.dataset.result = "hide";
  setTimeout(resizeCanvas, 40);
  renderStats();
  updateButtons();
}
function setPhase(phase){
  S.phase = phase;
  renderStats();
  updateButtons();
}

/* ===== Shop ===== */
function rerollCost(){
  return S.augments.includes("A2") ? 1 : 2;
}
function rerollShop(free=false){
  if (!free){
    const cost = rerollCost();
    if (S.gold < cost){ showToast("Not enough gold", "bad"); return; }
    S.gold -= cost;
    showToast(`Shop rerolled (-${cost}g)`, "info");
  }

  const r = S.round;
  const weights = UNIT_POOL.map(u=>{
    if (r <= 2) return u.cost===1?6 : u.cost===2?2 : 1;
    if (r <= 5) return u.cost===1?4 : u.cost===2?4 : 2;
    return u.cost===1?2 : u.cost===2?5 : 4;
  });
  const total = weights.reduce((a,b)=>a+b,0);

  function pick(){
    let x = Math.random()*total;
    for (let i=0;i<UNIT_POOL.length;i++){
      x -= weights[i];
      if (x<=0) return UNIT_POOL[i];
    }
    return UNIT_POOL[0];
  }

  S.shop = Array.from({length:5}, ()=> makeOffer(pick()));
  renderAll();
  saveGame();
}

function buyOffer(offerId){
  const idx = S.shop.findIndex(o => o.offerId === offerId);
  if (idx < 0) return;
  const offer = S.shop[idx];
  if (S.gold < offer.cost){ showToast("Not enough gold", "bad"); return; }

  S.gold -= offer.cost;
  S.army.push(makeUnit(offer.name, 1, "player"));
  S.shop.splice(idx, 1);

  showToast(`${offer.name} ★1 recruited`, "info");
  mergeAllSafe();
  renderAll();
  saveGame();
}

/* ===== Merge ===== */
function mergeAllSafe(){
  let didMerge = true;
  const mergeMessages = [];

  while (didMerge){
    didMerge = false;

    const map = new Map();
    for (const u of S.army){
      const k = `${u.name}__${u.star}`;
      if (!map.has(k)) map.set(k, []);
      map.get(k).push(u.id);
    }

    let chosen = null;
    for (const [k, ids] of map.entries()){
      if (ids.length >= 3){
        const [name, starStr] = k.split("__");
        const star = Number(starStr);
        if (star >= 3) continue;
        chosen = { name, star, idsToConsume: ids.slice(0,3) };
        break;
      }
    }
    if (!chosen) break;

    const consumeSet = new Set(chosen.idsToConsume);
    S.army = S.army.filter(u => !consumeSet.has(u.id));

    const newStar = Math.min(3, chosen.star + 1);
    S.army.push(makeUnit(chosen.name, newStar, "player"));

    mergeMessages.push(`Merged: ${chosen.name} ★${chosen.star} → ★${newStar}`);
    didMerge = true;
  }

  if (mergeMessages.length){
    showToast(mergeMessages.join(", "), "good");
  }
}

/* ===== Render ===== */
function renderSynergies(){
  el.synergyRow.innerHTML = "";
  const counts = getTraitCounts(S.army);

  const defs = [
    { key:"Warrior", breaks:[2,4] },
    { key:"Ranger",  breaks:[2,4] },
    { key:"Mage",    breaks:[2,3] },
    { key:"Rogue",   breaks:[2,3] },
    { key:"Kingdom", breaks:[2,3] },
    { key:"Wilds",   breaks:[2,3] },
    { key:"Cult",    breaks:[2,3] },
  ];

  const pills = [];
  for (const d of defs){
    const n = counts[d.key] || 0;
    if (n <= 0) continue;
    const t = tierFor(n, d.breaks);
    const nxt = nextBreakpoint(n, d.breaks);
    const text = t>0 ? `${d.key}: ${n} (Active)` : `${d.key}: ${n}${nxt ? ` (Next ${nxt})` : ""}`;
    pills.push({text, active:(t>0)});
  }

  const maxShow = 4;
  const shown = pills.slice(0, maxShow);
  for (const p of shown){
    const div = document.createElement("div");
    div.className = "pill" + (p.active ? " pillGood" : "");
    div.textContent = p.text;
    el.synergyRow.appendChild(div);
  }
  if (pills.length > maxShow){
    const more = document.createElement("div");
    more.className = "pill";
    more.textContent = `+${pills.length - maxShow} more`;
    el.synergyRow.appendChild(more);
  }
}

function renderShop(){
  el.shop.innerHTML = "";
  if (!S.shop.length){
    const empty = document.createElement("div");
    empty.className = "card";
    empty.style.flexBasis = "260px";
    empty.innerHTML = `<h4>Empty</h4><div class="line">Reroll for new offers.</div>`;
    el.shop.appendChild(empty);
    return;
  }

  for (const offer of S.shop){
    const clr = getClassColor(offer.role);

    const card = document.createElement("div");
    card.className = "card";

    const h = document.createElement("h4");
    h.innerHTML = `<span>${offer.name} (${offer.cost}g)</span>`;
    const badge = document.createElement("span");
    badge.className = "badge";
    badge.style.background = clr.fill;
    h.appendChild(badge);

    const l1 = document.createElement("div");
    l1.className="line";
    l1.textContent = `HP ${offer.hp} • ATK ${offer.atk} • ${offer.role}`;

    const l2 = document.createElement("div");
    l2.className="line";
    l2.textContent = `${offer.classTag} • ${offer.originTag}`;

    const btn = document.createElement("button");
    btn.textContent = "Buy";
    btn.disabled = (S.gold < offer.cost);
    btn.addEventListener("click", ()=>buyOffer(offer.offerId));

    card.appendChild(h);
    card.appendChild(l1);
    card.appendChild(l2);
    card.appendChild(btn);
    el.shop.appendChild(card);
  }
}

function renderArmy(){
  el.armyBar.innerHTML = "";
  if (S.army.length === 0){
    const chip = document.createElement("div");
    chip.className="chip";
    chip.style.opacity="0.85";
    chip.style.minWidth="240px";
    chip.innerHTML = `<div class="t">No units</div><div class="m">Buy units to start</div>`;
    el.armyBar.appendChild(chip);
    return;
  }
  for (const u of S.army){
    const clr = getClassColor(u.role);
    const chip = document.createElement("div");
    chip.className="chip";
    chip.style.borderLeftColor = clr.fill;

    const itemTxt = u.item ? ITEMS[u.item.type]?.name : "—";
    chip.innerHTML = `
      <div class="t">
        <span>${u.name} ${"★".repeat(u.star)}</span>
        <span class="tinyTag">${itemTxt}</span>
      </div>
      <div class="s">${u.maxHP} HP • ${u.atk} ATK</div>
      <div class="m">${u.classTag} • ${u.originTag}</div>
    `;
    el.armyBar.appendChild(chip);
  }
}

function renderAll(){
  renderStats();
  renderSynergies();
  renderShop();
  renderArmy();
  updateButtons();
}

/* ===== Inventory Overlay ===== */
function openInventoryOverlay(){
  openOverlay("Inventory", true);

  const wrap = document.createElement("div");
  wrap.className = "split2";

  const left = document.createElement("div");
  left.className = "col";
  const right = document.createElement("div");
  right.className = "col";

  const invTitle = document.createElement("div");
  invTitle.className = "pill";
  invTitle.textContent = `Items: ${S.items.length}`;
  left.appendChild(invTitle);

  const invList = document.createElement("div");
  invList.className = "overlayList";
  left.appendChild(invList);

  const unitTitle = document.createElement("div");
  unitTitle.className = "pill";
  unitTitle.textContent = `Units: ${S.army.length}`;
  right.appendChild(unitTitle);

  const unitList = document.createElement("div");
  unitList.className = "overlayList";
  right.appendChild(unitList);

  let selectedItemId = null;

  function renderInv(){
    invList.innerHTML = "";
    if (S.items.length === 0){
      invList.innerHTML = `<div class="line">No items yet. Win fights (and elites) to find items.</div>`;
      return;
    }
    for (const it of S.items){
      const def = ITEMS[it.type];
      const card = document.createElement("div");
      card.className = "bigCard";
      card.style.borderColor = (selectedItemId === it.id) ? "rgba(106,166,255,0.95)" : "rgba(42,58,99,0.9)";
      card.innerHTML = `
        <div class="h"><span>${def.name}</span><span class="tag">${it.type}</span></div>
        <div class="d">${def.desc}</div>
      `;
      card.addEventListener("click", () => {
        selectedItemId = (selectedItemId === it.id) ? null : it.id;
        renderInv();
        renderUnits();
      });
      invList.appendChild(card);
    }
  }

  function renderUnits(){
    unitList.innerHTML = "";
    if (S.army.length === 0){
      unitList.innerHTML = `<div class="line">No units.</div>`;
      return;
    }
    for (const u of S.army){
      const card = document.createElement("div");
      card.className = "bigCard";
      const itemName = u.item ? ITEMS[u.item.type]?.name : "Empty";
      card.innerHTML = `
        <div class="h"><span>${u.name} ${"★".repeat(u.star)}</span><span class="tag">${itemName}</span></div>
        <div class="d">${u.classTag} • ${u.originTag} • ${u.role}</div>
      `;
      card.addEventListener("click", () => {
        if (!selectedItemId){
          showToast("Tap an item first", "bad");
          return;
        }
        const idx = S.items.findIndex(x => x.id === selectedItemId);
        if (idx < 0) return;

        const picked = S.items[idx];
        S.items.splice(idx, 1);

        // swap
        if (u.item){
          S.items.push(u.item);
        }
        u.item = picked;

        showToast(`${ITEMS[picked.type].name} equipped to ${u.name} ★${u.star}`, "good");

        selectedItemId = null;
        renderInv();
        renderUnits();
        saveGame();
      });
      unitList.appendChild(card);
    }
  }

  wrap.appendChild(left);
  wrap.appendChild(right);
  ov.body.appendChild(wrap);

  const foot = document.createElement("div");
  foot.className = "pill";
  foot.textContent = "Tap an item, then tap a unit to equip (replaces existing item).";
  ov.body.appendChild(foot);

  renderInv();
  renderUnits();
}

/* ===== Rewards + Node Select flow ===== */
function openItemRewardOverlay(itemType){
  openOverlay("Item Found", false);

  const def = ITEMS[itemType];
  const box = document.createElement("div");
  box.className = "overlayList";
  box.innerHTML = `
    <div class="bigCard">
      <div class="h"><span>${def.name}</span><span class="tag">${itemType}</span></div>
      <div class="d">${def.desc}</div>
    </div>
  `;
  ov.body.appendChild(box);

  const btn = document.createElement("button");
  btn.className = "btnPrimary";
  btn.textContent = "Add to Inventory";
  btn.addEventListener("click", () => {
    S.items.push({ id:rndId(), type:itemType });
    closeOverlay();
    saveGame();
    renderAll();
    continuePostBattleFlow();
  });
  ov.body.appendChild(btn);
}

function openAugmentPickOverlay(){
  openOverlay("Choose an Augment", false);

  const exclude = [...S.augments];
  const choices = [];
  const allKeys = Object.keys(AUGMENTS);
  const pool = allKeys.filter(k => !exclude.includes(k));

  function pickAug(){
    if (pool.length === 0) return allKeys[Math.floor(Math.random()*allKeys.length)];
    const k = pool[Math.floor(Math.random()*pool.length)];
    pool.splice(pool.indexOf(k), 1);
    return k;
  }

  while (choices.length < 3){
    choices.push(pickAug());
  }

  const list = document.createElement("div");
  list.className = "overlayList";

  for (const id of choices){
    const a = AUGMENTS[id];
    const card = document.createElement("div");
    card.className = "bigCard";
    card.innerHTML = `
      <div class="h"><span>${a.name}</span><span class="tag">${id}</span></div>
      <div class="d">${a.desc}</div>
    `;
    card.addEventListener("click", () => {
      S.augments.push(id);
      // immediate effects
      if (id === "A1"){ S.gold += 3; showToast("+3g", "good"); }
      if (id === "A3"){ S.gold += 8; showToast("+8g", "good"); }
      closeOverlay();
      saveGame();
      renderAll();
      continuePostBattleFlow();
    });
    list.appendChild(card);
  }

  ov.body.appendChild(list);
  const hint = document.createElement("div");
  hint.className = "pill";
  hint.textContent = "Pick 1. It lasts for the whole run.";
  ov.body.appendChild(hint);
}

function openNodeSelectOverlay(){
  openOverlay("Choose Next Node", false);

  const list = document.createElement("div");
  list.className = "overlayList";

  function nodeCard(title, desc, tag, onPick){
    const card = document.createElement("div");
    card.className = "bigCard";
    card.innerHTML = `
      <div class="h"><span>${title}</span><span class="tag">${tag}</span></div>
      <div class="d">${desc}</div>
    `;
    card.addEventListener("click", onPick);
    list.appendChild(card);
  }

  nodeCard("Battle", "Standard fight. Normal rewards.", "BATTLE", () => {
    S.node = { type:"battle", isElite:false };
    closeOverlay();
    advanceToNextRoundPlanning();
  });

  nodeCard("Elite", "Harder enemies (+25% HP, +10% ATK). Guaranteed item + augment.", "ELITE", () => {
    S.node = { type:"battle", isElite:true };
    closeOverlay();
    advanceToNextRoundPlanning();
  });

  nodeCard("Event", "Pick a risky choice: gold, heal, or duplicate a unit.", "EVENT", () => {
    closeOverlay();
    openEventSelectOverlay();
  });

  ov.body.appendChild(list);
}

function openEventSelectOverlay(){
  openOverlay("Event", false);

  const list = document.createElement("div");
  list.className = "overlayList";

  const events = [
    {
      id:"E1",
      name:"Duplicate",
      desc:"Duplicate a random roster unit (same ★) but lose 3 HP.",
      run: () => {
        if (S.army.length === 0){ showToast("No units to duplicate", "bad"); return; }
        const pick = S.army[Math.floor(Math.random()*S.army.length)];
        S.army.push(makeUnit(pick.name, pick.star, "player"));
        S.hp = Math.max(0, S.hp - 3);
        showToast(`Duplicated ${pick.name} ★${pick.star} (-3 HP)`, "bad");
      }
    },
    {
      id:"E2",
      name:"Gold Rush",
      desc:"+10g now, but next battle enemies +15% HP (one battle).",
      run: () => {
        S.gold += 10;
        S.nextEnemyMod = { hpMult:1.15, atkMult:1.0 };
        showToast("+10g (enemies tougher next battle)", "info");
      }
    },
    {
      id:"E3",
      name:"Heal",
      desc:"Heal +6 HP but lose 4g (if you have it).",
      run: () => {
        const lose = Math.min(4, S.gold);
        S.gold -= lose;
        S.hp = Math.min(S.maxHp, S.hp + 6);
        showToast(`Healed +6 HP (-${lose}g)`, "good");
      }
    }
  ];

  // pick 3 random (they're already 3)
  for (const evn of events){
    const card = document.createElement("div");
    card.className = "bigCard";
    card.innerHTML = `
      <div class="h"><span>${evn.name}</span><span class="tag">${evn.id}</span></div>
      <div class="d">${evn.desc}</div>
    `;
    card.addEventListener("click", () => {
      evn.run();
      // after event, next node becomes normal battle
      S.node = { type:"battle", isElite:false };
      closeOverlay();
      advanceToNextRoundPlanning();
    });
    list.appendChild(card);
  }

  ov.body.appendChild(list);
}

/* ===== Post-battle flow control ===== */
function continuePostBattleFlow(){
  // called after each overlay step closes
  if (!S.postBattle) return;
  if (S.postBattle.itemDrop){
    const t = S.postBattle.itemDrop;
    S.postBattle.itemDrop = null;
    openItemRewardOverlay(t);
    return;
  }
  if (S.postBattle.augmentNeeded){
    S.postBattle.augmentNeeded = false;
    openAugmentPickOverlay();
    return;
  }
  // rewards finished -> node select
  openNodeSelectOverlay();
}

function advanceToNextRoundPlanning(){
  // Start-of-round income
  S.round += 1;

  // baseline +2
  S.gold += 2;

  // A1 +1g per round
  if (S.augments.includes("A1")) S.gold += 1;

  // clear elite flag? node stays chosen for next fight (battle/elite)
  setScreen("planning");
  setPhase("planning");
  rerollShop(true);

  renderAll();
  saveGame();

  // done
  S.postBattle = null;
}

/* ===== Battle ===== */
const ctx = el.canvas.getContext("2d");
let W=0, H=0;

function resizeCanvas(){
  const rect = el.canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = Math.floor(rect.width * dpr);
  H = Math.floor(rect.height * dpr);
  el.canvas.width = W;
  el.canvas.height = H;
}
window.addEventListener("resize", resizeCanvas);

function cloneForCombat(rosterU, side){
  const c = JSON.parse(JSON.stringify(rosterU));
  c.side = side;
  c.hp = c.maxHP;
  c.cd = 0;
  c.alive = true;
  c.swingT = 0;
  c.aimA = 0;
  c.rosterId = rosterU.id;

  // combat-only fields
  c.damageReduction = 0;    // 0..1
  c.regenPerSec = 0;        // % maxHP per second, e.g. 0.03
  c.shield = 0;             // flat shield points
  c.shieldT = 0;            // seconds
  c.lifesteal = 0;          // 0..1
  c.bombReady = false;
  c.firstHit = true;
  c.firstHitBonus = 0;      // 0..1
  c.secondWindUsed = false;
  c.moveSpeedMult = 1;
  c.dmgMult = 1;

  return c;
}

function alive(arr){ return arr.filter(u => u.alive && u.hp > 0); }

function findNearest(att, enemies){
  let best=null, bestD=1e18;
  for (const e of enemies){
    if (!e.alive) continue;
    const dx = e.x - att.x;
    const dy = e.y - att.y;
    const d = dx*dx + dy*dy;
    if (d < bestD){ bestD=d; best=e; }
  }
  return best;
}

function findByIdAnySide(id){
  for (const u of S.P) if (u.id === id) return u;
  for (const u of S.E) if (u.id === id) return u;
  return null;
}

function applyRunBonusesToClone(u, counts){
  // trait tiers
  const tWar = tierFor(counts.Warrior, [2,4]);
  const tRan = tierFor(counts.Ranger, [2,4]);
  const tMag = tierFor(counts.Mage, [2,3]);
  const tRog = tierFor(counts.Rogue, [2,3]);
  const tKin = tierFor(counts.Kingdom, [2,3]);
  const tWil = tierFor(counts.Wilds, [2,3]);
  const tCul = tierFor(counts.Cult, [2,3]);

  // base multipliers from augments
  if (S.augments.includes("A6")){
    u.dmgMult *= 1.20;
    u.maxHP = Math.round(u.maxHP * 0.90);
    u.hp = Math.min(u.hp, u.maxHP);
  }
  if (S.augments.includes("A4") && isRangedUnit(u)){
    u.range += 35;
  }

  // class bonuses
  if (u.classTag === "Warrior"){
    if (tWar === 1) u.maxHP = Math.round(u.maxHP * 1.15);
    if (tWar === 2) u.maxHP = Math.round(u.maxHP * 1.35);
  }
  if (u.classTag === "Ranger"){
    if (tRan === 1) u.spd = u.spd * 0.90;
    if (tRan === 2) u.spd = u.spd * 0.75;
  }
  if (u.classTag === "Mage"){
    if (tMag === 1) u.atk = Math.round(u.atk * 1.15);
    if (tMag === 2) u.atk = Math.round(u.atk * 1.30);
  }
  if (u.classTag === "Rogue"){
    if (tRog === 1){ u.firstHitBonus = Math.max(u.firstHitBonus, 0.20); u.moveSpeedMult *= 1.10; }
    if (tRog === 2){ u.firstHitBonus = Math.max(u.firstHitBonus, 0.45); u.moveSpeedMult *= 1.20; }
  }

  // origin bonuses
  if (u.originTag === "Kingdom" && u.role === "Front"){
    if (tKin === 1) u.damageReduction += 0.10;
    if (tKin === 2) u.damageReduction += 0.20;
  }
  if (u.originTag === "Wilds"){
    if (tWil === 1) u.regenPerSec += 0.015;
    if (tWil === 2) u.regenPerSec += 0.03;
  }
  if (u.originTag === "Cult"){
    // handled on kill: determine shieldPct
    if (tCul === 1) u.cultShieldPct = 0.08;
    if (tCul === 2) u.cultShieldPct = 0.16;
  }

  // augment A7
  if (S.augments.includes("A7") && u.classTag === "Warrior"){
    u.damageReduction += 0.10;
  }

  // augment A8
  if (S.augments.includes("A8") && u.classTag === "Ranger"){
    u.spd = u.spd * 0.88;
  }

  // item effects
  if (u.item && ITEMS[u.item.type]){
    const it = u.item.type;
    if (it === "I1"){ u.atk = Math.round(u.atk * 1.20); }
    if (it === "I2"){ u.maxHP = Math.round(u.maxHP * 1.25); }
    if (it === "I3"){ if (isRangedUnit(u)) u.spd = u.spd * 0.85; }
    if (it === "I4"){ u.range += 30; }
    if (it === "I5"){ u.lifesteal = Math.max(u.lifesteal, 0.10); }
    if (it === "I6"){ u.bombReady = true; }
  }

  // second wind augment (flag exists; behavior in tick)
  // finalize hp after maxHP changes:
  u.hp = u.maxHP;
  u.damageReduction = clamp(u.damageReduction, 0, 0.75);
}

function spawnEnemyWave(){
  const r = S.round;
  const enemyCount = Math.min(14, 3 + Math.floor(r/2));
  S.E = [];

  const weights = UNIT_POOL.map(u=>{
    if (r <= 2) return u.cost===1?6 : u.cost===2?2 : 1;
    if (r <= 5) return u.cost===1?4 : u.cost===2?4 : 2;
    return u.cost===1?2 : u.cost===2?5 : 4;
  });
  const total = weights.reduce((a,b)=>a+b,0);

  function pick(){
    let x = Math.random()*total;
    for (let i=0;i<UNIT_POOL.length;i++){
      x -= weights[i];
      if (x<=0) return UNIT_POOL[i];
    }
    return UNIT_POOL[0];
  }

  for (let i=0;i<enemyCount;i++){
    const t = pick();
    const star = (r >= 6 && Math.random()<0.35) ? 2 : 1;
    const u = makeUnit(t.name, star, "enemy");
    S.E.push(u);
  }

  // apply node modifiers to enemies (elite + event debuff)
  let hpMult = 1.0, atkMult = 1.0;
  if (S.node.isElite){ hpMult *= 1.25; atkMult *= 1.10; }
  if (S.nextEnemyMod){
    hpMult *= (S.nextEnemyMod.hpMult || 1.0);
    atkMult *= (S.nextEnemyMod.atkMult || 1.0);
  }

  if (hpMult !== 1.0 || atkMult !== 1.0){
    for (const e of S.E){
      e.maxHP = Math.round(e.maxHP * hpMult);
      e.hp = e.maxHP;
      e.atk = Math.round(e.atk * atkMult);
    }
  }

  // consume one-battle event debuff once battle starts
  S.nextEnemyMod = null;
}

function deployArmies(){
  S.projectiles = [];
  S.P = S.army.map(u => cloneForCombat(u, "player"));

  // apply trait + augment + item bonuses to player clones
  const counts = getTraitCounts(S.army);
  for (const u of S.P) applyRunBonusesToClone(u, counts);

  // enemies can remain baseline (no synergies) but still allow items etc if you ever add them
  for (const e of S.E){
    e.damageReduction = 0;
    e.regenPerSec = 0;
    e.shield = 0;
    e.shieldT = 0;
    e.lifesteal = 0;
    e.bombReady = false;
    e.firstHit = true;
    e.firstHitBonus = 0;
    e.secondWindUsed = false;
    e.moveSpeedMult = 1;
    e.dmgMult = 1;
  }

  const centerLineX = W/2;
  const sidePadX = W*0.08;
  const topPadY  = H*0.14;
  const bottomPadY = H*0.10;
  const usableH = Math.max(80, H - topPadY - bottomPadY);

  const frontDepth = W*0.12;
  const backGap = W*0.08;

  function splitGroups(arr){
    const front = [];
    const back = [];
    const flank = [];
    for (const u of arr){
      if (u.role === "Skirmish") flank.push(u);
      else if (isRangedUnit(u)) back.push(u);
      else front.push(u);
    }
    return {front, back, flank};
  }

  function placeRank(units, baseX, sideSign){
    const n = units.length;
    if (!n) return;

    const maxRowsTarget = 10;
    const cols = Math.min(4, Math.max(1, Math.ceil(n / maxRowsTarget)));
    const rows = Math.max(1, Math.ceil(n / cols));
    const yStep = usableH / (rows + 1);

    const colOffset = Math.max(14, W*0.02);

    for (let i=0;i<n;i++){
      const col = Math.floor(i / rows);
      const row = i % rows;

      let x = baseX + sideSign * (col * colOffset);
      let y = topPadY + (row + 1) * yStep;

      y += (i % 2 ? 6 : -6);
      x += ((i % 3) - 1) * 4;

      x = clamp(x, 16, W-16);
      y = clamp(y, 16, H-16);

      units[i].x = x;
      units[i].y = y;
    }
  }

  function placeFlanks(units, baseX, sideSign){
    const n = units.length;
    if (!n) return;

    const band = usableH * 0.28;
    const topStart = topPadY;
    const botStart = topPadY + usableH - band;

    const rows = Math.min(6, Math.max(1, Math.ceil(n/2)));
    const colOffset = Math.max(14, W*0.02);

    for (let i=0;i<n;i++){
      const half = Math.ceil(n/2);
      const isTop = i < half;
      const idx = isTop ? i : (i-half);

      let x = baseX + sideSign * (Math.floor(i/rows) * colOffset + backGap*0.35);
      let y = isTop
        ? topStart + (idx+1) * (band / (Math.min(half, rows)+1))
        : botStart + (idx+1) * (band / (Math.min(n-half, rows)+1));

      y += (i % 2 ? 6 : -6);
      x += ((i % 3) - 1) * 4;

      x = clamp(x, 16, W-16);
      y = clamp(y, 16, H-16);

      units[i].x = x;
      units[i].y = y;
    }
  }

  function placeSide(arr, side){
    const sideSign = (side === "player") ? -1 : 1;
    const {front, back, flank} = splitGroups(arr);

    const frontX = centerLineX + sideSign * frontDepth;
    const backX  = centerLineX + sideSign * (frontDepth + backGap);

    const minX = sidePadX;
    const maxX = W - sidePadX;
    const clampX = (x)=> clamp(x, minX, maxX);

    placeRank(front, clampX(frontX), sideSign);
    placeRank(back,  clampX(backX),  sideSign);
    placeFlanks(flank, clampX(frontX), sideSign);
  }

  placeSide(S.P, "player");
  placeSide(S.E, "enemy");
}

/* ===== Combat hooks ===== */
function regenTick(arr, dt){
  for (const u of arr){
    if (!u.alive) continue;
    if (u.shieldT > 0){
      u.shieldT = Math.max(0, u.shieldT - dt);
      if (u.shieldT === 0) u.shield = 0;
    }
    if (u.regenPerSec > 0){
      u.hp = Math.min(u.maxHP, u.hp + (u.regenPerSec * u.maxHP * dt));
    }
    // Second Wind check (augment A5)
    if (S.augments.includes("A5") && !u.secondWindUsed && u.hp > 0 && (u.hp / u.maxHP) < 0.30){
      u.hp = Math.min(u.maxHP, u.hp + 0.20 * u.maxHP);
      u.secondWindUsed = true;
    }
  }
}

function nearestEnemyWithin(foes, x, y, maxD, excludeId=null){
  let best=null, bestD=maxD*maxD;
  for (const e of foes){
    if (!e.alive) continue;
    if (excludeId && e.id === excludeId) continue;
    const dx = e.x - x;
    const dy = e.y - y;
    const d = dx*dx + dy*dy;
    if (d <= bestD){
      bestD = d; best = e;
    }
  }
  return best;
}

function onKill(att){
  // Cult shield on kill (if tier active)
  if (att.cultShieldPct && att.cultShieldPct > 0){
    att.shield = Math.max(att.shield, att.cultShieldPct * att.maxHP);
    att.shieldT = 2.0;
  }
}

function dealDamage(att, tgt, baseDamage, foes, isSplash=false){
  if (!att || !tgt || !tgt.alive) return 0;

  let dmg = baseDamage;

  // attacker multipliers
  dmg *= (att.dmgMult || 1);

  // rogue first hit bonus (primary hit only)
  if (!isSplash && att.firstHit && att.firstHitBonus > 0){
    dmg *= (1 + att.firstHitBonus);
    att.firstHit = false;
  }

  // damage reduction (target)
  dmg *= (1 - (tgt.damageReduction || 0));

  // shield absorb
  let remaining = dmg;
  if (tgt.shield > 0){
    const absorbed = Math.min(tgt.shield, remaining);
    tgt.shield -= absorbed;
    remaining -= absorbed;
  }

  const beforeHP = tgt.hp;
  tgt.hp = Math.max(0, tgt.hp - remaining);
  if (tgt.hp <= 0){
    tgt.alive = false;
    onKill(att);
  }

  const dealtToHP = Math.max(0, beforeHP - tgt.hp);

  // lifesteal (from damage to HP only)
  if (!isSplash && att.lifesteal > 0 && dealtToHP > 0){
    att.hp = Math.min(att.maxHP, att.hp + dealtToHP * att.lifesteal);
  }

  // bomb (primary hit only)
  if (!isSplash && att.bombReady){
    const other = nearestEnemyWithin(foes, tgt.x, tgt.y, 50, tgt.id);
    if (other){
      dealDamage(att, other, baseDamage * 0.35, foes, true);
    }
    att.bombReady = false;
  }

  return dealtToHP;
}

/* ===== Projectiles ===== */
function spawnProjectile(att, target){
  if (S.projectiles.length > 110) S.projectiles.shift();

  const dx = target.x - att.x;
  const dy = target.y - att.y;
  const dist = Math.max(1, Math.sqrt(dx*dx + dy*dy));
  const flight = Math.max(0.22, Math.min(0.45, dist / 520));
  const vx = dx / flight;
  const vy = dy / flight;

  S.projectiles.push({
    x: att.x,
    y: att.y,
    vx, vy,
    ttl: flight + 0.08,
    targetId: target.id,
    attackerId: att.id,
    attackerSide: att.side,
    color: att.classFx || "#cfe0ff"
  });
}

function updateProjectiles(dt){
  for (let i=S.projectiles.length-1; i>=0; i--){
    const p = S.projectiles[i];
    p.ttl -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    const tgt = findByIdAnySide(p.targetId);
    if (!tgt || !tgt.alive){
      S.projectiles.splice(i,1);
      continue;
    }

    const dx = tgt.x - p.x;
    const dy = tgt.y - p.y;
    const d = Math.sqrt(dx*dx + dy*dy);

    if (d < 14 || p.ttl <= 0){
      const att = findByIdAnySide(p.attackerId);
      if (att && att.alive){
        const foes = (att.side === "player") ? alive(S.E) : alive(S.P);
        dealDamage(att, tgt, att.atk, foes, false);
      } else {
        // fallback
        tgt.hp = Math.max(0, tgt.hp - 10);
        if (tgt.hp <= 0) tgt.alive = false;
      }
      S.projectiles.splice(i,1);
    }
  }
}

/* ===== Combat step ===== */
function stepCombat(dt){
  const P = alive(S.P);
  const E = alive(S.E);

  if (P.length === 0 || E.length === 0){
    endCombat(P.length > 0);
    return;
  }

  for (const u of S.P){ u.swingT = Math.max(0, u.swingT - dt); }
  for (const u of S.E){ u.swingT = Math.max(0, u.swingT - dt); }

  regenTick(S.P, dt);
  regenTick(S.E, dt);

  updateProjectiles(dt);

  function stepSide(friends, foes){
    for (const u of friends){
      u.cd -= dt;
      const t = findNearest(u, foes);
      if (!t) continue;

      const dx = t.x - u.x;
      const dy = t.y - u.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const inRange = dist <= u.range;

      if (!inRange){
        const baseSpeed = 62 + (u.star-1)*8;
        const speed = baseSpeed * (u.moveSpeedMult || 1);
        const nx = dx / (dist||1);
        const ny = dy / (dist||1);
        u.x += nx * speed * dt;
        u.y += ny * speed * dt;
        u.x = clamp(u.x, 18, W-18);
        u.y = clamp(u.y, 18, H-18);
      }

      if (u.cd <= 0 && inRange){
        const ang = Math.atan2(dy, dx);
        u.aimA = ang;

        if (isRangedUnit(u)){
          spawnProjectile(u, t);
        } else {
          dealDamage(u, t, u.atk, foes, false);
          u.swingT = 0.18;
        }
        u.cd = u.spd;
      }
    }
  }

  stepSide(P, E);
  stepSide(E, P);
}

/* ===== Drawing ===== */
function drawPoly(points){
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}
function drawShape(x,y,r,shape){
  const pts = [];
  if (shape === "square"){
    const s = r * 0.95;
    pts.push({x:x-s, y:y-s},{x:x+s, y:y-s},{x:x+s, y:y+s},{x:x-s, y:y+s});
    drawPoly(pts); return;
  }
  if (shape === "triangle"){
    const s = r * 1.05;
    pts.push({x:x, y:y-s},{x:x+s, y:y+s},{x:x-s, y:y+s});
    drawPoly(pts); return;
  }
  if (shape === "diamond"){
    const s = r * 1.05;
    pts.push({x:x, y:y-s},{x:x+s, y:y},{x:x, y:y+s},{x:x-s, y:y});
    drawPoly(pts); return;
  }
  if (shape === "hex"){
    const s = r * 1.02;
    for (let i=0;i<6;i++){
      const a = (Math.PI/3)*i - Math.PI/6;
      pts.push({x: x + Math.cos(a)*s, y: y + Math.sin(a)*s});
    }
    drawPoly(pts); return;
  }
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
}

function drawSwing(u, r){
  if (u.swingT <= 0) return;
  const p = Math.min(1, u.swingT / 0.18);
  const len = r * 1.7;
  const a = u.aimA;
  ctx.save();
  ctx.globalAlpha = 0.10 + 0.35 * p;
  ctx.strokeStyle = u.classFx || "#ffd36a";
  ctx.lineWidth = 2 + 2*p;

  const x1 = u.x + Math.cos(a - 0.55) * (r*0.7);
  const y1 = u.y + Math.sin(a - 0.55) * (r*0.7);
  const x2 = u.x + Math.cos(a + 0.35) * len;
  const y2 = u.y + Math.sin(a + 0.35) * len;

  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();
  ctx.restore();
}

function drawProjectiles(){
  for (const p of S.projectiles){
    ctx.save();
    ctx.globalAlpha = 0.45;
    ctx.strokeStyle = p.color || "#cfe0ff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(p.x - p.vx*0.02, p.y - p.vy*0.02);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#e8eefc";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "#0b1020";
  ctx.fillRect(0,0,W,H);

  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "#141d35";
  for (let i=0;i<10;i++){
    ctx.fillRect(i*(W/10), 0, (W/10)-2, H);
  }
  ctx.globalAlpha = 1;

  ctx.globalAlpha = 0.55;
  ctx.strokeStyle = "#233357";
  ctx.lineWidth = Math.max(2, Math.floor(W/320));
  ctx.beginPath();
  ctx.moveTo(W/2, 10);
  ctx.lineTo(W/2, H-10);
  ctx.stroke();
  ctx.globalAlpha = 1;

  drawProjectiles();

  function drawUnit(u){
    const r = 14 + (u.star-1)*4;

    // class colour fill, side outline
    ctx.fillStyle = u.classFill || "#6aa6ff";
    ctx.strokeStyle = (u.side==="player") ? "#cfe0ff" : "#ffd0d9";
    ctx.lineWidth = 2;
    drawShape(u.x, u.y, r, u.shape);

    // shield ring (cult)
    if (u.shield > 0){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "#d5b6ff";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(u.x, u.y, r+4, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    drawSwing(u, r);

    ctx.fillStyle = "#e8eefc";
    ctx.font = `${Math.max(11, Math.floor(W/60))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.fillText(u.name, u.x, u.y - r - 4);

    ctx.fillStyle = "#cfe0ff";
    ctx.font = `${Math.max(10, Math.floor(W/70))}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textBaseline = "top";
    ctx.fillText("★".repeat(u.star), u.x, u.y + r + 2);

    const barW = 52 + (u.star-1)*10;
    const barH = 6;
    const x = u.x - barW/2;
    const y = u.y - r - 14;

    ctx.fillStyle = "#1d2638";
    ctx.fillRect(x, y, barW, barH);

    ctx.fillStyle = (u.side==="player") ? "#55d38a" : "#ff5c7a";
    ctx.fillRect(x, y, barW * (u.hp/u.maxHP), barH);
  }

  for (const u of S.P) if (u.alive) drawUnit(u);
  for (const u of S.E) if (u.alive) drawUnit(u);
}

/* ===== Loop ===== */
let lastT = 0;
let rafId = null;

function loop(t){
  if (!lastT) lastT = t;
  const dt = Math.min(0.05, (t-lastT)/1000);
  lastT = t;

  if (S.combatRunning) stepCombat(dt);
  if (S.screen === "battle") draw();

  rafId = requestAnimationFrame(loop);
}

/* ===== Permadeath + Results ===== */
function applyPermadeath(){
  const dead = S.P.filter(u => !u.alive || u.hp <= 0);
  if (!dead.length) return [];

  const deadIds = new Set(dead.map(u => u.rosterId).filter(Boolean));
  const deadNames = [];

  for (const u of dead){
    if (!u.rosterId) continue;
    deadNames.push(`${u.name} ★${u.star}`);
  }

  S.army = S.army.filter(u => !deadIds.has(u.id));

  if (deadNames.length === 1){
    showToast(`${deadNames[0]} died`, "bad");
  } else if (deadNames.length > 1){
    showToast(`Units lost: ${deadNames.join(", ")}`, "bad");
  }
  return deadNames;
}

function startCombat(){
  if (document.body.dataset.overlay === "open") return;
  if (S.army.length === 0){ showToast("Not enough units", "bad"); return; }

  // cannot start fight if node is event (events resolve before planning)
  if (S.node.type === "event"){ showToast("Choose an event first", "bad"); return; }

  setScreen("battle");
  setPhase("combat");
  S.combatRunning = true;
  showToast(`${nodeLabel()} started`, "info");

  resizeCanvas();

  spawnEnemyWave();
  deployArmies();

  document.body.dataset.result = "hide";
  updateButtons();
}

function showResult(title, summary, good){
  S.combatRunning = false;
  setPhase("result");

  document.body.dataset.result = "show";
  el.resultTitle.textContent = title;
  el.resultTitle.style.color = good ? "var(--good)" : "var(--bad)";
  el.resultText.textContent = summary;

  showToast(summary, good ? "good" : "bad");

  updateButtons();
  renderStats();
}

function endCombat(win){
  const deadNames = applyPermadeath();
  renderAll();

  // base rewards
  let summary = "";
  if (win){
    S.streak += 1;
    const base = 4 + Math.floor(S.round/2);
    const streakBonus = Math.min(4, Math.floor(S.streak/2));
    const goldGain = base + streakBonus;
    S.gold += goldGain;
    summary = `Victory! +${goldGain}g`;
  } else {
    S.streak = 0;
    const dmg = 2 + Math.floor(S.round/2);
    S.hp = Math.max(0, S.hp - dmg);
    S.gold += 3;

    if (S.hp <= 0){
      // game over
      showResult("Game Over", "You ran out of HP. Start a new run from the menu.", false);
      el.btnNext.disabled = true;
      el.btnResultNext.disabled = true;

      try{
        const data = serializeState();
        data.ended = true;
        localStorage.setItem(SAVE_V2, JSON.stringify(data));
      }catch(e){}
      refreshContinueBtn();
      return;
    }
    summary = `Defeat. -${dmg} HP, +3g`;
  }

  // Build postBattle pipeline ONLY if player is alive
  if (S.hp > 0){
    const isElite = !!S.node.isElite;
    const roundAfterThis = S.round + 1; // because we increment on advance
    const augmentNeeded = win && (isElite || (roundAfterThis % 3 === 0));

    // item drop rules (only on win)
    let itemDrop = null;
    if (win){
      if (isElite){
        itemDrop = pickRandomKey(ITEMS);
      } else {
        if (Math.random() < 0.40) itemDrop = pickRandomKey(ITEMS);
      }
    }

    S.postBattle = {
      win,
      itemDrop,
      augmentNeeded,
      deadNames
    };
  }

  showResult(win ? "Victory" : "Defeat", summary, win);
  saveGame();
}

/* ===== Continue button now drives reward -> node -> next planning ===== */
function onContinueAfterBattle(){
  if (!S.postBattle){
    // no pipeline? still advance
    openNodeSelectOverlay();
    return;
  }
  continuePostBattleFlow();
}

/* ===== UI Events ===== */
el.btnStart.addEventListener("click", startCombat);
el.btnReroll.addEventListener("click", () => rerollShop(false));
el.btnNext.addEventListener("click", onContinueAfterBattle);
el.btnResultNext.addEventListener("click", onContinueAfterBattle);

el.btnMenu.addEventListener("click", () => {
  if (document.body.dataset.overlay === "open") closeOverlay();
  setScreen("menu");
  showToast("Menu", "info");
  refreshContinueBtn();
});

el.btnInventory.addEventListener("click", () => {
  openInventoryOverlay();
  updateButtons();
});

el.btnHowTo.addEventListener("click", () => {
  document.body.dataset.howto = (document.body.dataset.howto === "open") ? "closed" : "open";
});

el.btnNewGame.addEventListener("click", () => {
  newGame();
});

el.btnContinue.addEventListener("click", () => {
  const ok = loadGame();
  if (!ok) showToast("No save found", "bad");
});

/* ===== INIT / NEW GAME ===== */
function newGame(){
  clearSave();

  S.round = 1;
  S.gold = 10;
  S.hp = 20;
  S.maxHp = 20;
  S.streak = 0;

  S.army = [];
  S.shop = [];
  S.projectiles = [];
  S.P = []; S.E = [];
  S.combatRunning = false;

  S.augments = [];
  S.items = [];
  S.node = { type:"battle", isElite:false };
  S.nextEnemyMod = null;
  S.postBattle = null;

  // starters
  S.army.push(makeUnit("Brawler", 1, "player"));
  S.army.push(makeUnit("Archer", 1, "player"));

  setScreen("planning");
  setPhase("planning");
  rerollShop(true);
  renderAll();
  showToast("New Game", "good");
  saveGame();

  // pick first node immediately after first battle? no, keep as Battle by default
}

function init(){
  resizeCanvas();
  refreshContinueBtn();
  setScreen("menu");
  setPhase("planning");
  showToast("Welcome", "info");
  if (!rafId) rafId = requestAnimationFrame(loop);
}
init();
</script>
</body>
</html>
