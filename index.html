<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
<title>Auto Battler (Mobile) v60</title>
<style>
  html,body{margin:0;padding:0;background:#121214;height:100svh;overscroll-behavior:none;font-family:-apple-system,system-ui,sans-serif}
  #boot{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#eaeaea;gap:10px}
  #boot .tag{font-size:12px;color:#7bd7ff}
  #boot.err{background:#1a0000}
  #boot.err .msg{max-width:90vw;color:#ffb8b8;white-space:pre-wrap;text-align:center}
  canvas{position:fixed;left:0;top:0;width:100vw;height:100svh;touch-action:manipulation;display:none}
  #toast{position:fixed;top:calc(10px + env(safe-area-inset-top,0px));left:50%;transform:translateX(-50%);
         padding:8px 12px;background:#222;color:#eee;border-radius:8px;font-size:14px;opacity:0;transition:opacity .12s;pointer-events:none}
  #toast.show{opacity:.96}
</style>
</head>
<body>
<div id="boot">
  <div class="tag">Build v60</div>
  <div>Loadingâ€¦</div>
  <div class="msg"></div>
</div>
<canvas id="c"></canvas>
<div id="toast"></div>

<script>
(function topLevel(){
  const BUILD="v60";
  const bootEl=document.getElementById('boot');
  const bootMsg=bootEl.querySelector('.msg');
  const ok=()=>{bootEl.style.display='none'; document.getElementById('c').style.display='block';};
  const fail=(e)=>{
    bootEl.classList.add('err');
    bootMsg.textContent = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
  };

  try{
    // ====== GAME CODE (from v59, plus tiny safety tweaks) ======
    let SHOW_SHOP = true;
    const UI_H_SHOP = 196, UI_H_COMPACT = 96;
    const BUY_COST = 2, REROLL_COST = 2;

    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha:false });
    const toastEl = document.getElementById('toast'); let toastTimer=null;
    const toast=m=>{toastEl.textContent=m;toastEl.classList.add('show');clearTimeout(toastTimer);toastTimer=setTimeout(()=>toastEl.classList.remove('show'),1400);};

    const vv=()=>{const v=visualViewport;const w=Math.min(innerWidth||1e9,document.documentElement.clientWidth||1e9,v?v.width:1e9);const h=Math.min(innerHeight||1e9,document.documentElement.clientHeight||1e9,v?v.height:1e9);return {w:Math.floor(w),h:Math.floor(h)}};
    const isPortrait=()=>vv().h>vv().w;
    const currentUIH=()=>SHOW_SHOP?UI_H_SHOP:UI_H_COMPACT;

    function setCanvasSize(){const dpr=Math.max(1,devicePixelRatio||1);const {w,h}=vv();canvas.width=Math.floor(w*dpr);canvas.height=Math.floor(h*dpr);canvas.style.width=w+'px';canvas.style.height=h+'px';ctx.setTransform(dpr,0,0,dpr,0,0);}
    const COLS=5, ROWS=3;
    let L={cell:48,originX:0,originY:24,gridW:0,gridH:0,yUI:0,vw:0,vh:0};
    function layout(){const {w,h}=vv();const TOP_PAD=36,BTM_BUF=2;const targetUIH=currentUIH();const availH=Math.max(60,h-targetUIH-TOP_PAD-BTM_BUF);const cell=Math.max(14,Math.min(Math.floor(availH/ROWS),Math.floor(w/COLS)));const gridW=COLS*cell,gridH=ROWS*cell;let originY=Math.floor((h-targetUIH-gridH)/2);originY=Math.max(12,Math.min(originY,h-targetUIH-gridH-8));const originX=Math.floor((w-gridW)/2);let yUI=h-targetUIH-BTM_BUF;yUI=Math.max(originY+gridH+8,yUI);L={cell,originX,originY,gridW,gridH,yUI,vw:w,vh:h};}
    function resize(){setCanvasSize();layout();}
    addEventListener('resize',resize,{passive:true});addEventListener('orientationchange',resize,{passive:true});
    if(visualViewport){visualViewport.addEventListener('resize',resize,{passive:true});visualViewport.addEventListener('scroll',resize,{passive:true});}
    resize();

    const C={ bg:'#121214', grid:'#282828', ui:'#1e1e1e', hp:'#e42828', t:'#eaeaea', td:'#d8c878', start:'#7a50a0', hint:'#9ee',
              b:'#c8503c', a:'#50c85a', c:'#78b4dc', e:'#a0a0a0' };
    const COL={ phys:'#ffb27c', physCrit:'#ffd45a', magic:'#88c6ff', magicCrit:'#7de0ff', miss:'#cccccc', heal:'#a6f5c7' };

    const refundFor=u=>(!u)?BUY_COST:(u.star===1?2:u.star===2?6:18);

    const BASE={
      Brawler:{hp:120, atk:18, spd:1.0, range:1, color:C.b, role:'melee',  crit:0.10, critMult:2.0, armor:10, resist:5,  dodge:0.05, lifesteal:0.05},
      Archer: {hp:70,  atk:25, spd:0.8, range:5, color:C.a, role:'ranged', crit:0.20, critMult:2.0, armor:4,  resist:4,  dodge:0.10, lifesteal:0.00},
      Cleric: {hp:80,  atk:8,  spd:1.0, range:5, color:C.c, role:'healer', crit:0.10, critMult:2.0, armor:6,  resist:12, dodge:0.05, lifesteal:0.00},
    };
    const starMul=s=>s===1?1:s===2?1.4:1.8;
    const scaled=(b,s)=>({hp:Math.round(b.hp*starMul(s)),atk:Math.round(b.atk*starMul(s)),spd:b.spd,range:b.range,color:b.color,role:b.role,
      crit:b.crit+(s>=2&&b.role==='ranged'?0.10:0),critMult:2.0,armor:Math.round(b.armor*starMul(s)),resist:Math.round(b.resist*starMul(s)),dodge:b.dodge,lifesteal:b.lifesteal});
    function mkUnit(name,team,cell=null,star=1){const s=scaled(BASE[name],star);return {name,team,cell,star,alive:true,maxhp:s.hp,hp:s.hp,atk:s.atk,spd:s.spd,range:s.range,color:s.color,role:s.role,crit:s.crit,critMult:s.critMult,armor:s.armor,resist:s.resist,dodge:s.dodge,lifesteal:s.lifesteal,cool:0,stepCool:0,lastPos:null,shield:0,shieldT:0};}

    let gold=6, floorN=1, state='shop', result=null;
    const roster=[], enemies=[];
    let shop=[], preview=null;
    const buyAreas=[]; let startArea={x:0,y:0,w:0,h:0}, rerollArea={x:0,y:0,w:0,h:0}, sellArea={x:0,y:0,w:0,h:0};
    let shopBtn={x:16,y:20,w:160,h:54};

    function refillShop(){const k=Object.keys(BASE);shop=Array.from({length:3},()=>k[(Math.random()*k.length)|0]);}
    function spawnEnemies(){enemies.length=0;const count=(floorN===1)?2:3, cols=[4,3,4,3];
      for(let i=0;i<count;i++){const hp=Math.floor((floorN===1)?80:90+floorN*8), atk=Math.floor((floorN===1)?10:10+floorN*3);
        enemies.push({name:'Enemy',team:'enemy',cell:{x:cols[i%cols.length],y:i%3},star:1,alive:true,maxhp:hp,hp,atk,spd:1.0,range:1,color:C.e,role:'melee',crit:0.05,critMult:2.0,armor:5+floorN,resist:3+((floorN/2)|0),dodge:0.02,lifesteal:0,cool:0,stepCool:0,lastPos:null,shield:0,shieldT:0});
      }
    }

    const fill=(x,y,w,h,c)=>{ctx.fillStyle=c;ctx.fillRect(x,y,w,h);};
    const text=(t,x,y,s=16,c=C.t)=>{ctx.fillStyle=c;ctx.font=`${s}px -apple-system,system-ui,sans-serif`;ctx.fillText(t,x,y);};
    const cellCenter=(x,y)=>({x:L.originX+x*L.cell+L.cell/2,y:L.originY+y*L.cell+L.cell/2});
    const pointInRect=(x,y,r)=>x>=r.x&&y>=r.y&&y<=r.y+r.h&&x<=r.x+r.w;

    const playersAlive=()=>roster.filter(u=>u.alive&&u.cell);
    const enemiesAlive=()=>enemies.filter(u=>u.alive);

    const isAdjCross=(a,b)=>!!a&&!!b&&(Math.abs(a.cell.x-b.cell.x)+Math.abs(a.cell.y-b.cell.y)===1);
    const inRange=(a,t)=>{if(!a||!t) return false;const dx=Math.abs(t.cell.x-a.cell.x),dy=Math.abs(t.cell.y-a.cell.y);return a.role==='melee'?(dx+dy)===1:(dx+dy)<=Math.max(1,a.range);};
    const occupiedAt=(x,y)=>playersAlive().some(u=>u.cell.x===x&&u.cell.y===y)||enemiesAlive().some(u=>u.cell.x===x&&u.cell.y===y);
    const key=(x,y)=>`${x},${y}`;

    function diagonalNudge(u,t,res){
      if(!t) return false;
      const dx=t.cell.x-u.cell.x, dy=t.cell.y-u.cell.y;
      if(Math.abs(dx)===1 && Math.abs(dy)===1){
        const tryStep=(nx,ny)=>{ if(nx<0||nx>=COLS||ny<0||ny>=ROWS) return false;
          if(occupiedAt(nx,ny) && !(nx===u.cell.x && ny===u.cell.y)) return false;
          if(u.lastPos && nx===u.lastPos.x && ny===u.lastPos.y) return false;
          u.lastPos={x:u.cell.x,y:u.cell.y}; u.cell.x=nx; u.cell.y=ny; u.stepCool=.14; res.add(key(nx,ny)); return true; };
        if(tryStep(u.cell.x+Math.sign(dx), u.cell.y)) return true;
        if(tryStep(u.cell.x, u.cell.y+Math.sign(dy))) return true;
      }
      return false;
    }

    function nextStepBFS(u,target,res){
      if(!target) return null;
      const st={x:u.cell.x,y:u.cell.y},tx=target.cell.x,ty=target.cell.y;
      const goals=[],adj=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of adj){const gx=tx+dx,gy=ty+dy;
        if(gx<0||gx>=COLS||gy<0||gy>=ROWS) continue;
        if(!occupiedAt(gx,gy)||(gx===st.x&&gy===st.y)) goals.push({x:gx,y:gy});
      }
      if(!goals.length) return null;
      const dq=[st],came=new Map();came.set(key(st.x,st.y),null);
      function valid(nx,ny){
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) return false;
        if(occupiedAt(nx,ny)&&!(nx===st.x&&ny===st.y)) return false;
        if(res.has(key(nx,ny))&&!(nx===st.x&&ny===st.y)) return false;
        if(u.lastPos&&nx===u.lastPos.x&&ny===u.lastPos.y) return false;
        return true;
      }
      while(dq.length){
        const cur=dq.shift();
        if(goals.some(g=>g.x===cur.x&&g.y===cur.y)){
          let path=[cur], k=key(cur.x,cur.y);
          while(came.get(k)){ const p=came.get(k); path.push(p); k=key(p.x,p.y); }
          path.reverse(); return path[1]||null;
        }
        for(const [dx,dy] of adj){
          const nx=cur.x+dx, ny=cur.y+dy, nk=key(nx,ny);
          if(came.has(nk)) continue;
          if(!valid(nx,ny)) continue;
          came.set(nk,cur); dq.push({x:nx,y:ny});
        }
      }
      return null;
    }

    function tryStepToward(u,t,res){
      if(!t||u.role!=='melee'||isAdjCross(u,t)||u.stepCool>0) return false;
      if(diagonalNudge(u,t,res)) return true;
      const step=nextStepBFS(u,t,res);
      if(step){u.lastPos={x:u.cell.x,y:u.cell.y};u.cell.x=step.x;u.cell.y=step.y;u.stepCool=.18;res.add(key(step.x,step.y));return true;}
      u.stepCool=.1;return false;
    }

    const rnd=p=>Math.random()<p, phys=(d,a)=>d*(100/(100+Math.max(0,a))), mag=(d,r)=>d*(100/(100+Math.max(0,r)));
    const dmgTexts=[]; const pushDmg=(cell,txt,col)=>{const c=cellCenter(cell.x,cell.y);dmgTexts.push({x:c.x,y:c.y,t:0,text:txt,color:col});};
    function updDmg(dt){for(const d of dmgTexts) d.t+=dt; for(let i=dmgTexts.length-1;i>=0;i--) if(dmgTexts[i].t>.6) dmgTexts.splice(i,1);}
    function drawDmg(){for(const d of dmgTexts){const a=Math.max(0,1-d.t/.6),lift=d.t*24;ctx.globalAlpha=a;ctx.fillStyle=d.color;ctx.font='14px -apple-system,system-ui,sans-serif';ctx.fillText(d.text,d.x-10,d.y-10-lift);ctx.globalAlpha=1;}}
    function shieldAbsorb(t,d){if(t.shield>0){const use=Math.min(t.shield,d);t.shield-=use;d-=use;if(t.shield<=0) t.shieldT=0;}return Math.max(0,d);}

    const hitSparks=[], healSparks=[], slashes=[], projectiles=[];
    function resolveHit(a,t,base,type='physical'){
      if(!a||!t||!t.alive) return;
      let dr=0;if(a.name==='Brawler'&&a.star>=2){const near=(a.team==='player'?enemiesAlive():playersAlive());if(near.some(e=>Math.abs(e.cell.x-a.cell.x)+Math.abs(e.cell.y-a.cell.y)===1)) dr=.20;}
      if(rnd(t.dodge||0)){pushDmg(t.cell,'MISS',COL.miss);return;}
      let dmg=base;const crit=rnd(a.crit||0);if(crit) dmg*=(a.critMult||2.0);
      dmg=(type==='physical')?phys(dmg,t.armor||0):mag(dmg,t.resist||0);
      dmg=Math.max(1,Math.round(dmg*(1-dr)));dmg=shieldAbsorb(t,dmg);
      t.hp-=dmg;const col=(type==='physical')?(crit?COL.physCrit:COL.phys):(crit?COL.magicCrit:COL.magic);
      pushDmg(t.cell,(crit?'â˜…':'')+dmg,col);if(t.hp<=0) t.alive=false;
      const ls=a.lifesteal||0;if(ls>0&&a.alive&&dmg>0){const heal=Math.max(1,Math.round(dmg*ls));a.hp=Math.min(a.maxhp,a.hp+heal);const ac=cellCenter(a.cell.x,a.cell.y);healSparks.push({x:ac.x,y:ac.y,t:0,txt:`+${heal}`});}
    }

    const PROJ_SPEED=420,HIT_RADIUS=10;
    function spawnProjectile({shooter,target,amt,type,dmgType='physical'}){
      if(!target||!target.alive||!target.cell) return;
      const s=cellCenter(shooter.cell.x,shooter.cell.y);
      projectiles.push({x:s.x,y:s.y,shooterRef:shooter,targetRef:target,amt,speed:PROJ_SPEED,alive:true,ttl:2.0,type,dmgType});
    }
    function updateProjectiles(dt){
      for(const p of projectiles){
        if(!p.alive) continue; p.ttl-=dt;
        const t=p.targetRef;
        if(p.ttl<=0||!t||!t.alive||!t.cell){ p.alive=false; continue; }
        const tc=cellCenter(t.cell.x,t.cell.y), dx=tc.x-p.x, dy=tc.y-p.y;
        const dist=Math.hypot(dx,dy);
        if(!isFinite(dist) || dist<=HIT_RADIUS || dist===0){
          p.x=tc.x;p.y=tc.y;
          if(p.type==='dmg'){ resolveHit(p.shooterRef,t,p.amt,p.dmgType); hitSparks.push({x:tc.x,y:tc.y,t:0}); }
          else { const before=t.hp; t.hp=Math.min(t.maxhp,t.hp+p.amt); healSparks.push({x:tc.x,y:tc.y,t:0,txt:`+${t.hp-before}`}); }
          p.alive=false; continue;
        }
        const step=p.speed*dt;
        const nx=p.x+(dx/dist)*step, ny=p.y+(dy/dist)*step;
        const adx=tc.x-nx, ady=tc.y-ny;
        const overshoot=(dx*adx+dy*ady)<=0;
        if(overshoot){
          p.x=tc.x;p.y=tc.y;
          if(p.type==='dmg'){ resolveHit(p.shooterRef,t,p.amt,p.dmgType); hitSparks.push({x:tc.x,y:tc.y,t:0}); }
          else { const before=t.hp; t.hp=Math.min(t.maxhp,t.hp+p.amt); healSparks.push({x:tc.x,y:tc.y,t:0,txt:`+${t.hp-before}`}); }
          p.alive=false; continue;
        }
        p.x=nx;p.y=ny;
      }
      for(let i=projectiles.length-1;i>=0;i--) if(!projectiles[i].alive) projectiles.splice(i,1);
    }

    function updateFX(dt){
      for(const h of hitSparks) h.t+=dt;
      for(let i=hitSparks.length-1;i>=0;i--) if(hitSparks[i].t>.2) hitSparks.splice(i,1);
      for(const h of healSparks) h.t+=dt;
      for(let i=healSparks.length-1;i>=0;i--) if(healSparks[i].t>.35) healSparks.splice(i,1);
      for(const sl of slashes) sl.t+=dt;
      for(let i=slashes.length-1;i>=0;i--) if(slashes[i].t>.18) slashes.splice(i,1);
      updDmg(dt);
    }

    function tryMerge(name,star){
      const copies=roster.filter(u=>u.name===name&&u.star===star);
      if(copies.length<3) return false;
      const keep=copies.find(u=>u.cell)||copies[0];
      const keepCell=keep.cell?{...keep.cell}:null;
      let removed=0;for(let i=roster.length-1;i>=0&&removed<3;i--){const u=roster[i];if(u.name===name&&u.star===star){roster.splice(i,1);removed++;}}
      const m=mkUnit(name,'player',keepCell,star+1);if(m.name==='Archer'&&m.star>=2)m.atk=Math.round(m.atk*1.10);
      roster.push(m);if(m.star<3) tryMerge(name,m.star);return true;
    }

    function frontlineTarget(attacker,targets){
      if(!targets.length) return null; let front;
      if(attacker.team==='enemy'){const mx=Math.max(...targets.map(t=>t.cell.x));front=targets.filter(t=>t.cell.x===mx);}
      else {const mn=Math.min(...targets.map(t=>t.cell.x));front=targets.filter(t=>t.cell.x===mn);}
      const sameRow=front.filter(t=>t.cell.y===attacker.cell.y);if(sameRow.length) front=sameRow;
      front.sort((a,b)=>(a.hp/a.maxhp)-(b.hp/b.maxhp));return front[0];
    }

    function tryAct(u,isEnemy=false){
      let acted=false;
      if(u.role==='healer'){
        const pool = isEnemy ? enemiesAlive() : playersAlive();
        const patient = pool.slice().sort((a,b)=>(a.hp/a.maxhp)-(b.hp/b.maxhp))[0];
        if(patient && patient.hp<patient.maxhp){ spawnProjectile({shooter:u,target:patient,amt:20,type:'heal'}); acted=true; }
        const foes = isEnemy ? playersAlive() : enemiesAlive();
        const t=frontlineTarget(u,foes);
        if(inRange(u,t)){ spawnProjectile({shooter:u,target:t,amt:Math.max(4,Math.floor(u.atk*0.5)),type:'dmg',dmgType:'magic'}); acted=true; }
      } else {
        const foes = isEnemy ? playersAlive() : enemiesAlive();
        const t=frontlineTarget(u,foes);
        if(u.role==='melee' ? isAdjCross(u,t) : inRange(u,t)){
          if(u.role==='melee'){ const a=cellCenter(u.cell.x,u.cell.y), b=cellCenter(t.cell.x,t.cell.y); slashes.push({sx:a.x,sy:a.y,ang:Math.atan2(b.y-a.y,b.x-a.x),t:0}); resolveHit(u,t,u.atk,'physical'); }
          else { spawnProjectile({shooter:u,target:t,amt:u.atk,type:'dmg',dmgType:'physical'}); }
          acted=true;
        }
      }
      return acted;
    }

    function endBattle(outcome){
      state='result'; result=outcome;
      projectiles.length=0; hitSparks.length=0; healSparks.length=0; slashes.length=0; dmgTexts.length=0;
    }

    function battleTick(dt){
      if(!playersAlive().length){ endBattle('lose'); return; }
      if(!enemiesAlive().length){ gold += 2 + Math.floor(floorN/2); endBattle('win'); return; }

      { const res=new Set();
        for(const u of playersAlive()){
          u.cool=Math.max(0,u.cool-dt); u.stepCool=Math.max(0,u.stepCool-dt);
          if(u.cool<=0){
            let acted = tryAct(u,false);
            if(!acted && u.role==='melee'){
              const tgt=frontlineTarget(u,enemiesAlive());
              tryStepToward(u,tgt,res);
              acted = tryAct(u,false);
            }
            u.cool = acted ? (1/u.spd) : 0.10;
          } else if(u.role==='melee'){
            const tgt=frontlineTarget(u,enemiesAlive()); tryStepToward(u,tgt,res);
          }
        }
      }

      if(!playersAlive().length){ endBattle('lose'); return; }
      if(!enemiesAlive().length){ gold += 2 + Math.floor(floorN/2); endBattle('win'); return; }

      { const res=new Set();
        for(const e of enemiesAlive()){
          e.cool=Math.max(0,e.cool-dt); e.stepCool=Math.max(0,e.stepCool-dt);
          if(e.cool<=0){
            let acted = tryAct(e,true);
            if(!acted && e.role==='melee'){
              const tgt=frontlineTarget(e,playersAlive());
              tryStepToward(e,tgt,res);
              acted = tryAct(e,true);
            }
            e.cool = acted ? (1/e.spd) : 0.10;
          } else if(e.role==='melee'){
            const tgt=frontlineTarget(e,playersAlive()); tryStepToward(e,tgt,res);
          }
        }
      }
    }

    const cellAtFloor=(px,py)=>({x:((px-L.originX)/L.cell)|0,y:((py-L.originY)/L.cell)|0});
    const cellAtRound=(px,py)=>({x:Math.round((px-L.originX)/L.cell),y:Math.round((py-L.originY)/L.cell)});
    const unitAtCell=(c,r)=>roster.find(u=>u.cell&&u.cell.x===c&&u.cell.y===r&&u.alive)||null;
    const inLeftCols=(c,r)=> (c>=0&&c<=1&&r>=0&&r<ROWS);

    function placeExactAt(c,r){
      if(!inLeftCols(c,r)){toast('Place in the left two columns');return false;}
      if(unitAtCell(c,r)){toast('Cell occupied');return false;}
      preview.cell={x:c,y:r};roster.push(preview);tryMerge(preview.name,preview.star||1);
      toast(`${preview._fromPickup?'Moved':'Placed'} ${preview.name} ${'â˜…'.repeat(preview.star||1)} @ ${c},${r}`);
      preview=null;state='shop';return true;
    }
    function clientToCanvas(e){const rect=canvas.getBoundingClientRect();const t=e.changedTouches?.[0]||e.touches?.[0]||e;return {x:t.clientX-rect.left,y:t.clientY-rect.top};}

    let toggleLock=false,toggleTimer=null;
    function safeToggleShop(){if(toggleLock) return;toggleLock=true;SHOW_SHOP=!SHOW_SHOP;layout();toast(SHOW_SHOP?'Shop shown':'Shop hidden');clearTimeout(toggleTimer);toggleTimer=setTimeout(()=>{toggleLock=false;},400);}

    function safeStart(){
      if(!roster.some(u=>u.alive&&u.cell)){ toast('Place at least one unit first'); return; }
      spawnEnemies(); state='battle';
      playersAlive().forEach(u=>u.cool=0); enemiesAlive().forEach(e=>e.cool=0);
      toast('Battle!');
    }

    function onPointerDown(e){if(isPortrait()){e.preventDefault();return;}e.preventDefault();}
    function onPointerUp(e){
      if(isPortrait()){e.preventDefault();return;}
      const p=clientToCanvas(e);
      if(pointInRect(p.x,p.y,shopBtn)){safeToggleShop();e.preventDefault();e.stopPropagation();return;}

      if(state==='result'){
        if(result==='win'){floorN++;toast(`Floor ${floorN}`);} else {roster.length=0;enemies.length=0;gold=6;floorN=1;toast('Run reset');}
        result=null;state='shop';SHOW_SHOP=true;refillShop();layout();e.preventDefault();return;
      }

      if(state==='placing'&&preview){
        if(pointInRect(p.x,p.y,sellArea)){const amt=refundFor(preview);gold+=amt;preview=null;state='shop';toast(`Sold for ${amt}g`);e.preventDefault();return;}
        let c=cellAtRound(p.x,p.y).x,r=cellAtRound(p.x,p.y).y;c=Math.max(0,Math.min(COLS-1,c));r=Math.max(0,Math.min(ROWS-1,r));placeExactAt(c,r);e.preventDefault();return;
      }

      if(state==='shop'&&!preview){
        const cc=cellAtFloor(p.x,p.y);
        if(inLeftCols(cc.x,cc.y)){
          const u=unitAtCell(cc.x,cc.y);
          if(u){const idx=roster.indexOf(u);if(idx>=0) roster.splice(idx,1);preview=u;preview._fromPickup=true;preview._fromCell={x:cc.x,y:cc.y};state='placing';toast(`Picked up ${u.name} ${'â˜…'.repeat(u.star||1)}`);e.preventDefault();return;}
        }
        if(SHOW_SHOP && pointInRect(p.x,p.y,rerollArea)){if(gold>=REROLL_COST){gold-=REROLL_COST;refillShop();toast('Shop rerolled');}else toast('Not enough gold');e.preventDefault();return;}
        if(SHOW_SHOP){for(const r of buyAreas){if(pointInRect(p.x,p.y,r)&&gold>=BUY_COST){gold-=BUY_COST;preview=mkUnit(shop[r.i],'player',null,1);preview._fromPickup=false;preview._fromCell=null;state='placing';toast(`Bought ${shop[r.i]} â˜…`);e.preventDefault();return;}}}
        if(pointInRect(p.x,p.y,startArea)){ safeStart(); e.preventDefault(); return; }
      }
    }
    canvas.addEventListener('pointerdown',onPointerDown,{passive:false});
    canvas.addEventListener('pointerup',onPointerUp,{passive:false});

    function draw(dt){
      const Cfg={ bg:'#121214', grid:'#282828' };
      const portrait=isPortrait();
      ctx.fillStyle=Cfg.bg;ctx.fillRect(0,0,L.vw,L.vh);
      ctx.strokeStyle=Cfg.grid;for(let c=0;c<COLS;c++)for(let r=0;r<ROWS;r++)ctx.strokeRect(L.originX+c*L.cell,L.originY+r*L.cell,L.cell,L.cell);

      // version tag
      ctx.fillStyle='#7bd7ff'; ctx.font='12px -apple-system,system-ui,sans-serif';
      ctx.fillText('Build '+BUILD, L.originX+L.gridW-72, L.originY-8);

      const hint=state==='result'?'Tap anywhere to continueâ€¦':state==='placing'?'Drag to place or onto SELL to sell.':'Tap a unit to move it. Use SHOP to toggle.';
      text(hint,L.originX,Math.max(16,L.originY-6),12,C.hint);

      function drawUnit(u){if(!u.alive||!u.cell)return;const gx=L.originX+u.cell.x*L.cell,gy=L.originY+u.cell.y*L.cell;ctx.fillStyle=u.color;ctx.fillRect(gx+8,gy+8,L.cell-16,L.cell-16);const w=L.cell-20,hpw=Math.max(0,Math.floor(w*Math.max(0,u.hp)/u.maxhp));ctx.fillStyle='#333';ctx.fillRect(gx+10,gy+L.cell-28,w,6);ctx.fillStyle=C.hp;ctx.fillRect(gx+10,gy+L.cell-28,hpw,6);}
      roster.forEach(drawUnit);enemies.forEach(drawUnit);

      for(const s of slashes){const a=Math.max(0,1-s.t/.18);ctx.save();ctx.globalAlpha=a;ctx.translate(s.sx,s.sy);ctx.rotate(s.ang);ctx.strokeStyle='#ffffff';ctx.lineWidth=6;ctx.beginPath();ctx.arc(0,0,18+s.t*14,-0.6,0.2);ctx.stroke();ctx.strokeStyle='#ffe9a6';ctx.lineWidth=3;ctx.beginPath();ctx.arc(0,0,18+s.t*14,-0.6,0.2);ctx.stroke();ctx.restore();}
      for(const p of projectiles){ctx.fillStyle='#ffffff';ctx.beginPath();if(p.type==='heal'){ctx.ellipse(p.x,p.y,8,8,0,0,Math.PI*2);ctx.fill();ctx.fillStyle=COL.heal;ctx.beginPath();ctx.ellipse(p.x,p.y,6,6,0,0,Math.PI*2);ctx.fill();}else{ctx.ellipse(p.x,p.y,7,3,0,0,Math.PI*2);ctx.fill();ctx.fillStyle='#ffe9a6';ctx.beginPath();ctx.ellipse(p.x,p.y,5,2,0,0,Math.PI*2);ctx.fill();}}
      drawDmg();

      const y0=L.yUI;fill(0,y0,L.vw,currentUIH(),C.ui);
      sellArea={x=L.vw-168,y:y0+(SHOW_SHOP?60:8),w:160,h:72};fill(sellArea.x,sellArea.y,sellArea.w,sellArea.h,'#3a2222');text(`SELL (${preview?refundFor(preview):2}g)`,sellArea.x+22,sellArea.y+44,20,'#ff9a9a');
      if(SHOW_SHOP){rerollArea={x:L.vw-336,y:y0+8,w:160,h:52};fill(rerollArea.x,rerollArea.y,rerollArea.w,rerollArea.h,'#2d2d2d');text(`REROLL (${REROLL_COST}g)`,rerollArea.x+12,rerollArea.y+32,18,'#ffd45a');} else rerollArea={x:0,y:0,w:0,h:0};
      startArea={x:L.vw-168,y:y0+8,w:160,h:52};fill(startArea.x,startArea.y,startArea.w,startArea.h,C.start);text('START',startArea.x+48,startArea.y+32,20,'#fff');
      if(SHOW_SHOP) text(`GOLD: ${gold}g`,8,y0+52,18,'#ffd45a');

      if(SHOW_SHOP){
        buyAreas.length=0;const cardW=Math.min(200,L.vw/3-12),cardH=126;
        for(let i=0;i<3;i++){const x=8+i*(cardW+6),y=y0+60,w=cardW,h=cardH;fill(x,y,w,h,'#3c3c3c');const name=shop[i],b=BASE[name];
          text(`${name} â˜…`,x+8,y+18,16,'#fff');ctx.fillStyle='#eaeaea';ctx.font='12px -apple-system,system-ui,sans-serif';
          const lines=[`HP: ${b.hp}   ATK: ${b.atk}`,`CRIT: ${Math.round(b.crit*100)}%   ARM: ${b.armor}`,`RES: ${b.resist}   SPD: ${b.spd}`];
          let ly=y+36;for(const ln of lines){ctx.fillText(ln,x+8,ly);ly+=16;}
          fill(x+8,y+h-22,w-16,18,'#2a2a2a');text(`Buy ${BUY_COST} gold`,x+14,y+h-8,12,C.td);
          buyAreas.push({x,y,w,h,i});
        }
      } else buyAreas.length=0;

      fill(shopBtn.x,shopBtn.y,shopBtn.w,shopBtn.h,'#2d2d2d');text(SHOW_SHOP?'HIDE SHOP':'SHOW SHOP',shopBtn.x+14,shopBtn.y+34,18,'#ffd45a');

      if(isPortrait()){ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillRect(0,0,L.vw,L.vh);text('Rotate your device to landscape to play',(L.vw-320)/2,L.vh/2,18,'#eaeaea');}
    }

    function boot(){state='shop';SHOW_SHOP=true;refillShop(); ok();}
    boot();
    let last=performance.now(), dbgErr='';
    function loop(ts){
      const dt=Math.min(.05,(ts-last)/1000); last=ts;
      try{
        if(!isPortrait()){
          if(state==='battle'){ battleTick(dt); updateProjectiles(dt); updateFX(dt); }
          else { updateFX(dt); }
        }
        draw(dt);
      }catch(e){
        dbgErr = (e&&e.message?e.message:String(e));
        // show error overlay if something breaks after boot
        bootEl.style.display='flex'; bootEl.classList.add('err');
        bootEl.querySelector('.tag').textContent='Build '+BUILD;
        bootMsg.textContent=dbgErr;
      }
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
    // ====== END GAME CODE ======
  }catch(e){ fail(e); }
})();
</script>
</body>
</html>
