<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
<title>Auto Battler (Mobile) v62</title>
<style>
  html,body{margin:0;padding:0;background:#121214;height:100svh;overscroll-behavior:none;font-family:-apple-system,system-ui,sans-serif}
  #boot{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;color:#eaeaea;gap:10px}
  #boot .tag{font-size:12px;color:#7bd7ff}
  #boot.err{background:#1a0000}
  #boot.err .msg{max-width:90vw;color:#ffb8b8;white-space:pre-wrap;text-align:center}
  canvas{position:fixed;left:0;top:0;width:100vw;height:100svh;touch-action:manipulation;display:none}
  #toast{position:fixed;top:calc(10px + env(safe-area-inset-top,0px));left:50%;transform:translateX(-50%);
         padding:8px 12px;background:#222;color:#eee;border-radius:8px;font-size:14px;opacity:0;transition:opacity .12s;pointer-events:none}
  #toast.show{opacity:.96}
</style>
</head>
<body>
<div id="boot">
  <div class="tag">Build v62</div>
  <div>Loadingâ€¦</div>
  <div class="msg"></div>
</div>
<canvas id="c"></canvas>
<div id="toast"></div>

<script>
(function topLevel(){
  const BUILD="v62";
  const boot=document.getElementById('boot');
  const bootMsg=boot.querySelector('.msg');
  const ok=()=>{boot.style.display='none'; document.getElementById('c').style.display='block';};
  const fail=e=>{boot.classList.add('err'); bootMsg.textContent=(e&& (e.stack||e.message))?(e.stack||e.message):String(e);};

  try{
    // ---------- canvas & layout ----------
    const canvas=document.getElementById('c');
    const ctx=canvas.getContext('2d',{alpha:false});
    const toastEl=document.getElementById('toast'); let toastTimer=null;
    const toast=m=>{toastEl.textContent=m;toastEl.classList.add('show');clearTimeout(toastTimer);toastTimer=setTimeout(()=>toastEl.classList.remove('show'),1200);};

    function vv(){const v=visualViewport;const w=Math.min(innerWidth||1e9,document.documentElement.clientWidth||1e9,v?v.width:1e9);const h=Math.min(innerHeight||1e9,document.documentElement.clientHeight||1e9,v?v.height:1e9);return {w:Math.floor(w),h:Math.floor(h)}}
    const isPortrait=()=>vv().h>vv().w;
    let SHOW_SHOP=true; const UI_H_SHOP=196, UI_H_COMPACT=96;
    const currentUIH=()=>SHOW_SHOP?UI_H_SHOP:UI_H_COMPACT;

    function setCanvasSize(){const dpr=Math.max(1,devicePixelRatio||1);const {w,h}=vv();canvas.width=Math.floor(w*dpr);canvas.height=Math.floor(h*dpr);canvas.style.width=w+'px';canvas.style.height=h+'px';ctx.setTransform(dpr,0,0,dpr,0,0);}
    const COLS=5, ROWS=3;
    let L={cell:48,originX:0,originY:24,gridW:0,gridH:0,yUI:0,vw:0,vh:0};
    function layout(){const {w,h}=vv();const TOP_PAD=36,BTM_BUF=2;const targetUIH=currentUIH();const availH=Math.max(60,h-targetUIH-TOP_PAD-BTM_BUF);const cell=Math.max(14,Math.min(Math.floor(availH/ROWS),Math.floor(w/COLS)));const gridW=COLS*cell,gridH=ROWS*cell;let originY=Math.floor((h-targetUIH-gridH)/2);originY=Math.max(12,Math.min(originY,h-targetUIH-gridH-8));const originX=Math.floor((w-gridW)/2);let yUI=h-targetUIH-BTM_BUF;yUI=Math.max(originY+gridH+8,yUI);L={cell,originX,originY,gridW,gridH,yUI,vw:w,vh:h};}
    function resize(){setCanvasSize();layout();}
    addEventListener('resize',resize,{passive:true});addEventListener('orientationchange',resize,{passive:true});
    if(visualViewport){visualViewport.addEventListener('resize',resize,{passive:true});visualViewport.addEventListener('scroll',resize,{passive:true});}
    resize();

    // ---------- constants ----------
    const C={ bg:'#121214', grid:'#282828', ui:'#1e1e1e', hp:'#e42828', t:'#eaeaea', td:'#d8c878', start:'#7a50a0', hint:'#9ee',
              b:'#c8503c', a:'#50c85a', c:'#78b4dc', e:'#a0a0a0' };

    const BUY_COST=2, REROLL_COST=2;

    // ---------- units ----------
    const BASE={
      Brawler:{hp:120, atk:18, spd:1.0, range:1, color:C.b, role:'melee',  crit:0.10, critMult:2.0, armor:10, resist:5,  dodge:0.05, lifesteal:0.05},
      Archer: {hp:70,  atk:25, spd:0.8, range:5, color:C.a, role:'ranged', crit:0.20, critMult:2.0, armor:4,  resist:4,  dodge:0.10, lifesteal:0.00},
      Cleric: {hp:80,  atk:8,  spd:1.0, range:5, color:C.c, role:'healer', crit:0.10, critMult:2.0, armor:6,  resist:12, dodge:0.05, lifesteal:0.00},
    };
    const starMul=s=>s===1?1:s===2?1.4:1.8;
    const scaled=(b,s)=>({hp:Math.round(b.hp*starMul(s)),atk:Math.round(b.atk*starMul(s)),spd:b.spd,range:b.range,color:b.color,role:b.role,
      crit:b.crit+(s>=2&&b.role==='ranged'?0.10:0),critMult:2.0,armor:Math.round(b.armor*starMul(s)),resist:Math.round(b.resist*starMul(s)),dodge:b.dodge,lifesteal:b.lifesteal});
    function mkUnit(name,team,cell=null,star=1){const s=scaled(BASE[name],star);return {name,team,cell,star,alive:true,maxhp:s.hp,hp:s.hp,atk:s.atk,spd:s.spd,range:s.range,color:s.color,role:s.role,crit:s.crit,critMult:s.critMult,armor:s.armor,resist:s.resist,dodge:s.dodge,lifesteal:s.lifesteal,cool:0,stepCool:0,lastPos:null};}

    // ---------- state ----------
    let gold=6, floorN=1, state='shop', result=null;
    const roster=[], enemies=[];
    let shop=[], preview=null;
    const buyAreas=[]; let startArea={x:0,y:0,w:0,h:0}, rerollArea={x:0,y:0,w:0,h:0}, sellArea={x:0,y:0,w:0,h:0};
    let shopBtn={x:16,y:20,w:160,h:54};

    function refillShop(){const k=Object.keys(BASE);shop=Array.from({length:3},()=>k[(Math.random()*k.length)|0]);}
    function spawnEnemies(){enemies.length=0;const count=(floorN===1)?2:3, cols=[4,3,4,3];
      for(let i=0;i<count;i++){const hp=Math.floor((floorN===1)?80:90+floorN*8), atk=Math.floor((floorN===1)?10:10+floorN*3);
        enemies.push({name:'Enemy',team:'enemy',cell:{x:cols[i%cols.length],y:i%3},star:1,alive:true,maxhp:hp,hp,atk,spd:1.0,range:1,color:C.e,role:'melee',crit:0.05,critMult:2.0,armor:5+floorN,resist:3+((floorN/2)|0),dodge:0.02,lifesteal:0,cool:0,stepCool:0,lastPos:null});
      }
    }

    // ---------- helpers ----------
    const fill=(x,y,w,h,c)=>{ctx.fillStyle=c;ctx.fillRect(x,y,w,h);};
    const text=(t,x,y,s=16,c=C.t)=>{ctx.fillStyle=c;ctx.font=`${s}px -apple-system,system-ui,sans-serif`;ctx.fillText(t,x,y);};
    const cellCenter=(x,y)=>({x:L.originX+x*L.cell+L.cell/2,y:L.originY+y*L.cell+L.cell/2});
    const unitAtCell=(c,r)=>roster.find(u=>u.cell&&u.cell.x===c&&u.cell.y===r&&u.alive)||null;
    const playersAlive=()=>roster.filter(u=>u.alive&&u.cell);
    const enemiesAlive=()=>enemies.filter(u=>u.alive);
    const inLeftCols=(c,r)=> (c>=0&&c<=1&&r>=0&&r<ROWS);
    const pointInRect=(x,y,r)=>x>=r.x&&y>=r.y&&y<=r.y+r.h&&x<=r.x+r.w;
    const isAdjCross=(a,b)=>!!a&&!!b&&(Math.abs(a.cell.x-b.cell.x)+Math.abs(a.cell.y-b.cell.y)===1);
    const key=(x,y)=>`${x},${y}`;
    const occupiedAt=(x,y)=>playersAlive().concat(enemiesAlive()).some(u=>u.cell.x===x&&u.cell.y===y);

    function phys(d,a){return d*(100/(100+Math.max(0,a)));} function mag(d,r){return d*(100/(100+Math.max(0,r)));}

    // diagonal nudge into adjacency (horiz first)
    function diagonalNudge(u,t,res){
      if(!t) return false;
      const dx=t.cell.x-u.cell.x, dy=t.cell.y-u.cell.y;
      if(Math.abs(dx)===1 && Math.abs(dy)===1){
        const tryStep=(nx,ny)=>{ if(nx<0||nx>=COLS||ny<0||ny>=ROWS) return false;
          if(occupiedAt(nx,ny) && !(nx===u.cell.x && ny===u.cell.y)) return false;
          if(u.lastPos && nx===u.lastPos.x && ny===u.lastPos.y) return false;
          u.lastPos={x:u.cell.x,y:u.cell.y}; u.cell.x=nx; u.cell.y=ny; u.stepCool=.14; res.add(key(nx,ny)); return true; };
        if(tryStep(u.cell.x+Math.sign(dx), u.cell.y)) return true;
        if(tryStep(u.cell.x, u.cell.y+Math.sign(dy))) return true;
      }
      return false;
    }
    function nextStepBFS(u,target,res){
      if(!target) return null;
      const st={x:u.cell.x,y:u.cell.y},tx=target.cell.x,ty=target.cell.y;
      const goals=[],adj=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of adj){const gx=tx+dx,gy=ty+dy;if(gx<0||gx>=COLS||gy<0||gy>=ROWS) continue;
        if(!occupiedAt(gx,gy)||(gx===st.x&&gy===st.y)) goals.push({x:gx,y:gy});}
      if(!goals.length) return null;
      const dq=[st],came=new Map();came.set(key(st.x,st.y),null);
      function valid(nx,ny){
        if(nx<0||nx>=COLS||ny<0||ny>=ROWS) return false;
        if(occupiedAt(nx,ny)&&!(nx===st.x&&ny===st.y)) return false;
        if(res.has(key(nx,ny))&&!(nx===st.x&&ny===st.y)) return false;
        if(u.lastPos&&nx===u.lastPos.x&&ny===u.lastPos.y) return false;
        return true;
      }
      while(dq.length){
        const cur=dq.shift();
        if(goals.some(g=>g.x===cur.x&&g.y===cur.y)){
          let path=[cur], k=key(cur.x,cur.y);
          while(came.get(k)){ const p=came.get(k); path.push(p); k=key(p.x,p.y); }
          path.reverse(); return path[1]||null;
        }
        for(const [dx,dy] of adj){
          const nx=cur.x+dx, ny=cur.y+dy, nk=key(nx,ny);
          if(came.has(nk)) continue;
          if(!valid(nx,ny)) continue;
          came.set(nk,cur); dq.push({x:nx,y:ny});
        }
      }
      return null;
    }
    function frontlineTarget(attacker,targets){
      if(!targets.length) return null; let front;
      if(attacker.team==='enemy'){const mx=Math.max(...targets.map(t=>t.cell.x));front=targets.filter(t=>t.cell.x===mx);}
      else {const mn=Math.min(...targets.map(t=>t.cell.x));front=targets.filter(t=>t.cell.x===mn);}
      const sameRow=front.filter(t=>t.cell.y===attacker.cell.y);if(sameRow.length) front=sameRow;
      front.sort((a,b)=>(a.hp/a.maxhp)-(b.hp/b.maxhp));return front[0];
    }
    function tryStepToward(u,t,res){
      if(!t||u.role!=='melee'||isAdjCross(u,t)||u.stepCool>0) return false;
      if(diagonalNudge(u,t,res)) return true;
      const step=nextStepBFS(u,t,res);
      if(step){u.lastPos={x:u.cell.x,y:u.cell.y};u.cell.x=step.x;u.cell.y=step.y;u.stepCool=.18;res.add(key(step.x,step.y));return true;}
      u.stepCool=.1;return false;
    }

    // instant attack/heal (no projectiles)
    function act(u,isEnemy){
      const foes=isEnemy?playersAlive():enemiesAlive();
      const t=frontlineTarget(u,foes);
      if(!t) return false;
      if(u.role==='melee'){
        if(isAdjCross(u,t)){ // swing
          let dmg=phys(u.atk,t.armor); dmg=Math.max(1,Math.round(dmg)); t.hp-=dmg; if(t.hp<=0) t.alive=false; return true;
        }
        return false;
      }else if(u.role==='ranged'){
        // hitscan
        let dmg=phys(u.atk,t.armor); t.hp-=Math.max(1,Math.round(dmg)); if(t.hp<=0) t.alive=false; return true;
      }else{ // healer: heal lowest ally; also light ping to enemy
        const pool=isEnemy?enemiesAlive():playersAlive();
        pool.sort((a,b)=>(a.hp/a.maxhp)-(b.hp/b.maxhp));
        const p=pool[0];
        if(p && p.hp<p.maxhp){ p.hp=Math.min(p.maxhp,p.hp+20); return true; }
        let dmg=Math.max(1,Math.round(mag(Math.max(4,Math.floor(u.atk*0.5)), t.resist)));
        t.hp-=dmg; if(t.hp<=0) t.alive=false; return true;
      }
    }

    // ---------- economy & merge ----------
    const refundFor=u=>(!u)?BUY_COST:(u.star===1?2:u.star===2?6:18);
    function tryMerge(name,star){
      const copies=roster.filter(u=>u.name===name&&u.star===star);
      if(copies.length<3) return false;
      const keep=copies.find(u=>u.cell)||copies[0];
      const keepCell=keep.cell?{...keep.cell}:null;
      let removed=0;for(let i=roster.length-1;i>=0&&removed<3;i--){const u=roster[i];if(u.name===name&&u.star===star){roster.splice(i,1);removed++;}}
      const m=mkUnit(name,'player',keepCell,star+1);if(m.name==='Archer'&&m.star>=2)m.atk=Math.round(m.atk*1.10);
      roster.push(m);if(m.star<3) tryMerge(name,m.star);return true;
    }

    // ---------- battle tick ----------
    function battleTick(dt){
      if(!playersAlive().length){ state='result'; result='lose'; return; }
      if(!enemiesAlive().length){ state='result'; result='win'; gold += 2 + Math.floor(floorN/2); return; }

      { const res=new Set();
        for(const u of playersAlive()){
          u.cool=Math.max(0,u.cool-dt); u.stepCool=Math.max(0,u.stepCool-dt);
          if(u.cool<=0){
            let acted=act(u,false);
            if(!acted && u.role==='melee'){ const tgt=frontlineTarget(u,enemiesAlive()); tryStepToward(u,tgt,res); acted=act(u,false); }
            u.cool = acted ? (1/u.spd) : 0.12;
          }else if(u.role==='melee'){ const tgt=frontlineTarget(u,enemiesAlive()); tryStepToward(u,tgt,res); }
        }
      }
      if(!playersAlive().length){ state='result'; result='lose'; return; }
      if(!enemiesAlive().length){ state='result'; result='win'; gold += 2 + Math.floor(floorN/2); return; }

      { const res=new Set();
        for(const e of enemiesAlive()){
          e.cool=Math.max(0,e.cool-dt); e.stepCool=Math.max(0,e.stepCool-dt);
          if(e.cool<=0){
            let acted=act(e,true);
            if(!acted && e.role==='melee'){ const tgt=frontlineTarget(e,playersAlive()); tryStepToward(e,tgt,res); acted=act(e,true); }
            e.cool = acted ? (1/e.spd) : 0.12;
          }else if(e.role==='melee'){ const tgt=frontlineTarget(e,playersAlive()); tryStepToward(e,tgt,res); }
        }
      }
    }

    // ---------- input ----------
    function clientToCanvas(e){const rect=canvas.getBoundingClientRect();const t=e.changedTouches?e.changedTouches[0]:e;return {x:t.clientX-rect.left,y:t.clientY-rect.top};}
    const cellAtFloor=(px,py)=>({x:((px-L.originX)/L.cell)|0,y:((py-L.originY)/L.cell)|0});
    const cellAtRound=(px,py)=>({x:Math.round((px-L.originX)/L.cell),y:Math.round((py-L.originY)/L.cell)});
    function placeExactAt(c,r){
      if(!inLeftCols(c,r)){toast('Place in the left two columns');return false;}
      if(unitAtCell(c,r)){toast('Cell occupied');return false;}
      preview.cell={x:c,y:r};roster.push(preview);tryMerge(preview.name,preview.star||1);
      toast(`${preview._fromPickup?'Moved':'Placed'} ${preview.name}`); preview=null; state='shop'; return true;
    }
    function safeToggleShop(){SHOW_SHOP=!SHOW_SHOP;layout();toast(SHOW_SHOP?'Shop shown':'Shop hidden');}
    function safeStart(){ if(!roster.some(u=>u.alive&&u.cell)){toast('Place at least one unit'); return;} spawnEnemies(); playersAlive().forEach(u=>u.cool=0); enemiesAlive().forEach(e=>e.cool=0); state='battle'; toast('Battle!'); }

    let startAreaMemo={x:0,y:0,w:0,h:0};
    function onPointerUp(e){
      if(isPortrait()){e.preventDefault();return;}
      const p=clientToCanvas(e);
      // shop toggle (top-left)
      if(pointInRect(p.x,p.y,{x:16,y:20,w:160,h:54})){ safeToggleShop(); e.preventDefault(); return; }

      if(state==='result'){
        if(result==='win'){ floorN++; toast(`Floor ${floorN}`); } else { roster.length=0; enemies.length=0; gold=6; floorN=1; toast('Run reset'); }
        result=null; state='shop'; SHOW_SHOP=true; refillShop(); layout(); e.preventDefault(); return;
      }

      if(state==='placing'&&preview){
        if(pointInRect(p.x,p.y,sellArea)){const amt=refundFor(preview); gold+=amt; preview=null; state='shop'; toast(`Sold for ${amt}g`); e.preventDefault(); return;}
        let c=cellAtRound(p.x,p.y).x, r=cellAtRound(p.x,p.y).y; c=Math.max(0,Math.min(COLS-1,c)); r=Math.max(0,Math.min(ROWS-1,r));
        placeExactAt(c,r); e.preventDefault(); return;
      }

      if(state==='shop'&&!preview){
        const cc=cellAtFloor(p.x,p.y);
        if(inLeftCols(cc.x,cc.y)){
          const u=unitAtCell(cc.x,cc.y);
          if(u){ const idx=roster.indexOf(u); if(idx>=0) roster.splice(idx,1); preview=u; preview._fromPickup=true; state='placing'; toast(`Picked up ${u.name}`); e.preventDefault(); return;}
        }
        if(SHOW_SHOP && pointInRect(p.x,p.y,rerollArea)){ if(gold>=REROLL_COST){gold-=REROLL_COST;refillShop();toast('Rerolled');} else toast('Not enough gold'); e.preventDefault(); return;}
        if(SHOW_SHOP){ for(const r of buyAreas){ if(pointInRect(p.x,p.y,r)&&gold>=BUY_COST){ gold-=BUY_COST; preview=mkUnit(shop[r.i],'player',null,1); preview._fromPickup=false; state='placing'; toast(`Bought ${shop[r.i]}`); e.preventDefault(); return; } } }
        if(pointInRect(p.x,p.y,startAreaMemo)){ safeStart(); e.preventDefault(); return; }
      }
    }
    canvas.addEventListener('pointerup',onPointerUp,{passive:false});
    canvas.addEventListener('pointerdown',e=>{if(isPortrait()){e.preventDefault();}},{passive:false});

    // ---------- render ----------
    const buyAreas=[]; let rerollArea={x:0,y:0,w:0,h:0}, sellArea={x:0,y:0,w:0,h:0};
    function draw(){
      ctx.fillStyle=C.bg; ctx.fillRect(0,0,L.vw,L.vh);
      // grid
      ctx.strokeStyle=C.grid; for(let c=0;c<COLS;c++) for(let r=0;r<ROWS;r++) ctx.strokeRect(L.originX+c*L.cell,L.originY+r*L.cell,L.cell,L.cell);
      // version
      ctx.fillStyle='#7bd7ff'; ctx.font='12px -apple-system,system-ui'; ctx.fillText('Build '+BUILD, L.originX+L.gridW-72, L.originY-8);
      // hint
      const hint=state==='result'?'Tap anywhere to continueâ€¦':state==='placing'?'Tap to place or SELL.':'Tap a unit to move it. Use SHOP to toggle.';
      text(hint,L.originX,Math.max(16,L.originY-6),12,'#9ee');

      // units
      function drawUnit(u){ if(!u.alive||!u.cell) return; const gx=L.originX+u.cell.x*L.cell, gy=L.originY+u.cell.y*L.cell;
        ctx.fillStyle=u.color; ctx.fillRect(gx+8,gy+8,L.cell-16,L.cell-16);
        const w=L.cell-20, hpw=Math.max(0,Math.floor(w*Math.max(0,u.hp)/u.maxhp));
        ctx.fillStyle='#333'; ctx.fillRect(gx+10,gy+L.cell-28,w,6);
        ctx.fillStyle=C.hp; ctx.fillRect(gx+10,gy+L.cell-28,hpw,6);
      }
      roster.forEach(drawUnit); enemies.forEach(drawUnit);

      // UI panel
      const y0=L.yUI; fill(0,y0,L.vw,currentUIH(),C.ui);
      // SELL
      sellArea={x:L.vw-168,y:y0+(SHOW_SHOP?60:8),w:160,h:72}; fill(sellArea.x,sellArea.y,sellArea.w,sellArea.h,'#3a2222'); text(`SELL (${preview?refundFor(preview):2}g)`,sellArea.x+22,sellArea.y+44,20,'#ff9a9a');
      // START
      startAreaMemo={x:L.vw-168,y:y0+8,w:160,h:52}; fill(startAreaMemo.x,startAreaMemo.y,startAreaMemo.w,startAreaMemo.h,'#7a50a0'); text('START',startAreaMemo.x+48,startAreaMemo.y+32,20,'#fff');
      // REROLL
      if(SHOW_SHOP){ rerollArea={x:L.vw-336,y:y0+8,w:160,h:52}; fill(rerollArea.x,rerollArea.y,rerollArea.w,rerollArea.h,'#2d2d2d'); text(`REROLL (${REROLL_COST}g)`,rerollArea.x+12,rerollArea.y+32,18,'#ffd45a'); } else rerollArea={x:0,y:0,w:0,h:0};
      if(SHOW_SHOP) text(`GOLD: ${gold}g`,8,y0+52,18,'#ffd45a');

      // shop cards
      buyAreas.length=0;
      if(SHOW_SHOP){
        const cardW=Math.min(200,L.vw/3-12), cardH=126;
        for(let i=0;i<3;i++){
          const x=8+i*(cardW+6), y=y0+60, w=cardW, h=cardH; fill(x,y,w,h,'#3c3c3c');
          const name=shop[i], b=BASE[name]; text(`${name} â˜…`,x+8,y+18,16,'#fff');
          ctx.fillStyle='#eaeaea'; ctx.font='12px -apple-system,system-ui';
          ctx.fillText(`HP: ${b.hp}   ATK: ${b.atk}`,x+8,y+36);
          ctx.fillText(`CRIT: ${Math.round(b.crit*100)}%   ARM: ${b.armor}`,x+8,y+52);
          ctx.fillText(`RES: ${b.resist}   SPD: ${b.spd}`,x+8,y+68);
          fill(x+8,y+h-22,w-16,18,'#2a2a2a'); text(`Buy ${BUY_COST} gold`,x+14,y+h-8,12,C.td);
          buyAreas.push({x,y,w,h,i});
        }
      }
      // top-left toggle
      fill(16,20,160,54,'#2d2d2d'); text(SHOW_SHOP?'HIDE SHOP':'SHOW SHOP',30,54,18,'#ffd45a');

      // debug mini box
      const dbgX=L.vw-200, dbgY=8;
      ctx.fillStyle='rgba(0,0,0,0.55)'; ctx.fillRect(dbgX,dbgY,190,54);
      ctx.fillStyle='#9ee'; ctx.font='12px -apple-system,system-ui';
      ctx.fillText(`state: ${state}`, dbgX+8, dbgY+16);
      ctx.fillText(`players: ${playersAlive().length}  enemies: ${enemiesAlive().length}`, dbgX+8, dbgY+34);
    }

    // ---------- boot & loop ----------
    function bootGame(){ state='shop'; SHOW_SHOP=true; refillShop(); ok(); }
    bootGame();
    let last=performance.now();
    function loop(ts){ const dt=Math.min(.05,(ts-last)/1000); last=ts;
      if(!isPortrait()){
        if(state==='battle') battleTick(dt);
      }
      draw(); requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

  }catch(e){ fail(e); }
})();
</script>
</body>
</html>
