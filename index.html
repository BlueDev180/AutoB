<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Bonechain ‚Äì Roguelike Block Summoner (v4.0)</title>
<style>
:root{
  color-scheme:dark;
  --bg:#0f0f11; --ui:#18181b; --grid:#202024; --hi:#ffd45a;
  --safeB: env(safe-area-inset-bottom,0px);
}
*{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
html,body{margin:0;background:var(--bg);font-family:-apple-system,system-ui,Segoe UI,Roboto;color:#eee;min-height:100dvh;overflow-x:hidden}

header,footer{
  background:var(--ui); color:#eaeaea; display:flex; align-items:center; gap:12px;
  padding:10px 14px; position:relative;
}
header{justify-content:space-between}
.build{color:#7bd7ff;font-size:12px}
.hud{display:flex;gap:10px;flex-wrap:wrap}
.hud .chip{background:#24242c;border:1px solid #32323a;border-radius:10px;padding:4px 10px;font-size:12px}
.btn{background:#2a2a31;color:#fff;border:1px solid #3b3b44;border-radius:8px;padding:8px 12px}

main{display:flex;justify-content:center;padding:8px 10px}
#field{
  width:80vw; height:auto; aspect-ratio:9/16;
  max-height:65dvh; background:#121216; border:1px solid #2a2a31; border-radius:12px;
  touch-action:none;
}

/* synergy bar */
#synergies{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:6px 10px;background:#141419;border-top:1px solid #262632;border-bottom:1px solid #262632}
.sy{display:flex;align-items:center;gap:6px;background:#1a1a22;border:1px solid #2c2c35;border-radius:10px;padding:4px 8px;font-size:12px}
.sy level{display:inline-block;background:#33384a;border-radius:6px;padding:2px 6px;margin-left:4px;color:#cde1ff}

/* bottom bar */
footer{flex-direction:column; align-items:center; padding:10px 12px;gap:10px;padding-bottom:calc(10px + var(--safeB))}
.legend{display:flex; gap:8px; flex-wrap:wrap}
.b{display:inline-block; padding:4px 8px; border-radius:8px; font-size:12px}
.b-SK{background:#3a2727}
.b-AR{background:#243a27}
.b-WR{background:#2b2740}
.b-DB{background:#3a2b27}
.rate{font-size:12px;opacity:.8}

.bar{
  display:grid; grid-template-columns: repeat(6, 1fr); /* 2 rows of 6 */
  gap:8px; width:92vw; max-width:520px;
}
.block{
  background:#23232a; border:2px solid #35353f; border-radius:12px; padding:12px 0;
  text-align:center; font-weight:800; color:#fff; user-select:none;
  box-shadow: inset 0 0 0 2px #0002;
  transform: translateY(0); opacity:1;
  transition: transform .22s ease-out, opacity .22s ease-out;
}
.block.spawn{ transform: translateY(12px); opacity:0; pointer-events:none; }
.block.spawn.ready{ transform: translateY(0); opacity:1; pointer-events:auto; }
.block.preview{ outline:3px dashed #fff9 }

/* modal */
.modalWrap{position:fixed;inset:0;background:#0009;display:none;align-items:center;justify-content:center;z-index:40}
.modal{background:#17171d;border:1px solid #2c2c35;border-radius:14px;padding:14px;max-width:560px;width:92vw;box-shadow:0 20px 60px #000c}
.modal h2{margin:0 0 8px 0;font-size:18px}
.choiceList{display:grid;gap:10px}
.choice{background:#1d1d24;border:1px solid #2e2e38;border-radius:12px;padding:10px;display:flex;justify-content:space-between;align-items:center}
.choice .title{font-weight:700}
.choice .desc{font-size:12px;opacity:.85;margin-top:4px}
.choice .take{background:#2a2a31;border:1px solid #3b3b44;border-radius:8px;padding:8px 10px}
.modal .row{display:flex;justify-content:space-between;align-items:center;margin-top:10px}

/* tutorial tip */
.tip{position:fixed;left:50%;transform:translateX(-50%);bottom:calc(140px + var(--safeB));
  background:#141420;border:1px solid #2a2a34;border-radius:10px;padding:8px 12px;font-size:13px;color:#d7d7e4;z-index:35}
.tip b{color:var(--hi)}

/* portrait gate (if you later force portrait only) */
/* #rotateGate{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000c;color:#fff;font-weight:700;font-size:24px;z-index:50}
@media (orientation:landscape){#rotateGate{display:flex}} */
</style>
</head>
<body>
<header>
  <div class="build">Bonechain v4.0 ‚Ä¢ Portrait</div>
  <div class="hud">
    <div class="chip" id="waveChip">Wave 1</div>
    <div class="chip" id="hpChip">HP 50</div>
    <div class="chip" id="soulsChip">Souls 0</div>
    <div class="chip rate" id="rateChip">Block: 0.8s</div>
    <div class="chip" id="bestChip">Best: 0</div>
  </div>
  <button id="btnPause" class="btn" aria-label="Pause">‚è∏</button>
</header>

<main>
  <canvas id="field" width="405" height="720" aria-label="battlefield"></canvas>
</main>

<div id="synergies"></div>

<footer>
  <div class="legend">
    <span class="b b-SK">üíÄ SKEL</span>
    <span class="b b-AR">üèπ ARCH</span>
    <span class="b b-WR">üëª WRAITH</span>
    <span class="b b-DB">‚ò†Ô∏è BLAST</span>
  </div>
  <div id="blockBar" class="bar" aria-label="skill blocks"></div>
</footer>

<!-- reward modal -->
<div id="modalWrap" class="modalWrap" role="dialog" aria-modal="true">
  <div class="modal">
    <h2 id="modalTitle">Choose a Relic</h2>
    <div class="choiceList" id="choiceList"></div>
    <div class="row">
      <button class="btn" id="btnSkip">Skip (+1 Soul)</button>
      <button class="btn" id="btnContinue">Continue</button>
    </div>
  </div>
</div>

<div class="tip" id="tip">Tap 1‚Äì3 matching blocks to <b>summon</b>. Clear a wave ‚Üí pick a <b>relic</b>.</div>

<script>
/*  Bonechain v4.0 ‚Äî ‚ÄúFull game‚Äù single-file prototype
    What‚Äôs included:
    - Block combos (1‚Äì3) that summon/buff/spell (row-aware, preview on hold)
    - Slow, sliding block feed; block-rate shown & modified by relics
    - Units (ally/enemy), boss every 5 waves; enemies stop + fight when in range
    - Relic choices after each wave; composable synergies; upgrades tweak feed & stats
    - Clean UI chips; synergy bar; tutorial tip; localStorage: best wave
*/

///// CONSTANTS & CANVAS ///////////////////////////////////////////////
const W = 405, H = 720;
const ROWS = 18, COLS = 9;
const cellW = W/COLS, cellH = H/ROWS;
const BASE_Y = H * 0.94, BASE_HIT_Y = H * 0.93;

const cvs = document.getElementById('field');
const ctx = cvs.getContext('2d');
const waveEl = document.getElementById('waveChip');
const hpEl = document.getElementById('hpChip');
const soulsEl = document.getElementById('soulsChip');
const rateEl = document.getElementById('rateChip');
const bestEl = document.getElementById('bestChip');
const btnPause = document.getElementById('btnPause');
const bar = document.getElementById('blockBar');
const modalWrap = document.getElementById('modalWrap');
const choiceList = document.getElementById('choiceList');
const btnSkip = document.getElementById('btnSkip');
const btnContinue = document.getElementById('btnContinue');
const tip = document.getElementById('tip');
const syBar = document.getElementById('synergies');

let running = true, last = performance.now(), globalTime = 0;

///// SAVE (best wave) /////////////////////////////////////////////////
const saveKey = 'bc_meta_v40';
let meta = JSON.parse(localStorage.getItem(saveKey) || '{"best":0,"runs":0}');
function saveMeta(){ localStorage.setItem(saveKey, JSON.stringify(meta)); }
bestEl.textContent = 'Best: ' + meta.best;

///// GAME STATE ////////////////////////////////////////////////////////
const TEAMS = {ALLY:'ally', ENEMY:'enemy'};
const STATE = {PLAY:'play', REWARD:'reward', GAMEOVER:'gameover'};
let state = STATE.PLAY;

const game = {
  wave: 1, necroHP: 50, souls: 0,
  units: [], proj: [], fx: [],
  spawnGate: 0.6, volleyT: 0,
  blockRate: 0.8, // seconds per block ‚Äî can be relic-modified
  blockRateMin: 0.25,
  bossEvery: 5,
  synergies: { // track per-run counters / levels
    Legion: 0,   // Skeleton/BoneKnight casts
    Arrowstorm: 0, // Archer/Volley
    Wisp: 0,     // Wraith family
    Doom: 0      // Death Blast casts
  },
  relics: [] // ids of taken relics
};

///// BLOCK BAR (feeder + sliding + preview) ////////////////////////////
const TYPES = ['SK','AR','WR','DB'];
const BAR_COLS = 6, BAR_SIZE = 12;
let blocks = [], spawnFlags = [];
let blockTimer = 0;
function addBlock(type){
  if (blocks.length >= BAR_SIZE) return false;
  blocks.push(type);
  spawnFlags[blocks.length-1] = true;
  return true;
}
function scheduleRefill(dt){
  blockTimer -= dt;
  if (blockTimer <= 0 && blocks.length < BAR_SIZE){
    const k = TYPES[(Math.random()*TYPES.length)|0];
    addBlock(k);
    blockTimer = game.blockRate;
    renderBar();
  }
}
function refillInstantTo(n){ while(blocks.length < Math.min(n, BAR_SIZE)) addBlock(TYPES[(Math.random()*TYPES.length)|0]); }
function symbolFor(k){ return k==='SK'?'üíÄ':k==='AR'?'üèπ':k==='WR'?'üëª':'‚ò†Ô∏è'; }
function colorFor(k){ return k==='SK'?'#a55':k==='AR'?'#5a5':k==='WR'?'#7a67c7':'#b27b55'; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function renderBar(){
  bar.innerHTML = '';
  for (let i=0;i<blocks.length;i++){
    const k = blocks[i], d = document.createElement('div');
    d.className = 'block';
    d.dataset.i = i; d.dataset.k = k;
    d.textContent = symbolFor(k);
    d.style.borderColor = colorFor(k);

    if (spawnFlags[i]){ d.classList.add('spawn'); requestAnimationFrame(()=>d.classList.add('ready')); spawnFlags[i]=false; }
    else d.classList.add('ready');

    d.addEventListener('touchstart', onBlockPreview, {passive:true});
    d.addEventListener('mousedown', onBlockPreview);
    d.addEventListener('touchend', onBlockTap, {passive:true});
    d.addEventListener('mouseup', onBlockTap);
    d.addEventListener('mouseleave', clearPreview);
    d.addEventListener('touchcancel', clearPreview);
    bar.appendChild(d);
  }
  // placeholders keep grid shape
  for (let i=blocks.length;i<BAR_SIZE;i++){
    const ph=document.createElement('div');ph.className='block';ph.style.opacity=.15;ph.style.pointerEvents='none';bar.appendChild(ph);
  }
  rateEl.textContent = 'Block: ' + game.blockRate.toFixed(2) + 's';
}

function rowBoundsOf(index){
  const rowStart = Math.floor(index / BAR_COLS) * BAR_COLS;
  return {rowStart, rowEnd: rowStart + BAR_COLS - 1};
}
function selectionForIndex(i){
  const k = blocks[i]; if (!k) return null;
  const {rowStart, rowEnd} = rowBoundsOf(i);
  // contiguous run in row
  let runStart = i, runEnd = i;
  while (runStart-1 >= rowStart && blocks[runStart-1] === k) runStart--;
  while (runEnd+1 <= rowEnd   && blocks[runEnd+1]   === k) runEnd++;
  const runLen = runEnd - runStart + 1, use = Math.min(3, runLen);
  let sliceStart = i;
  if (use===3) sliceStart = clamp(i-1, runStart, runEnd-2);
  else if (use===2) sliceStart = clamp(i-1, runStart, runEnd-1);
  return {k, use, sliceStart};
}
function onBlockPreview(e){
  const target = e.currentTarget; if (!target.classList.contains('ready')) return;
  const i = +target.dataset.i, sel = selectionForIndex(i); if (!sel) return;
  clearPreview();
  for (let j=0;j<sel.use;j++){
    const idx = sel.sliceStart + j;
    const el = bar.querySelector(`.block[data-i="${idx}"]`);
    if (el) el.classList.add('preview');
  }
}
function clearPreview(){ bar.querySelectorAll('.block.preview').forEach(el=>el.classList.remove('preview')); }
function onBlockTap(e){
  e.preventDefault?.();
  if (state !== STATE.PLAY) return;
  const target = e.currentTarget; if (!target.classList.contains('ready')) return;
  const i = +target.dataset.i, sel = selectionForIndex(i); if (!sel) return;
  // consume
  blocks.splice(sel.sliceStart, sel.use); spawnFlags.splice(sel.sliceStart, sel.use);
  clearPreview(); renderBar();
  cast(sel.k, sel.use);
}

///// CASTING / COMBOS & SYNERGY COUNTS /////////////////////////////////
function addSynergy(kind, amount=1){
  if (kind==='SK' || kind==='BK') game.synergies.Legion += amount;
  if (kind==='AR' || kind==='VOLLEY') game.synergies.Arrowstorm += amount;
  if (kind==='WR' || kind==='WE') game.synergies.Wisp += amount;
  if (kind==='DB') game.synergies.Doom += amount;
  renderSynergies();
}
function cast(k, n){
  if (k==='SK'){
    if (n===1){ spawnSquad('Skeleton', 1); addSynergy('SK'); }
    if (n===2){ spawnSquad('Skeleton', 2); addSynergy('SK',2); }
    if (n===3){ spawnUnit('BoneKnight'); addSynergy('BK'); }
  }else if (k==='AR'){
    if (n===1){ spawnSquad('Archer', 1); addSynergy('AR'); }
    if (n===2){ spawnSquad('Archer', 2); addSynergy('AR',2); }
    if (n===3){ spawnSquad('Archer', 2); game.volleyT = 4; fxText(W*0.5,H*0.82,'VOLLEY!'); addSynergy('VOLLEY'); }
  }else if (k==='WR'){
    if (n===1){ spawnSquad('Wraith', 1); addSynergy('WR'); }
    if (n===2){ spawnSquad('Wraith', 2); addSynergy('WR',2); }
    if (n===3){ spawnUnit('WraithElite'); addSynergy('WE'); }
  }else if (k==='DB'){
    const r = n===1?54:n===2?82:108;
    const stun = n===3?1.2:0;
    aoe(W*0.5, H*0.33, r, 10 + n*6, stun);
    addSynergy('DB');
  }
}

///// UNITS, STATS, SPRITE LOOK /////////////////////////////////////////
function unit(team, kind, hp, atk, rngCells, cd, speed){
  return {team, kind, x:0, y:0, hp, max:hp, atk, rng:rngCells, cd, tAtk:0, speed,
          anim:{hit:0, swing:0, bob:(Math.random()*Math.PI*2)}};
}
function baseUnit(kind){
  // relic modifiers hook
  const mod = (k,v)=>applyMods(k,v);

  switch(kind){
    case 'Skeleton':    return unit(TEAMS.ALLY,'SK', mod('SK.hp',22), mod('SK.atk',6), 1, mod('SK.cd',0.7), mod('SK.spd',160));
    case 'BoneKnight':  return unit(TEAMS.ALLY,'BK', mod('BK.hp',62), mod('BK.atk',11), 1, mod('BK.cd',0.85),mod('BK.spd',150));
    case 'Archer':      return unit(TEAMS.ALLY,'AR', mod('AR.hp',16), mod('AR.atk',7), 4, mod('AR.cd',1.0), mod('AR.spd',165));
    case 'Wraith':      return unit(TEAMS.ALLY,'WR', mod('WR.hp',14), mod('WR.atk',9), 1, mod('WR.cd',0.6), mod('WR.spd',190));
    case 'WraithElite': return unit(TEAMS.ALLY,'WE', mod('WE.hp',26), mod('WE.atk',14),1, mod('WE.cd',0.5), mod('WE.spd',210));
    // enemies
    case 'Goblin':      return unit(TEAMS.ENEMY,'EG', 16 + game.wave*0.6, 5 + game.wave*0.2, 1, 0.9, 155);
    case 'Slinger':     return unit(TEAMS.ENEMY,'ES', 12 + game.wave*0.5, 6 + game.wave*0.25,4, 1.05,165);
    case 'Brute':       return unit(TEAMS.ENEMY,'EB', 40 + game.wave*1.0, 9 + game.wave*0.35,1, 1.0,135);
    case 'Boss':        return unit(TEAMS.ENEMY,'BO', 140 + game.wave*5, 12 + game.wave*0.6, 2, 0.85,120);
  }
  return unit(TEAMS.ENEMY,'EG', 16, 5, 1, 1, 155);
}
function applyMods(key, val){
  // simple multiplicative mod from relics
  let mult = 1;
  for(const r of activeRelics) if (r.mod && r.mod[key]) mult *= r.mod[key];
  return Math.max(1, val*mult);
}
function spawnUnit(kind){
  const u = baseUnit(kind);
  if (u.team===TEAMS.ALLY){
    u.x = W*0.2 + Math.random()*W*0.6;
    u.y = H*0.78 + (Math.random()*cellH - cellH/2);
  }else{
    u.x = W*0.15 + Math.random()*W*0.7;
    u.y = H*0.06 + (Math.random()*cellH*1.5 - cellH*0.75);
  }
  game.units.push(u);
}
function spawnSquad(kind, n){ for(let i=0;i<n;i++) spawnUnit(kind); }

///// WAVES & BOSSES /////////////////////////////////////////////////////
function spawnWave(n){
  // basic ramp + boss every N
  const bossWave = n % game.bossEvery === 0;
  if (bossWave){
    spawnUnit('Boss');
    for(let i=0;i<2+Math.floor(n/5);i++) spawnUnit('Brute');
  }else{
    let g = 4 + Math.floor(n*1.1);
    let s = Math.floor(n/2);
    let b = Math.floor((n-1)/3);
    for(let i=0;i<g;i++) spawnUnit('Goblin');
    for(let i=0;i<s;i++) spawnUnit('Slinger');
    for(let i=0;i<b;i++) spawnUnit('Brute');
  }
}

///// AOE SPELL /////////////////////////////////////////////////////////
function aoe(xc, yc, r, dmg, stun){
  fxRing(xc,yc,r);
  for(const u of game.units){
    if (u.team!==TEAMS.ENEMY || u.hp<=0) continue;
    const dx = u.x - xc, dy = u.y - yc;
    if (Math.hypot(dx,dy) <= r){
      u.hp -= applySpellMods(dmg); u.anim.hit = 0.2;
      u.tAtk = Math.max(u.tAtk, stun||0);
      fxHit(u.x,u.y);
    }
  }
}
function applySpellMods(dmg){
  let val = dmg;
  for(const r of activeRelics) if (r.addSpellDmg) val += r.addSpellDmg;
  for(const r of activeRelics) if (r.mulSpellDmg) val *= r.mulSpellDmg;
  return val;
}

///// TARGETING HELPERS /////////////////////////////////////////////////
function nearest(u, team){
  let best=null, bd=1e9;
  for(const v of game.units){
    if (v.team!==team || v.hp<=0) continue;
    const d = Math.abs(v.x-u.x)+Math.abs(v.y-u.y);
    if (d<bd){bd=d; best=v;}
  }
  return best;
}
function nearestPointTarget(p){
  const want = p.team===TEAMS.ALLY ? TEAMS.ENEMY : TEAMS.ALLY;
  let best=null, bd=1e9;
  for(const u of game.units){
    if (u.team!==want || u.hp<=0) continue;
    const d = Math.abs(u.x-p.x)+Math.abs(u.y-p.y);
    if (d<bd){bd=d; best=u;}
  }
  return best;
}

///// COMBAT LOOP ////////////////////////////////////////////////////////
function shoot(u, target, dmg){
  const ang = Math.atan2(target.y-u.y, target.x-u.x);
  let mult = 1;
  if (game.volleyT>0 && u.kind==='AR') mult *= 1.8;
  for(const r of activeRelics) if (r.mulProjDmg) mult *= r.mulProjDmg;
  game.proj.push({x:u.x, y:u.y, vx:320*Math.cos(ang), vy:320*Math.sin(ang), dmg:dmg*mult, team:u.team, life:1.6});
  u.anim.swing = 0.18;
}
function step(dt){
  if (!running) return;

  globalTime += dt;

  // block feeding
  scheduleRefill(dt);

  if (game.spawnGate>0){
    game.spawnGate -= dt;
    if (game.spawnGate<=0) spawnWave(game.wave);
  }
  if (game.volleyT>0) game.volleyT = Math.max(0, game.volleyT - dt);

  // units
  for(const u of game.units){
    if (u.hp<=0) continue;
    // decay fx
    if (u.anim.hit>0) u.anim.hit = Math.max(0, u.anim.hit - dt);
    if (u.anim.swing>0) u.anim.swing = Math.max(0, u.anim.swing - dt);

    if (u.team===TEAMS.ALLY){
      const e = nearest(u, TEAMS.ENEMY); if (!e) continue;
      const dx = e.x - u.x, dy = e.y - u.y, dist = Math.hypot(dx,dy);
      const rngPx = u.rng * cellH * 0.9; u.tAtk -= dt;

      if (dist <= rngPx){
        if (u.tAtk<=0){
          if (u.rng>1) shoot(u, e, u.atk);
          else { e.hp -= u.atk; fxHit(e.x,e.y); u.anim.swing = 0.12; }
          u.tAtk = u.cd;
        }
      }else{
        const sp = u.speed * dt;
        u.x += sp * Math.sign(dx) * 0.6;
        u.y += sp * Math.sign(dy);
      }
    }else{
      const a = nearest(u, TEAMS.ALLY);
      const tx = a? a.x : u.x, ty = a? a.y : BASE_Y;
      const dx = tx - u.x, dy = ty - u.y, dist = Math.hypot(dx,dy);
      const rngPx = u.rng * cellH * 0.9; u.tAtk -= dt;

      if (a && dist <= rngPx){
        if (u.tAtk<=0){
          if (u.rng>1) shoot(u, a, u.atk);
          else { a.hp -= u.atk; fxHit(a.x,a.y); u.anim.swing = 0.12; }
          u.tAtk = u.cd;
        }
      }else if (!a && u.y >= BASE_HIT_Y){
        u.y = Math.min(u.y, BASE_Y);
        if (u.tAtk<=0){
          let baseDmg = u.atk;
          for(const r of activeRelics) if (r.baseDR) baseDmg *= (1-r.baseDR); // base damage reduction relic
          game.necroHP -= baseDmg; fxText(W*0.5, H*0.95, '-'+Math.round(baseDmg));
          u.tAtk = u.cd;
        }
      }else{
        const sp = u.speed * dt;
        u.x += sp * Math.sign(dx) * 0.4;
        u.y += Math.abs(sp);
      }
    }
    // clamp
    u.x = Math.max(8, Math.min(W-8, u.x));
    u.y = Math.max(8, Math.min(H-8, u.y));
  }

  // projectiles
  for(const p of game.proj){
    p.x += p.vx*dt; p.y += p.vy*dt; p.life -= dt;
    if (p.life<=0) p.dead = true;
    const tgt = nearestPointTarget(p);
    if (tgt && Math.hypot(tgt.x-p.x,tgt.y-p.y) < 8){
      tgt.hp -= p.dmg; fxHit(tgt.x,tgt.y); tgt.anim.hit = 0.2; p.dead = true;
    }
  }
  game.proj = game.proj.filter(p=>!p.dead);

  // cleanup
  for(const u of game.units) if (u.hp<=0 || u.y > H+24) u.dead = true;
  game.units = game.units.filter(u=>!u.dead);

  // wave clear / defeat
  const enemiesLeft = game.units.some(u=>u.team===TEAMS.ENEMY);
  if (!enemiesLeft && game.spawnGate<=0){ onWaveClear(); }
  if (game.necroHP<=0){ onDefeat(); }

  // HUD
  hpEl.textContent = 'HP ' + Math.max(0,Math.round(game.necroHP));
  soulsEl.textContent = 'Souls ' + game.souls;
}

///// FX & RENDER ////////////////////////////////////////////////////////
function fxHit(x,y){ game.fx.push({x,y,t:0.15,type:'hit'}); }
function fxRing(x,y,r){ game.fx.push({x,y,t:0.4, r, type:'ring'}); }
function fxText(x,y,txt){ game.fx.push({x,y,t:1.0, text:txt, type:'text', yo:0}); }

function drawUnit(u){
  const ally = u.team===TEAMS.ALLY;
  const baseColor = (u.kind==='AR') ? '#7ed0ff'
                   : (u.kind==='WR'||u.kind==='WE') ? '#b69aff'
                   : (u.kind==='BK') ? '#e0c078'
                   : (u.kind==='BO') ? '#ff7a7a'
                   : (ally ? '#5ed892' : '#e06a6a');
  const bob = Math.sin(globalTime*3 + u.anim.bob) * 1.5;
  const elite = (u.kind==='BK'||u.kind==='WE'||u.kind==='BO'||u.kind==='EB');
  const scale = elite ? 1.26 : 1.0;
  const glow = elite ? 0.25 : 0;

  ctx.save(); ctx.translate(u.x, u.y + bob);
  if (glow>0){ ctx.fillStyle = baseColor + '33'; ctx.beginPath(); ctx.arc(0,0, 16*scale+3, 0, Math.PI*2); ctx.fill(); }
  const size = 16*scale * (1 + u.anim.hit*0.28);
  ctx.fillStyle = baseColor;
  ctx.beginPath();
  ctx.moveTo(0, -size*0.8);
  ctx.lineTo(size*0.8, 0);
  ctx.lineTo(0, size*0.8);
  ctx.lineTo(-size*0.8, 0);
  ctx.closePath();
  ctx.fill();

  if (u.anim.swing>0){
    ctx.strokeStyle = '#fff9'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0,0, size*0.9, -0.9, -0.9 + u.anim.swing*6); ctx.stroke();
  }
  // hp
  ctx.fillStyle = '#2a2a2a';
  ctx.fillRect(-10, size*0.9, 20, 3.5);
  ctx.fillStyle = '#7cf470';
  ctx.fillRect(-10, size*0.9, 20*(u.hp/u.max), 3.5);

  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  // grid
  ctx.strokeStyle = '#1e1e24';
  for(let r=1;r<ROWS;r++){ ctx.beginPath(); ctx.moveTo(0,r*cellH); ctx.lineTo(W,r*cellH); ctx.stroke(); }
  for(let c=1;c<COLS;c++){ ctx.beginPath(); ctx.moveTo(c*cellW,0); ctx.lineTo(c*cellW,H); ctx.stroke(); }
  // baseline
  ctx.fillStyle = '#24242c'; ctx.fillRect(W*0.05, BASE_Y, W*0.9, 4);

  for(const u of game.units) drawUnit(u);

  // projectiles
  ctx.fillStyle = '#fff';
  for(const p of game.proj){ ctx.beginPath(); ctx.arc(p.x,p.y,2.6,0,Math.PI*2); ctx.fill(); }

  // fx
  for(const f of game.fx){
    f.t -= 1/60;
    if (f.type==='hit'){ ctx.strokeStyle = '#fff8'; ctx.strokeRect(f.x-10,f.y-10,20,20); }
    else if(f.type==='ring'){ ctx.strokeStyle = '#ffdd77aa'; ctx.beginPath(); ctx.arc(f.x,f.y, f.r*(1-f.t/0.4), 0, Math.PI*2); ctx.stroke(); }
    else if(f.type==='text'){ f.yo -= 0.7; ctx.fillStyle = '#ffd45a'; ctx.font='bold 16px system-ui'; ctx.textAlign='center'; ctx.fillText(f.text, f.x, f.y + f.yo); }
  }
  game.fx = game.fx.filter(f=>f.t>0);
}

///// RELICS & SYNERGIES ////////////////////////////////////////////////
const RELIC_POOL = [
  // block rate & economy
  {id:'quickHands', title:'Quick Hands', desc:'Blocks feed 25% faster.', take:()=>{ game.blockRate = Math.max(game.blockRateMin, game.blockRate*0.75);} },
  {id:'darkDeal', title:'Dark Deal', desc:'+2 Souls now, -10% max HP.', take:()=>{ game.souls += 2; game.necroHP = Math.min(game.necroHP, (hpMax()*0.9)); hpEl.textContent='HP '+Math.round(game.necroHP);}},

  // unit damage/health (mods map keys)
  {id:'steelBones', title:'Steel Bones', desc:'Skeletons +20% HP.', mod:{'SK.hp':1.2,'BK.hp':1.1}},
  {id:'poisonWisp', title:'Poison Wisps', desc:'Wraith attacks +25% damage.', mod:{'WR.atk':1.25,'WE.atk':1.25}},
  {id:'fletching', title:'Fine Fletching', desc:'Archer attacks +20%.', mod:{'AR.atk':1.2}},
  {id:'knightOrder', title:'Knight‚Äôs Oath', desc:'Bone Knights +30% HP, -10% CD.', mod:{'BK.hp':1.3,'BK.cd':0.9}},

  // spells & base defense
  {id:'soulflare', title:'Soulflare', desc:'+6 Death Blast damage.', addSpellDmg:6},
  {id:'arcaneFocus', title:'Arcane Focus', desc:'Spell damage x1.2.', mulSpellDmg:1.2},
  {id:'wardingSigil', title:'Warding Sigil', desc:'Base damage taken -20%.', baseDR:0.2},

  // projectiles
  {id:'razorTips', title:'Razor Tips', desc:'Projectile damage x1.15.', mulProjDmg:1.15},

  // synergy escalators
  {id:'legionDrums', title:'Legion Drums', desc:'Every 5 Skeleton casts this run ‚Üí +1 Skeleton (free).'},
  {id:'arrowChorus', title:'Arrow Chorus', desc:'AR-3 (Volley) also grants +10% Ally atk for 5s after it ends.'},
  {id:'doomChill', title:'Doom Chill', desc:'Death Blast 3 briefly slows enemies.'}
];
let activeRelics = [];

function applyRelic(r){
  activeRelics.push(r);
  if (r.take) r.take();
  renderSynergies(); // also re-draw synergy chips (list active relics subtly)
}
function hpMax(){ return 50 + 0; } // placeholder for later meta upgrades

function renderSynergies(){
  // simple readout: synergy counters & active relic count
  syBar.innerHTML = '';
  const make = (name, val)=>{ const d=document.createElement('div');d.className='sy';d.innerHTML=`<span>${name}</span><level>${val}</level>`; syBar.appendChild(d); };
  make('Legion', game.synergies.Legion);
  make('Arrowstorm', game.synergies.Arrowstorm);
  make('Wisp', game.synergies.Wisp);
  make('Doom', game.synergies.Doom);

  // small count of relics
  const r=document.createElement('div');r.className='sy';r.innerHTML=`<span>Relics</span><level>${activeRelics.length}</level>`; syBar.appendChild(r);
}

///// WAVE CLEAR ‚Üí REWARD MODAL /////////////////////////////////////////
function onWaveClear(){
  // payout, escalate, show reward choices
  game.souls += 2 + Math.floor(game.wave/3);
  soulsEl.textContent = 'Souls ' + game.souls;
  fxText(W*0.5, H*0.08, `WAVE ${game.wave} CLEAR!`);

  state = STATE.REWARD;
  running = false;
  openReward();
}
function openReward(){
  modalWrap.style.display='flex';
  document.getElementById('modalTitle').textContent = `Choose a Relic (Wave ${game.wave})`;
  choiceList.innerHTML = '';

  // pick 3 distinct relics (weighted lightly: more ‚Äúcore‚Äù early)
  const pool = RELIC_POOL.filter(r=>!activeRelics.find(a=>a.id===r.id));
  const picks = [];
  while(picks.length<3 && pool.length>0){
    const i = (Math.random()*pool.length)|0;
    picks.push(pool.splice(i,1)[0]);
  }

  picks.forEach(r=>{
    const row=document.createElement('div');row.className='choice';
    const left=document.createElement('div');left.style.flex='1';
    const title=document.createElement('div');title.className='title';title.textContent=r.title;
    const desc=document.createElement('div');desc.className='desc';desc.textContent=r.desc;
    left.appendChild(title); left.appendChild(desc);

    const take=document.createElement('button');take.className='take';take.textContent='Take';
    take.onclick=()=>{ applyRelic(r); closeReward(true); };

    row.appendChild(left); row.appendChild(take);
    choiceList.appendChild(row);
  });

  btnSkip.onclick=()=>{ game.souls += 1; closeReward(true); };
  btnContinue.onclick=()=> closeReward(false);
}
function closeReward(proceed){
  modalWrap.style.display='none';
  state = STATE.PLAY;
  running = true;

  // start next wave
  game.wave++;
  waveEl.textContent = 'Wave ' + game.wave;
  game.spawnGate = 0.9;

  // tiny bonus: inject one guaranteed block (still feeds with slide)
  addBlock(Math.random()<0.5?'SK':'AR');
  renderBar();
}

///// DEFEAT / GAME OVER ////////////////////////////////////////////////
function onDefeat(){
  running=false; state=STATE.GAMEOVER;
  fxText(W*0.5, H*0.5, 'DEFEAT');
  meta.best = Math.max(meta.best, game.wave-1); meta.runs++; saveMeta();
  bestEl.textContent = 'Best: ' + meta.best;

  // quick restart prompt via reward modal UI
  modalWrap.style.display='flex';
  document.getElementById('modalTitle').textContent = `Defeat ‚Ä¢ Reached Wave ${game.wave-1}`;
  choiceList.innerHTML = '';
  const row=document.createElement('div');row.className='choice';
  row.innerHTML = `<div><div class="title">Run it back?</div><div class="desc">Best wave: ${meta.best} ‚Ä¢ Runs: ${meta.runs}</div></div>`;
  choiceList.appendChild(row);
  btnSkip.textContent = 'Quit';
  btnContinue.textContent = 'Restart';
  btnSkip.onclick = ()=>location.reload();
  btnContinue.onclick = ()=>location.reload();
}

///// LOOP & UI /////////////////////////////////////////////////////////
function loop(now){
  const dt = Math.min((now-last)/1000, 1/30); last = now;
  if (running) step(dt);
  draw();
  requestAnimationFrame(loop);
}
btnPause.onclick = ()=>{
  if (state!==STATE.PLAY) return;
  running = !running; btnPause.textContent = running?'‚è∏':'‚ñ∂Ô∏è';
  tip.style.display = running?'block':'none';
};

///// BOOT //////////////////////////////////////////////////////////////
function boot(){
  renderSynergies();
  refillInstantTo(6); // seed top row
  renderBar();
  waveEl.textContent = 'Wave ' + game.wave;
  hpEl.textContent = 'HP ' + game.necroHP;
  soulsEl.textContent = 'Souls ' + game.souls;
  requestAnimationFrame(loop);

  // fade tip after a few seconds
  setTimeout(()=> tip.style.display='none', 5000);
}
boot();
</script>
</body>
</html>
