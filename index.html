<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
<title>Auto Battler (Mobile)</title>
<style>
  html,body{margin:0;padding:0;background:#121214;height:100%;font-family:-apple-system,system-ui,sans-serif;overscroll-behavior:none}
  canvas{position:fixed;left:0;top:0;width:100vw;height:100vh;touch-action:manipulation;display:block}
  #toast{position:fixed;top:10px;left:50%;transform:translateX(-50%);padding:8px 12px;background:#222;color:#eee;border-radius:8px;font-size:14px;opacity:0;transition:opacity .15s;pointer-events:none}
  #toast.show{opacity:0.95}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="toast"></div>
<script>
(() => {
  // ===== Canvas / UI =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  const toastEl = document.getElementById('toast');
  let toastTimer = null;
  function toast(msg){ toastEl.textContent = msg; toastEl.classList.add('show'); clearTimeout(toastTimer); toastTimer=setTimeout(()=>toastEl.classList.remove('show'),1200); }

  function resize(){
    const dpr = Math.max(1, devicePixelRatio||1);
    const w = innerWidth, h = innerHeight;
    canvas.width = Math.floor(w*dpr);
    canvas.height = Math.floor(h*dpr);
    canvas.style.width = w+'px';
    canvas.style.height = h+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ===== Layout =====
  const COLS=5, ROWS=3, UI_H=160;
  function layout(){
    const cell = Math.floor(Math.min(innerWidth/COLS, (innerHeight-UI_H)/ROWS));
    const gridW = COLS*cell, gridH = ROWS*cell;
    const originX = Math.floor((innerWidth - gridW)/2);
    const originY = 24;
    return {cell, gridW, gridH, originX, originY};
  }
  let L = layout();
  addEventListener('resize', ()=>{ L = layout(); });

  // ===== Colors & Units =====
  const C = { bg:'#121214', grid:'#282828', ui:'#1e1e1e', hpBack:'#333', hp:'#e42828',
              b:'#c8503c', a:'#50c85a', c:'#78b4dc', e:'#a0a0a0', t:'#eaeaea', td:'#d8c878', start:'#7a50a0',
              ghost:'rgba(255,255,255,.22)', hint:'#9ee' };

  const UNIT = {
    Brawler:{hp:120, atk:18, spd:1.0, range:1, color:C.b, role:"melee"},
    Archer:{hp:70,  atk:25, spd:0.8, range:3, color:C.a, role:"ranged"},
    Cleric:{hp:80,  atk:8,  spd:1.0, range:3, color:C.c, role:"healer"},
  };

  // ===== Game State =====
  let gold=6;
  let floorN=1, state='shop', result=null;
  const roster=[], enemies=[];
  let shop=[], preview=null;
  const buyAreas=[]; let startArea={x:0,y:0,w:0,h:0};
  let hover = {x:-1,y:-1};

  function refillShop(){
    const keys = Object.keys(UNIT);
    shop = Array.from({length:3},()=>keys[Math.floor(Math.random()*keys.length)]);
  }
  function mkUnit(name, team, cell=null){
    const d = UNIT[name];
    return {
      name, team, cell,
      alive:true, maxhp:d.hp, hp:d.hp, atk:d.atk, spd:d.spd, range:d.range, color:d.color, role:d.role,
      cool: Math.random()/d.spd, stepCool: 0, lastPos: null
    };
  }

  // ===== Enemies =====
  function spawnEnemies(){
    enemies.length=0;
    const count = (floorN===1)? 2 : 3;
    const cols=[4,3,4,3];
    for(let i=0;i<count;i++){
      const hp = Math.floor(90 + floorN*8);
      const atk = Math.floor(10 + floorN*3);
      enemies.push({name:'Enemy', team:'enemy', cell:{x:cols[i%cols.length], y:i%3}, alive:true, maxhp:hp, hp, atk, spd:1.0, range:1, color:C.e, role:'melee', cool: Math.random(), stepCool: 0, lastPos: null});
    }
    toast(`Enemies spawned: ${count}`);
  }

  const playersAlive=()=>roster.filter(u=>u.alive && u.cell);
  const enemiesAlive=()=>enemies.filter(u=>u.alive);

  // ===== Drawing =====
  const fill=(x,y,w,h,c)=>{ ctx.fillStyle=c; ctx.fillRect(x,y,w,h); };
  const stroke=(x,y,w,h,c)=>{ ctx.strokeStyle=c; ctx.strokeRect(x,y,w,h); };
  const text=(t,x,y,s=16,c=C.t)=>{ ctx.fillStyle=c; ctx.font=`${s}px -apple-system,system-ui,sans-serif`; ctx.fillText(t,x,y); };

  function drawUnit(u){
    if(!u.alive || !u.cell) return;
    const gx = L.originX + u.cell.x*L.cell, gy = L.originY + u.cell.y*L.cell;
    fill(gx+8, gy+8, L.cell-16, L.cell-16, u.color);
    const w=L.cell-20, hpw=Math.max(0, Math.floor(w*u.hp/u.maxhp));
    fill(gx+10, gy+L.cell-28, w, 6, '#333');
    fill(gx+10, gy+L.cell-28, hpw, 6, C.hp);
  }

  // ===== Targeting (frontline) =====
  function frontlineTarget(attacker, targets) {
    if (!targets.length) return null;
    let front;
    if (attacker.team === 'enemy') { // enemies hit our RIGHTMOST first
      const maxX = Math.max(...targets.map(t => t.cell.x));
      front = targets.filter(t => t.cell.x === maxX);
    } else { // we hit their LEFTMOST first
      const minX = Math.min(...targets.map(t => t.cell.x));
      front = targets.filter(t => t.cell.x === minX);
    }
    const sameRow = front.filter(t => t.cell.y === attacker.cell.y);
    if (sameRow.length) front = sameRow;
    front.sort((a,b) => (a.hp/a.maxhp) - (b.hp/b.maxhp));
    return front[0];
  }

  // ===== Range rules =====
  const isAdjCross = (a,b)=> !!a && !!b && (Math.abs(a.cell.x-b.cell.x)+Math.abs(a.cell.y-b.cell.y)===1);
  function inRange(attacker, target){
    if (!attacker || !target) return false;
    const dx = Math.abs(target.cell.x - attacker.cell.x);
    const dy = Math.abs(target.cell.y - attacker.cell.y);
    if (attacker.role === 'melee') return (dx+dy)===1; // cross-adjacent only
    // ranged/healer: MANHATTAN range (feels better on small grid)
    return (dx + dy) <= Math.max(1, attacker.range);
  }

  // ===== Occupancy =====
  function occupiedAt(x,y){
    return playersAlive().some(u=>u.cell.x===x && u.cell.y===y) ||
           enemiesAlive().some(u=>u.cell.x===x && u.cell.y===y);
  }
  const key=(x,y)=>`${x},${y}`;

  // ===== BFS to any cross-adjacent cell around target (with “don’t step past target” rule) =====
  function nextStepBFS(u, target, reservations){
    if (!target) return null;
    const start = {x:u.cell.x, y:u.cell.y};
    const tx = target.cell.x, ty = target.cell.y;
    const goals = [];
    const adj = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of adj){
      const gx = tx + dx, gy = ty + dy;
      if (gx<0||gx>=COLS||gy<0||gy>=ROWS) continue;
      // goal must be free (or it's our own tile)
      if (!occupiedAt(gx,gy) || (gx===start.x && gy===start.y)) goals.push({x:gx,y:gy});
    }
    if (!goals.length) return null;

    const dq=[start], came=new Map();
    came.set(key(start.x,start.y), null);

    function valid(nx,ny,px,py){
      if(nx<0||nx>=COLS||ny<0||ny>=ROWS) return false;
      // prevent stepping PAST target column
      if (u.team==='player' && nx>tx) return false;
      if (u.team==='enemy'  && nx<tx) return false;
      // block occupied/reserved except our own start
      if (occupiedAt(nx,ny) && !(nx===start.x && ny===start.y)) return false;
      if (reservations.has(key(nx,ny)) && !(nx===start.x && ny===start.y)) return false;
      // avoid immediate ping-pong to lastPos if possible
      if (u.lastPos && nx===u.lastPos.x && ny===u.lastPos.y) return false;
      return true;
    }

    while(dq.length){
      const cur = dq.shift();
      if (goals.some(g=>g.x===cur.x && g.y===cur.y)){
        // reconstruct first step
        let path=[cur], k=key(cur.x,cur.y);
        while(came.get(k)){
          const p=came.get(k); path.push(p); k=key(p.x,p.y);
        }
        path.reverse();
        return path[1] || null;
      }
      for (const [dx,dy] of adj){
        const nx=cur.x+dx, ny=cur.y+dy;
        const nk=key(nx,ny);
        if (came.has(nk)) continue;
        if (!valid(nx,ny,cur.x,cur.y)) continue;
        came.set(nk, cur);
        dq.push({x:nx,y:ny});
      }
    }
    return null;
  }

  // ===== Step wrapper (melee only) =====
  function tryStepToward(u, target, reservations){
    if (!target || u.role !== 'melee') return false;
    if (isAdjCross(u,target)) return false;
    if (u.stepCool > 0) return false;

    const step = nextStepBFS(u, target, reservations);
    if (step){
      u.lastPos = {x:u.cell.x, y:u.cell.y};
      u.cell.x = step.x; u.cell.y = step.y;
      u.stepCool = 0.18;
      reservations.add(key(step.x, step.y));
      return true;
    }
    // small delay to avoid jitter when blocked
    u.stepCool = 0.12;
    return false;
  }

  // ===== Battle =====
  function battleTick(dt){
    // Immediate end (prevents stray damage frames)
    if (!playersAlive().length){ state='result'; result='lose'; return; }
    if (!enemiesAlive().length){ state='result'; result='win'; gold += 2 + Math.floor(floorN/2); return; }

    // --- Players move/act ---
    {
      const reservations = new Set();
      for(const u of playersAlive()){
        u.cool -= dt;
        if (u.stepCool>0) u.stepCool -= dt;

        const tgt = frontlineTarget(u, enemiesAlive());

        // movement (melee only) if not already adjacent
        if (tryStepToward(u, tgt, reservations)) {
          // allow immediate attack this beat if now in range (prevents “only one hits” feeling)
          if (u.cool < 0) u.cool = 0;
        }

        // attack
        if(u.cool<=0){
          let did = false;
          if(u.role==='healer'){
            const allies=playersAlive();
            if(allies.length){
              allies.sort((a,b)=>(a.hp/a.maxhp)-(b.hp/b.maxhp));
              allies[0].hp = Math.min(allies[0].maxhp, allies[0].hp+20);
            }
            const t=frontlineTarget(u,enemiesAlive());
            if(inRange(u,t)){
              t.hp -= Math.max(4, Math.floor(u.atk*0.5));
              if(t.hp<=0) t.alive=false; did = true;
            }
          }
          if(!did && u.role!=='healer'){
            const t=frontlineTarget(u,enemiesAlive());
            if(u.role==='melee' ? isAdjCross(u,t) : inRange(u,t)){
              t.hp -= u.atk;
              if(u.name==='Brawler'){
                // splash to horizontal neighbor of target
                const mates=enemiesAlive().filter(e=>e!==t && e.cell.y===t.cell.y && Math.abs(e.cell.x - t.cell.x)===1);
                if(mates[0]) mates[0].hp -= Math.floor(u.atk*0.5);
              }
              if(t.hp<=0) t.alive=false;
            }
          }
          u.cool = 1/u.spd;
        }
      }
    }

    // Mid-tick end check
    if (!playersAlive().length){ state='result'; result='lose'; return; }
    if (!enemiesAlive().length){ state='result'; result='win'; gold += 2 + Math.floor(floorN/2); return; }

    // --- Enemies move/act ---
    {
      const reservations = new Set();
      for(const e of enemiesAlive()){
        e.cool -= dt;
        if (e.stepCool>0) e.stepCool -= dt;

        const tgt = frontlineTarget(e, playersAlive());

        if (tryStepToward(e, tgt, reservations)) {
          if (e.cool < 0) e.cool = 0;
        }

        if(e.cool<=0){
          const t = frontlineTarget(e, playersAlive());
          if(e.role==='melee' ? isAdjCross(e,t) : inRange(e,t)){
            t.hp -= e.atk; if(t.hp<=0) t.alive=false;
          }
          e.cool = 1/e.spd;
        }
      }
    }
  }

  // ===== Render =====
  function draw(dt){
    // Background & grid
    ctx.fillStyle=C.bg; ctx.fillRect(0,0,innerWidth,innerHeight);
    for(let c=0;c<COLS;c++) for(let r=0;r<ROWS;r++)
      stroke(L.originX + c*L.cell, L.originY + r*L.cell, L.cell, L.cell, C.grid);

    // Tips
    if (state==='placing'){
      text('Drag & release to place. Tap outside grid to cancel.', L.originX, Math.max(16, L.originY-6), 12, C.hint);
    } else if (state==='shop'){
      text('Tip: Tap a unit on the left to move it.', L.originX, Math.max(16, L.originY-6), 12, C.hint);
    } else if (state==='result'){
      text('Tap anywhere to continue…', L.originX, Math.max(16, L.originY-6), 12, C.hint);
    }

    // Units
    roster.forEach(drawUnit);
    enemies.forEach(drawUnit);

    // UI bottom bar
    const y0 = L.originY + L.gridH + 8;
    fill(0,y0,innerWidth,160,C.ui);

    buyAreas.length=0;
    for(let i=0;i<3;i++){
      const x=8+i*150, y=y0+8;
      fill(x,y,140,80,'#3c3c3c');
      text(shop[i], x+8, y+32, 20);
      text('Buy 2', x+8, y+60, 16, C.td);
      buyAreas.push({x,y,w:140,h:80,i});
    }

    text(`Gold: ${gold}`, 8, y0+110, 16);
    text(`Floor: ${floorN}`, 140, y0+110, 16);

    startArea = { x: innerWidth-160, y: y0+48, w:140, h:44 };
    fill(startArea.x, startArea.y, startArea.w, C.start);
    text('START', startArea.x+26, startArea.y+30, 24);

    if(state==='result'){
      text((result==='win')?'Victory!':'Defeated.', innerWidth/2-50, innerHeight/2-10, 28);
      text('Tap to continue', innerWidth/2-70, innerHeight/2+20, 16);
    }

    if(state==='battle') battleTick(dt);
  }

  // ===== Input / Placement =====
  const pointInRect=(x,y,r)=> x>=r.x && y>=r.y && y<=r.y+r.h && x<=r.x+r.w;

  function cellAtFloor(px,py){ return { x: Math.floor((px - L.originX)/L.cell), y: Math.floor((py - L.originY)/L.cell) }; }
  function cellAtRound(px,py){ return { x: Math.round((px - L.originX)/L.cell), y: Math.round((py - L.originY)/L.cell) }; }
  function unitAtCell(c,r){ return roster.find(u => u.cell && u.cell.x===c && u.cell.y===r && u.alive) || null; }
  function inLeftCols(c,r){ return (c>=0 && c<=1 && r>=0 && r<ROWS); }

  function placeExactAt(c,r){
    const fc = Math.max(0, Math.min(1, c));
    const fr = Math.max(0, Math.min(ROWS-1, r));
    if (!inLeftCols(c,r)){
      if (preview && preview._fromPickup && preview._fromCell){
        preview.cell = {...preview._fromCell};
        roster.push(preview);
        toast('Move cancelled');
        preview = null;
        state='shop';
        return false;
      }
    toast('Place in left two columns'); return false;
    }
    if (unitAtCell(c,r)){ toast('Cell occupied'); return false; }
    preview.cell = {x:c,y:r};
    roster.push(preview);
    toast(`${preview._fromPickup ? 'Moved' : 'Placed'} ${preview.name} @ ${c},${r}`);
    preview = null; state='shop'; return true;
  }

  function clientToCanvas(e){
    const rect = canvas.getBoundingClientRect();
    let cx, cy;
    if (e.changedTouches && e.changedTouches[0]) { cx = e.changedTouches[0].clientX; cy = e.changedTouches[0].clientY; }
    else if (e.touches && e.touches[0])           { cx = e.touches[0].clientX;        cy = e.touches[0].clientY; }
    else                                           { cx = e.clientX;                   cy = e.clientY; }
    return { x: cx - rect.left, y: cy - rect.top };
  }

  function onPointerDown(e){
    const p = clientToCanvas(e);
    hover.x = p.x; hover.y = p.y;

    // Continue from result
    if (state==='result'){
      if (result==='win'){ floorN++; toast(`Floor ${floorN}`); }
      else { roster.length=0; enemies.length=0; gold=6; floorN=1; toast('Run reset'); }
      result=null; state='shop'; enemies.length=0; refillShop();
      e.preventDefault(); return;
    }

    if (state==='placing' && preview){ e.preventDefault(); return; }

    if(state==='shop' && !preview){
      // Pick up existing
      const ccF = cellAtFloor(p.x,p.y);
      if (inLeftCols(ccF.x, ccF.y)){
        const u = unitAtCell(ccF.x, ccF.y);
        if (u){
          const idx = roster.indexOf(u);
          if (idx>=0) roster.splice(idx,1);
          preview = u;
          preview._fromPickup = true;
          preview._fromCell = {x:ccF.x, y:ccF.y};
          state='placing';
          toast(`Picked up ${u.name}`);
          e.preventDefault(); return;
        }
      }
      // Buy
      for(const r of buyAreas){
        if(pointInRect(p.x,p.y,r) && gold>=2){
          gold -= 2;
          preview = mkUnit(shop[r.i], 'player', null);
          preview._fromPickup = false;
          preview._fromCell = null;
          state='placing';
          toast(`Bought ${shop[r.i]}`);
          e.preventDefault(); return;
        }
      }
      // Start
      if(pointInRect(p.x,p.y,startArea) && roster.some(u=>u.alive && u.cell)){
        spawnEnemies(); state='battle'; e.preventDefault(); return;
      }
    }
  }
  function onPointerMove(e){ const p = clientToCanvas(e); hover.x = p.x; hover.y = p.y; }
  function onPointerUp(e){
    const p = clientToCanvas(e); hover.x = p.x; hover.y = p.y;
    if(state==='placing' && preview){
      let c = cellAtRound(hover.x, hover.y).x;
      let r = cellAtRound(hover.x, hover.y).y;
      c = Math.max(0, Math.min(COLS-1, c));
      r = Math.max(0, Math.min(ROWS-1, r));
      placeExactAt(c, r);
      e.preventDefault(); return;
    }
  }

  canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
  canvas.addEventListener('pointermove', onPointerMove, {passive:false});
  canvas.addEventListener('pointerup',   onPointerUp,   {passive:false});
  canvas.addEventListener('touchstart', onPointerDown, {passive:false});
  canvas.addEventListener('touchmove',  onPointerMove, {passive:false});
  canvas.addEventListener('touchend',   onPointerUp,   {passive:false});

  // ===== Boot =====
  refillShop();
  let last = performance.now();
  function loop(ts){
    const dt = Math.min(0.05, (ts-last)/1000); last = ts;
    draw(dt);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
